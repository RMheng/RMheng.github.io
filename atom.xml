<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rww&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/875500b7339ad8bf5d54b6a28209fad0</icon>
  <subtitle>半夏花已开，未来诚可期</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-29T13:31:15.281Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rmheng</name>
    <email>2961930359@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Keystone EuroSys20</title>
    <link href="http://yoursite.com/2021/01/29/keystone-2020/"/>
    <id>http://yoursite.com/2021/01/29/keystone-2020/</id>
    <published>2021-01-29T09:53:50.000Z</published>
    <updated>2021-01-29T13:31:15.281Z</updated>
    
    <content type="html"><![CDATA[<p>Keystone论文的精读笔记~</p><a id="more"></a><p>Keystone是第一个用于构造<strong>定制TEE</strong>的开源框架。Keystone使用硬件提供的简单抽象比如内存隔离和不可信组件（比如操作系统）下的可编程层。Keystone在这些抽象中（memory isolation，programmable layer underneath untrusted components）构造可重复使用的TEE core primitives，同时允许特定于平台的修改和硬件特性。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>（简单地介绍一下TEE）</p><p>TEE被广泛地应用于诸如安全云服务、数据库、大数据计算、安全银行、区块链共识协议等场景中。</p><p>弊端：任何一个vendor TEE仅支持针对威胁模型、硬件需求、资源管理、移植操作以及功能兼容性的一小部分设计空间。一旦，一个软件开发者选择了一个特定的硬件平台，无论他们的实际需求是什么，他们都会被锁定在对应固定的硬件平台中。现有的TEE解决方案不管是在RISC-V平台或者是OpenSPARC中，进行重新设计都需要耗费巨大的经历，并且仅仅另一个固定的设计点中起效。（这边举了一个sgx的例子，SGXv1在设计之初只支持固定的enclave大小并且缺乏I/O和系统调用，所以就造成TCB非常大，尽管研究人员们提出了很多复杂的解决方法，但仅有intel能够对内部设计进行更改，所以用户得等到SGXv2，才能拥有动态的enclave虚拟内存。）</p><p>为了利用riscv的原语构造一个高可定制的TEE，keystone主张硬件必须提供安全原语而非点到点的解决方案。（将一部分重要的原语信息暴露给软件将会带来更好的用户定制效果）<strong>Keystone的宗旨是通过借鉴模块化内核的概念，允许一组通用的软件模块根据硬件平台和用例调整特性和安全模型。</strong></p><p>可定制化的TEEs的概念是允许实体创建一个硬件，操作它，并在相同的基准上构造和配置不同的TEE设计。（也就是同样的硬件，硬件通过提供原语，开发者可以根据这些提供的原语构造出针对不同用户需求和威胁模型的TEEs）</p><p><strong>作者考虑的需求</strong></p><ul><li>在不可信OS下构造a highly programmable trusted layer；</li><li>将资源管理、虚拟化以及信任边界的隔离机制解耦（hypervisor是负责安全和虚拟化的可编程层，将我们的需求变得复杂化；而硬件和微代码并不满足可编程的需求。另外，也不应该依赖于硬件隔离来实现一个固定的安全和非安全边界）</li></ul><p>–》构造一个common，portable的软件基来适应千变万化的硬件功能和用户需求</p><p>Keystone是第一个用于构造可定制TEE的开源框架。使用physical memory protection(PMP)。PMP通过利用RISC-V中的programmable machine mode来指定对物理内存区域的任意保护。keystone中使用该machine mode来运行一个security monitor（SM）在无需进行资源管理的同时提供安全边界。</p><p>每个enclave运行在各自的隔离物理内存区域，并且拥有自己的supervisor-mode runtime（RT）组件来管理enclave的虚拟内存。</p><p>基于这个设计，RT主要是完成特定于enclave的功能，而SM管理硬件完成的保证。RT仅完成特定的功能，比如说和SM进行通信，通过共享内存与主机进行通信，为enclave user-mode application（eapp）提供服务。（与安全无关的功能）</p><p>SM利用hardware primitives来提供对诸如secure boot，memory isolation以及attestation等TEE保证。而RT提供诸如系统调用接口，标准libc支持，in-enclave虚拟内存管理，自分页等enclave内部的功能性模块。<em>SM利用了一切可利用的硬件来构造额外的安全机制，比如highly configurable cache controller，与PMP协调，来抵御cache side-channel。</em>（这块的抵御侧信道攻击需要仔细看一下）</p><p><strong>总结</strong>：作者提出了当前TEEs的各种问题，然后提出了定制TEEs的概念（这个定制TEEs的概念其实也是从SDN中派生出来的），然后提出了自己对定制TEEs的需求，接着提出了设计理念。</p><p>作者构造了Keystone，两个RTs（自己制作的RT-Eyrie和一个现成的微内核seL4）以及几个模块，这些模块可以供由enclave绑定的user application选择性地配置和使用功能。</p><p><img src="/2021/01/29/keystone-2020/1.png" alt="image-20200914110304034"></p><p><strong>贡献</strong></p><ul><li>customizable TEEs. 定义了一个新的范式，基于这样的一个范式，硬件制造商、开发商以及enclave开发人员能够定制自己的TEE；</li><li>Keystone框架。本文提供了第一个用于配置、建立以及实例化可定制TEEs的框架。主要方法是通过保证Keystone的模块化来根据需求定制TEE instances。</li><li>开源实现。在无需任何微架构的修改能够适应威胁模型、使用硬件特性、处理工作负载并且提供丰富的功能。</li><li>基准测试和实际应用。基于CoreMark,Beebs,RV8, IOZone来评估了Keystone，使用seL4搭载的Torchin Eyrie，FANN演示了真实世界中使用keystone的机器学习负载和一个keystone本地安全远程计算应用程序。最后演示对具有物理访问权限的攻击者的防御。</li></ul><h2 id="2-不同TEE的共同基准"><a href="#2-不同TEE的共同基准" class="headerlink" title="2 不同TEE的共同基准"></a>2 不同TEE的共同基准</h2><h3 id="2-1-商用TEEs"><a href="#2-1-商用TEEs" class="headerlink" title="2.1 商用TEEs"></a>2.1 商用TEEs</h3><p>目前很多的商用TEEs迎合特定且容易受到攻击的用例，但是仅仅在设计空间中仅考虑到了一部分。假设考虑在不可信云环境下的服务器运行高负载的程序，比如ML inferences。</p><ul><li>基于intel SGX的解决方案需要很大的软件栈来扩展额外支持的功能</li><li>AMD SEV-based solution用一个巨大的TCB隔离一个完整的VM（不管是SGX还是SEV，如果要考虑防御侧信道攻击，还需要格外的用户空间软件机制）</li><li>如果在IoT设备或者边缘感应器上，就需要考虑TrustZone，TrustZone位于一个叫secure world由硬件实现隔离的区域，但进一步的隔离需要基于软件的Secure world OS解决办法在secure application之间进行多路复用。</li></ul><p>一个新的研究方向是使用a thin layer of trusted software，类似于在kernel设计中的reference monitor。这样的设计能够抵御强大的攻击者且能够包含一个小的TCB。</p><ul><li><p>sanctum对硬件进行了修改为RISC-V构造user-space enclave。</p></li><li><p>Komodo：提供了一个verified monitor，该monitor能够在ARM TrustZone上运行</p></li></ul><h3 id="2-2-可定制的TEE"><a href="#2-2-可定制的TEE" class="headerlink" title="2.2 可定制的TEE"></a>2.2 可定制的TEE</h3><p>customizable TEEs：使用一个共同的软件框架，根据用户不同的需求来定制一个特定的TEE。硬件提供商仅需要提供基础的原语。实现一个特定的TEE实例需要涉及平台提供商对硬件接口，可信模型以及enclave开发人员的功能性需求。实体可以根据自己的需求把特定的模块组合起来实例化成一个特定的TEE。</p><p>现在的商用TEE系统都提供了固定的与各自的硬件平台相关的威胁模型。</p><ul><li>intel SGX不支持任何针对它的内存保护措施的修改，那么sgx对于不需要昂贵的内存加密的用例来说是不必要的</li><li>ARM TrustZone并不适合用来构造一个模块化的TEE（TrustZone的设计核心就是只分成了两个区域）如果有多个enclaves，还必须使用MMU（内存管理单元）</li><li>RISC-V基于machine mode和PMP寄存器提供per-hardware-thread 的物理内存视图（RISC-V同时允许多线程的enclave访问不相交的内存区域，同时允许enclave使用supervisor mode以及MMU）</li></ul><p>支持Keystone的安全硬件平台必须满足：</p><ul><li>仅对trusted boot process可见的device-specific secret key</li><li>a hardware source of randomness</li><li>a trusted boot process</li></ul><h3 id="2-3-TEE生命周期中的实体"><a href="#2-3-TEE生命周期中的实体" class="headerlink" title="2.3 TEE生命周期中的实体"></a>2.3 TEE生命周期中的实体</h3><ul><li>hardware manufacturer：负责设计和制造RISC-V硬件，包括trusted boot的相关IP</li><li>Keystone platform provider：购买制造商生产的硬件，操作硬件，并使之能够给它的客户使用，配置SM；</li><li>Keystone programmer：开发Keystone软件组件，包括SM，RT和eapps</li><li>Keystone user：选择RT和eapp的配置来构造一个Keystone，实例化一个能在Keystone platform provider提供的硬件上运行的enclave</li><li>Eapp user：与TEE中运行的eapp进行交互</li></ul><p>Acme 公司将他们的网站托管在 Apache 服务器上，该服务器运行在 Cloud 公司提供的一个基于 Keystone的安全区云服务上，该云服务基于 Bar 公司制造的硬件。   </p><p><strong>例子</strong></p><ul><li>Acme Corp：Keystone user</li><li>Apache webserver：eapp programmer</li><li>Bar Corp：hardware manufacturer</li><li>Cloud Corp提供云服务：Keystone platform provider，RT programmer，SM programmer</li></ul><h2 id="3-Keystone概览"><a href="#3-Keystone概览" class="headerlink" title="3 Keystone概览"></a>3 Keystone概览</h2><p>简单介绍一下RISC-V：RISC-V是一个有着不同开源内核实现的开源ISA。它支持4种特权模式：</p><ul><li>U-mode（user）：user-space processes</li><li>S-mode（supervisor）：kernel</li><li>H-mode（hypervisor）：hypervisor</li><li>M-mode（machine）：对物理资源的直接访问</li></ul><h3 id="3-1-设计原则"><a href="#3-1-设计原则" class="headerlink" title="3.1 设计原则"></a>3.1 设计原则</h3><ul><li>利用不可信代码下的可编程层和隔离原语。SM使用M-mode的特性来实现TEE保证：1）对平台提供者来说是可编程的；2）满足对于最小范围的最高特权级别的需求；3）在系统中控制系统中断和异常的代理；4）使用M-mode控制PMP，保证在运行时memory-mapped control features的隔离。（保证在运行时隔离内存映射功能）</li><li>解耦资源管理和安全检查。SM在最高权限以最少的代码实施安全策略，几乎只完成安全相关的功能。而S-mode的RT负责在enclave中运行的user code的生命周期，管理内存，系统调用，与SM进行通信，使用SBI（supervisor binary interface）代表eapp请求SM的操作。</li><li>设计模块化的层。Keystone使用模块化的层次（SM，RT，eapp）来支持不同的工作负载。（每个层都是独立的，上一层的安全性可以由下一层来进行检查？）</li><li>允许细粒度的TCB配置。Keystone可以根据用户的需求来实例化一个拥有最小TCB的TEEs、</li></ul><h3 id="3-2-Keystone-Enclave工作流"><a href="#3-2-Keystone-Enclave工作流" class="headerlink" title="3.2 Keystone Enclave工作流"></a>3.2 Keystone Enclave工作流</h3><p>platform用一个比较合适的硬件配置和安全扩展来初始化SM，这些安全扩展能够带来额外的隔离保证，比如cache partitioning；enclave开发者使用诸如virtual memory management和系统调用等丰富的功能来编写eapps和RTs。</p><p><img src="/2021/01/29/keystone-2020/2.png" alt="image-20200914221209627"></p><h3 id="3-3-编写eapps"><a href="#3-3-编写eapps" class="headerlink" title="3.3 编写eapps"></a>3.3 编写eapps</h3><p>对于编写enclave application，Keystone提供了3种方法：（用英文原文）</p><ul><li>独立的Keystone原生eapps</li><li>具有RT支持的未修改的RISC-V binaries</li><li>partitioned application running in the selected parts in the enclave</li></ul><h3 id="3-4-威胁模型"><a href="#3-4-威胁模型" class="headerlink" title="3.4 威胁模型"></a>3.4 威胁模型</h3><p><strong>假设</strong></p><ul><li>Keystone设计框架相信PMP规范，认为PMP和RISC-V硬件都是无bug的</li><li>只有当验证完SM的测量值是正确的（被可信硬件签名且是正确的版本号），Keystone user才会信任SM</li><li>SM只信任硬件，host信任SM，RT信任SM，eapp信任SM和RT</li><li>SM，RT和eapp都是bug-free的，这可以通过formal verification来完成（eapp不可能是恶意的吗？）（对RT和eapp进行充分的检查，来</li></ul><p><strong>攻击者模型</strong></p><ul><li>physical attacks：拦截、修改、重放芯片发出的信号，假设物理攻击者不会修改芯片包内部的组件</li><li>software attacks：控制host app，untrusted OS，网络通信，配置攻击enclaves，任意篡改未受保护的内存，篡改enclave信息</li><li>side-channel attacks：通过观察可信组件和不可信组件之间的交互收集信息，分三种：cache side-channel，timing side-channel，controlled channel</li><li>denial-of-service attacker：take down enclave或者host OS</li></ul><p>Keystone没有针对speculative execution attacks和timing side-channel attacks的防护（相关的防护措施，需要程序开发人员和硬件制造商来完成），也不考虑off-chip的侧信道攻击，比如说memory bus中的侧信道攻击</p><h2 id="4-Keystone-Security-Monitor"><a href="#4-Keystone-Security-Monitor" class="headerlink" title="4 Keystone Security Monitor"></a>4 Keystone Security Monitor</h2><p>SM使用的是RISC-V平台上的标准功能，所以很容易与RISC-V平台兼容。</p><h3 id="4-1-内存隔离"><a href="#4-1-内存隔离" class="headerlink" title="4.1 内存隔离"></a>4.1 内存隔离</h3><p>PMP是由RISC-V提供的一项功能，它通过PMP条目限制S-mode和M-mode对物理内存区域的访问。</p><p><img src="/2021/01/29/keystone-2020/3.png" alt="image-20200915163351206"></p><p>使用SM来完成memory isolation.</p><ul><li><p>所有的enclave不是共享一块大的内存区域，而是以多个不连续的enclave内存区域形式存在</p></li><li><p>PMP条目可以覆盖4bytes到DRAM的全部内存区域（enclave的地址范围不是固定的）</p></li><li><p>PMP条目分配得到的物理内存区域可以在运行的时候动态调节（可以随时多申请一块内存区域或者释放一块内存区域）</p></li></ul><p>SM首先给自己配置一块PMP entry来覆盖自己的内存区域，然后配置最低的PMP entry覆盖所有的内存并且允许所有mode访问。</p><p>OS创建一个enclave，然后找到一块合适的连续的物理内存通知SM。SM进行验证后，添加一个PMP条目并disable该条目的所有权限。OS和其他的进程都不能访问该PMP条目。</p><p><strong>内核之间的PMP实施</strong></p><p>每个内核都拥有自己的PMP条目的完整列表。对PMP条目的修改会通过inter-processor interrupts（IPIs）扩散到所有的内核中。在enclave执行的过程中，对PMP条目的修改只会在本地完成，不会扩散到其他内核中，IPIs的同步只会在enclave的创建和销毁中执行。（当enclave要进行扩容的时候，是否需要进行同步？如果不进行同步的话，一块内存是否会同时被两个enclave申请）</p><h3 id="4-2-enclave中的页管理-创建后"><a href="#4-2-enclave中的页管理-创建后" class="headerlink" title="4.2 enclave中的页管理(创建后)"></a>4.2 enclave中的页管理(创建后)</h3><p>在初始化过程中使用OS生成的页表，而在执行过程中，将virtual-to-physical的页表映射的任务完全交给enclave来完成。</p><p><img src="/2021/01/29/keystone-2020/4.png" alt="image-20200915213129136"></p><p>enclave中具有S-mode的RT，所以keystone能够操纵特定enclave的页表来管理自己的virtual memory。–》消除了controlled side-channel attacks。</p><h3 id="4-3-中断和异常"><a href="#4-3-中断和异常" class="headerlink" title="4.3 中断和异常"></a>4.3 中断和异常</h3><p>在enclave执行期间，所有的machine interrupts 都由SM直接捕获。异常（page faults）会通过RISC-V的exception delegation register由RT代理，进而将异常报告给untrusted OS。</p><p>为了应对针对某个内核的DoS攻击，SM设置了一个machine timer，一旦timer interrupt触发，SM将会重新获取控制权–》DoS攻击的应对</p><h3 id="4-4-Enclave生命周期"><a href="#4-4-Enclave生命周期" class="headerlink" title="4.4 Enclave生命周期"></a>4.4 Enclave生命周期</h3><ul><li><p>creation：Keystone测量enclave memory来保证OS在物理内存中加载了正确的enclave binaries。（这里的测量值是initial virtual memory，所以，SM需要OS来初始化enclave页表，并且给enclave分配physical memory。SM walk OS提供的页表并检查其中是否有不合法的映射，并且保证一个虚拟地址只能映射到一个物理地址。接着计算page content和virtual address，configuration data的哈希值）</p></li><li><p>execution：SM设置PMP entry，并将控制权移交给enclave entry point</p></li><li><p>destruction：在将控制权还给OS之前清除enclave memory region</p></li></ul><h3 id="4-5-TEE原语"><a href="#4-5-TEE原语" class="headerlink" title="4.5 TEE原语"></a>4.5 TEE原语</h3><p>secure boot. Keystone的root-of-trust可以是一个temper-proof software或者是hardware。在每次CPU的reset阶段，root-of-proof</p><ul><li>测量SM image</li><li>从secure source of randomness生成一个新鲜的认证密钥</li><li>将认证密钥存储到SM memory中</li><li>用hardware-visiable key对测量结果和public key进行签名</li></ul><p>secure boot的实现可以有多种方式，目前通过一个修改的first-stage bootloader模拟一个secure boot。</p><p>secure source of randomness. SM提供了一个安全的SM SBI 调用-random，它能够返回64bit的随机值（没说具体咋实现的，而且应该不是依赖于硬件）</p><p>remote attestation：SM基于provisioned key来实现measurement和attestation。Keystone通过在signed attestation report中加入limited arbitrary data将attestation值与secure channel绑定起来。</p><p>其他的primitives. 1）通过标准rdcycle指令允许enclaves访问read-only hardware-maintained timer register；2）在SM内存中保持一个limited counter state（有限的计数器状态）来提供单调计数器。通过这些特征能够提供可信计数器，rollback defense以及sealed storage等。</p><h3 id="4-6-特定平台的扩展"><a href="#4-6-特定平台的扩展" class="headerlink" title="4.6 特定平台的扩展"></a>4.6 特定平台的扩展</h3><p><strong>secure on-chip memory.</strong> 利用L2  memory controller动态实例化一个最高可以到2MB的scratchpad memory，该内存区域可以用来生成一个usable on-chip memory region。（这边的on-chip memory region是将L2 cache分成一部分，这部分只能由特定的enclave来使用吗）该scratchpad memory可以分配给一个enclave，给enclave在自己的运行期间就可以独占该scratchpad memory。</p><p>如果一个enclave需要运行在on-chip memory，跟标准过程的差别仅在：</p><ul><li>enclave在被加载后，会被分配一个经过修改的page tables，该页表指向final scratchpad address</li><li>SM在进行measurement之前将标准enclave memory region复制到新的scratchpad region中。</li></ul><p>–》保护免受可以进入DRAM的物理攻击者的攻击</p><p><img src="/2021/01/29/keystone-2020/5.png" alt="image-20200916095137404"></p><p>cache分块。实现的方式：</p><ul><li>类似于intel’s CAT（对CAT的理解是，通过增加一个CLOS位，管理缓存将缓存分给特定的应用，在本文中就是分给特定的enclave）的L2 cache controller’s waymasking primitive</li><li>PMP以透明的方式对L2 cahce进行分区，将其分配给OS和enclave</li></ul><p>在上下文切换的时候，enclave对应的cache partition中的值会被flushed。而在运行时，enclave physical memory中的值可以很好地被PMP保护。</p><p>–》抵御cache side-channel attacks</p><p><img src="/2021/01/29/keystone-2020/6.png" alt="image-20200916105840680"></p><p>动态调整大小。（SBI是由SM提供的API，不同的caller通过调用SBI，能够执行不同的功能）</p><p><img src="/2021/01/29/keystone-2020/7.png" alt="image-20200916112211215"></p><p>静态地定义了最大的enclave size，并分配static physical or virtual memory：1）避免因为workload而动态扩展大小；降低复杂性5 </p><p>当需要扩容的时候，RT需要OS发出SBI调用，来给enclave memory region增加连续的物理页。当成功分配后，SM通过扩容对应PMP条目来增加enclave的大小并通知RT。 </p><h2 id="5-Keystone-模块化runtime"><a href="#5-Keystone-模块化runtime" class="headerlink" title="5 Keystone 模块化runtime"></a>5 Keystone 模块化runtime</h2><p>enclave中的RT提供的功能类似于一个kernel，但是它并不需要大多数的kernel功能，作者构造了一个Eyrie的RT，其中仅仅包含了必要的功能从而降低了TCB。（仅允许RT访问shared memory buffer；另外，允许轻松移植成熟的微内核）</p><h3 id="5-1-enclave内存管理模块"><a href="#5-1-enclave内存管理模块" class="headerlink" title="5.1 enclave内存管理模块"></a>5.1 enclave内存管理模块</h3><p>默认情况下，Keystone enclave会占用一块由OS分配的固定的连续物理内存，该内存在加载之时就被静态映射到了一块virtual memory。（Keystone enclaves occupy a fixed contiguous physical memory allocated by the OS with a statically-mapped virtual address space at load time.  ）</p><p><strong>释放内存。</strong> 在enclave保存unmapped physical memory之后，<strong>构造一个模块让Eyrie RT来进行page table的管理</strong>。未被映射的memory region在eapp执行之前将被设置为0。–》page table management</p><p>In-Enclave自分页。为了Eyrie RT构造了一个in-enclave page wapping模块。该模块负责处理page-faults，并使用一个通用page backing-store来管理evicted page的存储和恢复。（页表驱逐策略是一个简单的random eapp-only page eviction policy）自分页和释放内存两个一起负责管理Eyrie RT中的virtual memory management。</p><p>保护离开enclave的页表内容。当某个enclave处理自己的page fault，那么就需要将secure physical memory中的部分页面驱逐出去。当这些页面被copied out时，它们的内容也需要被保护。完成了一个backing-store layer来完成page encryption和integrity protection来允许页表中的内容被驱逐到insecure storage中。这部分可以考虑由RT或者指定的trusted hardware unit——内存加密引擎来完成。</p><p>free-》page table管理，self-page-》wapping管理  前两者共同管理virtual memory</p><h3 id="5-2-功能性模块"><a href="#5-2-功能性模块" class="headerlink" title="5.2 功能性模块"></a>5.2 功能性模块</h3><p>Edge Call Interface. eapp不能访问Keystone中的非enclave memory。所以如果需要读取enclave以外的数据，Eyrie RT需要代表eapp执行edge calls。Eyrie将该调用安全传送到untrusted host，并将返回值传送给enclave，最后传给eapp。具体的实现方案是：</p><p>1）OS将host memory space中的一块shared buffer给SM；2）SM将地址传递给enclave使得RT能够访问该内存区域；3）SM使用一块单独的PMP条目来使得OS能够访问shared buffer。</p><p>通过该interface，Keystone可以利用现有的攻击措施来抵御Iago attacks。</p><p><strong>多线程。</strong> 通过将线程管理授权给runtime来实现multi-threaded eapps。（多个RT能够同时运行自己的eapps）</p><p>并不支持parallel multi-core enclave execution（多个处理器同时执行多个任务，每个任务分配在一个处理器上执行） （但是这可以通过SM在不同的内核中多次调用enclave execution，这个的意思是不是SM一次在core0上调用enclave execution，接下来再去在core1上调用enclave execution）</p><h2 id="6-安全分析"><a href="#6-安全分析" class="headerlink" title="6 安全分析"></a>6 安全分析</h2><h3 id="6-1-对enclave的保护"><a href="#6-1-对enclave的保护" class="headerlink" title="6.1 对enclave的保护"></a>6.1 对enclave的保护</h3><p>软件攻击者无法访问enclave memory</p><p>controlled side-channel无法实施：因为enclave拥有对应的page management和in-enclave page tables。</p><p>mapping attacks. 受信任的RT在enclave creation阶段来对page tables进行初始化或者加载由SM验证过的static mapping的页表。在动态内存调整时，RT会在映射到enclave中首先检查它们是否安全并在将内存还给OS之前，清空其中的内容。</p><p>syscall tampering attacks。（伪造系统调用攻击）–》利用现有的防御机制来作为RT模块的插件来抵御这种攻击</p><p>侧信道攻击：由于enclave不会和host OS或者其他的用户应用程序分享状态，因此不会受到controlled channel attacks的攻击。干净的上下文切换</p><h3 id="6-2-保护host-OS"><a href="#6-2-保护host-OS" class="headerlink" title="6.2 保护host OS"></a>6.2 保护host OS</h3><p>内存隔离</p><p>第一步，OS能够访问OS memory来进行boot操作</p><p>这边的图 是说enclave在执行的时候，所有的部分都能够读取enclave memory（all_perm)吗？但是如果两个enclave同时运行时，不应该只能一个keystone访问属于自己的内存区域，而不能访问其他的内存区域</p><h2 id="7-PMP"><a href="#7-PMP" class="headerlink" title="7 PMP"></a>7 PMP</h2><p>几个概念</p><ul><li>WPRI：Reserved Writes Preserve Values, Reads Ignore Values</li><li>WLRL: Write/Read Only Legal Values</li><li>WARL: Write Any Values, Reads Legal Values </li></ul><p>关于RISC-V的知识点</p><p>Sv32分页虚拟内存模式下，RV32可能会拥有34位物理地址空间-》支持34位的物理内存访问管理。</p><p>Sv32的虚拟地址是32位的，每个页的大小为4KB，它的物理地址是34位的。supervisor virtual address被转化为supervisor physical address需要一个two-level page tables，20-bit的VPN被转化为22-bit的physical page number（PPN），在最终转化为machine-level physical address之前，需要一些physical memory protection structures（PMP）。</p><p><img src="/2021/01/29/keystone-2020/11.png" alt="image-20200919150238758"></p><p>PMP checks are also applied to page-table accesses for virtual-address translation, for which the effective privilege mode is S. </p><p>PMP仅支持固定数量的内存区域。</p><p>PMP entries是由一个8-bit configuration register和一个MXLEN-bit address register描述的。最多仅能支持16个PMP entries。仅有M-mode能够访问PMP CSRs。</p><p>控制寄存器是8位（1个字节）的，但是在实际的机器中是不会存在8位的寄存器，所以其实是将一个CSR分成4个pmp entry configuration register.</p><p>下图中展示的是RV32，用4个CSRs，pmpcfg0-pmpcfg3来保存pmp0cfg-pmp15cfg这16个PMP entries.</p><p><img src="/2021/01/29/keystone-2020/8.png" alt="image-20200918171027557"></p><p>而在RV64中，pmpcfg0和pmpcfg2保存了16个PMP entries。将pmp8cfg到pmp15cfg保存在pmpcfg2，是因为在RV32和RV64的情况下，pmp8cfg到pmp11cfg都保存在pmpcfg2中，这样就可以减少对64位支持的开销。</p><p><img src="/2021/01/29/keystone-2020/9.png" alt></p><p>而保存PMP address registers的是pmpaddr0-pmpaddr15这些CSRs。在RV32中，每个PMP address registers编码34bit物理地址中的2-33bit；在RV64中，每个PMP address registers编码56bit物理地址中的2-55bit。（Each PMP address register<br>encodes bits 33–2 of a 34-bit physical address for RV32, as shown in Figure 3.29.  For RV64, each PMP address register encodes bits 55–2 of a 56-bit physical address, as shown in Figure 3.30.   ）（下图我认为3.29应该是到33结束）并不是所有的地址位都被设置了，所以pmpaddr registers也是WARL。</p><p><img src="/2021/01/29/keystone-2020/10.png" alt="image-20200919135409757"></p><p>PMP configuration registers的构造如下图所示。R，W，X设置分别代表可读，可写，可执行。如果设置R=0，W=1，那么该寄存器将会被reserved for future use. </p><p>A：对相关的PMP address register的address-matching mode进行编码</p><p><img src="/2021/01/29/keystone-2020/12.png" alt="image-20200919164058052"></p><p>（Keystone中仅支持TOR和NAPOT）</p><p><img src="/2021/01/29/keystone-2020/13.png" alt="image-20200919165823798"></p><p>NAPOT是利用address registers的low-order bits来定义地址范围</p><p>类型为NAPOT的情况下：</p><p>yyyy…yyy0，连续1的个数为0，则XLEN=0，NAPOT range为2^(0+3)=8</p><p>yyyy…yy01，连续1的个数为1，则XLEN=1，NAPOT range为2^(1+3)=16</p><p>1111…1111，连续1的个数为XLEN，NAPOT range为2^(1+XLEN)</p><p>如果是y…y01…1，连续1的个数为n，则该PMP entry所控制的地址空间为从y…y00…0开始的2^(n+3)个字节</p><p>类型为NA4（Naturally Aligned Four-byte regions）的情况下：</p><p>当pmpaddr值为yyyy…yyyy，那么控制的地址范围就是从yyyy…yyyy开始的4个字节</p><p>类型为TOR的情况下：</p><p>该PMP entry所控制的地址范围由前一个地址寄存器和后一个地址寄存器共同决定，也就是匹配满足以下条件的地址y：</p><p>pmpaddri-1≤y≤pmpaddri</p><p>当第0个PMP entry的A字段为TOR，其所控制的地址空间的下界被认为是0，也就是匹配所有满足 0≤y≤pmpaddr0</p><p><img src="/2021/01/29/keystone-2020/14.png" alt="image-20200919193458254"></p><p>L bit：锁定PMP entry。</p><p>当L bit=1时，对内存区域的访问将会应用在所有的privilege modes。（U, S, M模式都必须遵循配置寄存器的权限设置）</p><p>当L bit=0时，符合PMP entry的M-mode访问都会成功；S和U模式下需要遵循配置寄存器中的权限设置。</p><h3 id="7-1-物理内存保护以及分页"><a href="#7-1-物理内存保护以及分页" class="headerlink" title="7.1 物理内存保护以及分页"></a>7.1 物理内存保护以及分页</h3><p>通过S mode去对页表访问是最有效的。</p><p>当装有页表或者是指向page table的physical memory发生改变时，M-mode的软件必须在virtual memory system中同步PMP设置。这部分是通过SFENCE.VMA指令（rs1=x0, rs2=x0）来完成的。</p><h3 id="7-2-waymasking"><a href="#7-2-waymasking" class="headerlink" title="7.2 waymasking"></a>7.2 waymasking</h3><p>对waymasking的理解是通过waymask寄存器来允许特定的master访问某些way</p><p>waymaskX registers：仅影响分配，仍然可以尝试读取被masked的ways。</p><p>有16个waymaskX寄存器，分别是waymask0-waymask15，waymaskX register表示的是该L2 cache能够被master X驱逐。</p><p>在enclave执行过程中，只有enclave physical memory中的enclave lines会在对应的cache partition中，所以就会被PMP保护。</p><p>（我觉得目前，可能是直接把8个分区，比如0-7直接分给了keystone。如果一个时刻只有一个enclave运行的话，这些分区就不需要再细分。FU540中一共分了8个pmp entry，在waymasking的master这边有8个chiplink domain，可能就是一一对应的关系）</p><p>比如设置WayMask0[2].RW = 0x1，就表示enable way2 for Master0</p><p><img src="/2021/01/29/keystone-2020/15.png" alt="image-20200920163932004"></p><p><img src="/2021/01/29/keystone-2020/C:%5CUsers%5Crww%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200920164733863.png" alt="image-20200920164733863"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Keystone论文的精读笔记~&lt;/p&gt;
    
    </summary>
    
      <category term="Keystone" scheme="http://yoursite.com/categories/Keystone/"/>
    
    
      <category term="paper" scheme="http://yoursite.com/tags/paper/"/>
    
      <category term="RISC-V" scheme="http://yoursite.com/tags/RISC-V/"/>
    
      <category term="Keystone" scheme="http://yoursite.com/tags/Keystone/"/>
    
  </entry>
  
  <entry>
    <title>CITM CCS20</title>
    <link href="http://yoursite.com/2021/01/29/CIMT/"/>
    <id>http://yoursite.com/2021/01/29/CIMT/</id>
    <published>2021-01-28T16:00:00.000Z</published>
    <updated>2021-01-29T14:38:34.718Z</updated>
    
    <content type="html"><![CDATA[<p>Cache-in-the-Middle (CITM) Attacks : Manipulating Sensitive Data in Isolated Execution Environments的精读笔记~</p><p>这篇论文是我在组会讲解的第一篇论文，也很感激第一篇讲的是这篇，因为这篇完全就是中国人写的感觉，推荐阅读原文，非常好读懂</p><a id="more"></a><p>TrustZone的制造商希望通过约束安全世界中的第三方应用程序的安装来最小化可信计算基（TCB）,但是第三方的开发人员更希望能够在安全世界中自由地安装自己的应用。</p><p><strong>解决方法</strong>：在普通世界中构造了一个Isolated Execution Environment（IEEs）来保护安全敏感的应用程序。</p><p><strong>本文所完成的工作：</strong>针对IEE的数据保护模型（data protection models)和ARM cache属性（cache attributes），发现了三种基于cache的漏洞（CITM 漏洞），这些漏洞能够被用来操纵保护在IEE内部的敏感数据。</p><p>另外，由于映射到IEE内存中的缓存的安全措施的低效和不连贯的，普通世界中的攻击者能够通过以下几点措施降低IEE数据的安全性：</p><p>1）并发执行；</p><p>2）在安全敏感的应用程序被suspend或者终止（finished）时绕过强制的安全措施；</p><p>3）在IEE上下文切换进程中国措施使用不完整的安全措施。</p><p><strong>完成的工作：</strong></p><p>1）作者通过在一些著名的IEE systems中，包括SANCTUARY，Ginseng和TrustICE进行案例研究揭示了CITM漏洞的广泛存在；</p><p>2）CITM漏洞是能够在硬件测试床上利用的</p><p>3）分析导致CITM的漏洞的根本原因，并提供了解决对策。</p><p>实验证明我们的防御测试具有一个很小的开销。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>IEEs的主要思想是通过一个安全世界中的trusted reference monitor确保只有授权的IEE app能够访问IEE敏感资源。</p><p><img src="/2021/01/29/CIMT/image-20200824180749550.png" alt="image-20200824180749550"></p><p>Ginseng：在普通世界中构造第三方应用程序，同时避免部署安全世界中的application-specific logic（ Ginseng [55] constructs the IEEs to protect secrets of third-party applications in the normal world without deploying any application-specific logic in the secure world.这段的意思是否是不依赖于安全世界中的特殊逻辑）</p><p>SANCTUARY：将它的IEEs定位在per-core环境中来保护IEE指定的内存（避免这些受保护的内存被其他非安全的内核访问）</p><p>TrustICE：通过IEE monitor动态控制IEE memory的安全属性来保护IEE内存。</p><p><strong>攻击方法</strong></p><ul><li>攻击者在并发执行中通过cross-core缓存操作操纵IEE数据；（侧信道攻击？）（在多核系统上，仅仅core-wise的隔离是无法保证安全的，因为缓存是允许cross-core的访问，因此能够被攻击者利用）–》针对Sancutary</li><li>通过将不安全的缓存映射到用于安全措施的IEE内存中来绕过switch out操作后的安全防护操作；–》针对Ginseng</li><li>针对动态控制内存的安全属性的方法，作者认为在switch out过程中能够窃取敏感IEE数据，而在switch in的过程中可以伪造IEE数据。–》针对TrustICE</li></ul><p>本文指出了为了确保IEE数据的安全性，除了内存以外，保护缓存安全的重要性。</p><p><strong>根本原因</strong></p><ul><li>缓存和内存安全属性的非相关性（这个非相关性如何理解？）</li><li>缓存和内存读写操作的不同步</li></ul><p><strong>本文工作</strong></p><ul><li>为IEE内存安全配置cache attributes</li><li>在进行上下文切换时，清除cache mapping to the IEE 内存（难道其他三个没有进行这步的操作吗？）</li></ul><p><strong>名词解释</strong></p><p>switch out：从IEE到untrusted rich OS的上下文切换，switch out之前是secure的</p><p>switch in：逆过程。switch in之前是non-secure的</p><p>cross-core cache：意味着这个cache是被多个核共享的，比如l2 cache</p><h2 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2 背景知识"></a>2 背景知识</h2><p>L1-cache被进一步分为 I-cache（指令cache）和D-cache（数据cache）</p><p>L1-cache和L2-cache都被配置为N-way Set Associative cache。</p><p>全部的cache空间被分为N equally-sized块，也就是N路，每一路用k cache lines进行索引，每个cache line是一个数据单元。内存被分块成大小为一个cache line的多个数据块。j = i mod k</p><p>inner cacheability domain–&gt;L1 cache</p><p>outer cacheability domain–&gt;L2 cache</p><p>cacheability domain’s attributes:</p><ul><li>non-cacheable：内存上的任何读写操作都不会经过该cacheability domain；</li><li>write-through：在当前的cache上进行的写操作会立刻被传送到下一级别的storage；（L1 cache上的读写会被forwarded 到L2 cache——》主存）</li><li>write-back：当前cache上的改变暂存在缓冲区中，当被驱逐时写入下一级的存储部件中</li><li>write-allocate：当进行写操作时出现cache miss，该写结果将会被分配一个新的cache line，如果write-allocate未被设置，cache-missed write会对next level storage进行修改</li></ul><p>invalidation指令：储存在cache中的数据全部失效；</p><p>cleaning指令：将目标缓存上的内容强制写入下一级存储设备或者主存</p><h2 id="3-Threat-Model"><a href="#3-Threat-Model" class="headerlink" title="3 Threat Model"></a>3 Threat Model</h2><p>normal world中的rich OS是不可信的；</p><p>攻击者具有root权限，目的是破坏IEE中的敏感数据的机密性和完整性；</p><p>TrustZone能够提供normal world和secure world之间的安全隔离，安全世界中运行的app是可信的，并且是不会被rich OS降低安全性的；</p><p>安全敏感的app在IEE中运行，不会故意泄露信息。</p><h2 id="4-CITM漏洞"><a href="#4-CITM漏洞" class="headerlink" title="4 CITM漏洞"></a>4 CITM漏洞</h2><h3 id="4-1-IEE数据保护模型"><a href="#4-1-IEE数据保护模型" class="headerlink" title="4.1 IEE数据保护模型"></a>4.1 IEE数据保护模型</h3><p>本部分介绍IEE中的两种数据保护模型。</p><p>（1）安全敏感app能够和不可信app同时运行在normal world中的两个或多个core中。（在安全敏感app执行时，不可信app是可以运行的）</p><p>当安全敏感app在normal world中的一个核上运行时，不可信进程可以同时运行在不同的核或者以分时的状态（in a time-sharing manner）运行在相同的内核中。该模型的安全措施：–》SANCTUARY&amp;Ginseng</p><ul><li>在并发执行时，敏感app使用core-isolated storage（不允许其他core访问的内存或者说是core上的寄存器）传递隐私数据；</li><li>在敏感app suspend或者执行结束时，它core-isolated storage中的所有的隐私数据会在switch out过程中被清除；</li><li>在安全敏感的app重新运行时，在switch in过程中由IEE monitor负责恢复或者分配新的core-isolated storage</li></ul><p>（2）不可信进程不被允许同时和安全敏感 app运行在normal world中。</p><p>在normal world中的任何时间，所有的core只能同时运行安全敏感的app或者是不可信进程。但是在IEE进行上下文切换的过程中，仍然需要继续安全操作。除了在model中介绍的措施外，还需要配置：</p><ul><li>在switch out进程中，对于normal world来说，IEE内存无法被访问；</li><li>在switch in进程中，允许normal world对IEE内存的访问。</li></ul><h2 id="4-2-CITM-Attack-Types"><a href="#4-2-CITM-Attack-Types" class="headerlink" title="4.2 CITM Attack Types"></a>4.2 CITM Attack Types</h2><p>当不可信rich OS操纵normal world中的cache时，两种数据保护模型的安全性都将被降低。从攻击者的角度，可以从两个方面进行攻击：</p><ul><li>manipulating the core-isolated memory (在并发执行中)</li><li>篡改IEE的上下文切换</li></ul><h3 id="漏洞1：在并发执行时操纵core-isolated内存"><a href="#漏洞1：在并发执行时操纵core-isolated内存" class="headerlink" title="漏洞1：在并发执行时操纵core-isolated内存"></a>漏洞1：在并发执行时操纵core-isolated内存</h3><p>在多核系统上，与安全敏感的app并发执行的恶意OS可以通过操纵normal world中的cache来窃取或者修改core-isolated 内存中的IEE数据。因为安全敏感的APP运行在normal world中，而它相应的cache line被标记为non-secure，所以能够被不可信rich OS操纵。（伪造页表，用一个物理地址指向一个core-isolated memory page，恶意OS能够通过访问相应的虚拟地址操纵它的cache line）</p><p>产生的原因：ARM平台提供了保证memory isolation的硬件特性，但缺少相应的针对cache isolation的特性。（比如，TZC-400的Identity-based Filtering features可以用于隔离内存，但不能保证cache的隔离）</p><h3 id="漏洞2：在IEE的switch-out过程中绕过安全措施"><a href="#漏洞2：在IEE的switch-out过程中绕过安全措施" class="headerlink" title="漏洞2：在IEE的switch out过程中绕过安全措施"></a>漏洞2：在IEE的switch out过程中绕过安全措施</h3><p>switch in过程是IEE monitor在secure world中完成的，所以被cache line被配置为secure，所以是很难绕过安全检查并利用，但是switch out不管是由normal world还是secure world中的IEE执行，都是可以绕过安全操作的。</p><p>memory cleaning是在normal world中被执行的，相应的cache line是non-secure的，所以有可能通过控制non-secure cache限制cache中的内存写操作或者保持内存不变。比如，当内存被设置为write-back，write-allocate时，所有的内存写都会被暂存在缓冲区中直到cache set被驱逐。攻击者通过使用lockdown技术阻止cache eviction，进而直到敏感app被悬挂或者终止时，隐私数据都没有被安全地写入IEE内存。</p><p>当安全措施需要在secure world中执行时，IEE需要在不涉及rich OS的情况下将控制权转移到secure world中的IEE monitor。从normal world到secure world的上下文切换是由rich OS kernel中的Secure Monitor Call（SMC）高特权指令完成的。SMC是无法由进程或者app直接触发的，所以安全敏感app通过故意访问secure memroy来故意触发一个external abort。但是只要是在normal world中被访问，安全内存所被映射的cache lines就是non-secure的。（即使是secure world中的secure memory，一旦被normal world中的non-secure cache 映射了，就会变成non-secure），OS就会操纵相应的cache lines来绕过上下文切换和安全措施（data cleaning）。</p><h3 id="漏洞3：IEE-cache上下文切换时不完整的安全措施"><a href="#漏洞3：IEE-cache上下文切换时不完整的安全措施" class="headerlink" title="漏洞3：IEE cache上下文切换时不完整的安全措施"></a>漏洞3：IEE cache上下文切换时不完整的安全措施</h3><p>某些IEE系统在上下文切换中的内存保护是通过动态控制IEE内存的安全属性来完成的（TrustICE）（在switch in过程是不安全的，在switch out过程是安全的）</p><p>switch out阶段不合适的cache cleaning可能会导致IEE data leakage；有害数据可能在switch in阶段被加载入安全敏感的APP。漏洞3是由于cache上不完整的安全措施，而漏洞2是在上下文切换的时候绕过安全检查。</p><p>Model1–》3种漏洞</p><p>Model2–》2和3</p><p>漏洞1,2–》当内存用于存储IEE数据，能够被利用（为什么？）</p><p>漏洞3–》只有在IEE执行switch out的安全措施使才有此要求</p><h2 id="4-3-Cache-lockdown技术"><a href="#4-3-Cache-lockdown技术" class="headerlink" title="4.3 Cache lockdown技术"></a>4.3 Cache lockdown技术</h2><p>cache lockdown：允许程序加载代码和数据到cache中，并标记它们不被eviction（驱逐）–》提高更快的系统反应速度，减少执行时间</p><p>但是CITM中的漏洞2可以利用该lockdown技术，将cache中针对内存的写操作锁住，从而使memory-cleaning操作无效。</p><p>实现cache lockdown的三个方法：</p><ul><li>一些ARM开发板允许用户通过配置L2 auxiliary cache control register来lock L2 cahce ways。–》ARMv8处理器目前已经不支持该基于硬件的locking control 寄存器；</li><li>攻击者将自己控制的内存区域设置为outer cacheable，其他内存区域全部设置为outer non-cacheable，从而独占L2缓存–》huge overhead</li><li>更细粒度地控制内存页面的缓存属性从而独占L2缓存</li></ul><p>相同编号的blocks构成了一个page cache set，攻击者将想要控制的内存页面标记为outer cacheable，其他标记为non-cacheable。</p><p><img src="/2021/01/29/CIMT/image-20200825222106254.png" alt="image-20200825222106254"></p><p>page1和page6分享相同的page cache set，page1设置为cacheable，而page6被设置为non-cacheable（这边即使是修改了page1，由于page1没有被驱逐，所以page1的修改不会被写入到内存中）</p><p>本文选择了使用第三种方法，针对L2 cache实施了cache lockdown。</p><h2 id="5-case-study-of-CITM-attacks"><a href="#5-case-study-of-CITM-attacks" class="headerlink" title="5 case study of CITM attacks"></a>5 case study of CITM attacks</h2><p>SANCTUARY实际上是在ARM fast models virtualization tools上完成的，本文作者在i.MX6Quad开发板上模拟了SANCTUARY的cache操作，Ginseng在HiKey620开发板，TrustICE在i.MX6Quad SABRE开发板上实现。</p><h3 id="5-1-SANCTUARY：操作L1-cache"><a href="#5-1-SANCTUARY：操作L1-cache" class="headerlink" title="5.1 SANCTUARY：操作L1 cache"></a>5.1 SANCTUARY：操作L1 cache</h3><p>每个IEE运行在拥有core-isolated内存的core中，并且每次运行时IEE不会被其他core干扰。</p><h4 id="5-1-1-SANCTUARY的数据保护机制。"><a href="#5-1-1-SANCTUARY的数据保护机制。" class="headerlink" title="5.1.1 SANCTUARY的数据保护机制。"></a>5.1.1 SANCTUARY的数据保护机制。</h4><p>switch out：当IEE结束运行，隐私数据将会被IEE中的微内核清除（向受保护的core-isolated memory中写入全0，并使L1 cache无效）（L2cache在SANCTUARY中被禁止给core-isolated的内存使用）</p><p>switch in：在启动IEE之前，secure world中的IEE monitor将会为IEE建造一个干净的环境。在敏感app加载之前，L1 cache也会被invalided。</p><p>由于在switch in和switch out过程中，core-isolated memory和L1 cache都被安全地清空，所以对于漏洞3是免疫的。由于data cleaning操作是被IEE中的微内核完成的，所以对于漏洞2也是免疫的。如果想要绕过data cleaning，那么就必须锁住L1 cache，但是L1 cache的eviction是由该内核以及core-isolated内存页表的cache属性决定的，攻击者无法通过操纵另一个内核来控制eviction。（core-isolated内存的cache属性是由IEE中的微内核来控制和保护的）</p><p>SANCTUARY给每个内核分配一个独特的Non-Secure Access IDentifier(NSAID)，并且通过配置TZC-400给每个CPU（根据NSAID）分配独立的内存区域。ARM平台上的NSAID都是相同的，所以这部分是在ARM的快速模型虚拟化工具上来完成的。</p><p>受保护的内存区域通过配置cache属性为outer non-cacheable来避免缓存到L2 cache中，而L1 cache一般位于每个内核的内部，不会直接被其他内核访问，但除此之外，SANCTUARY就没有在并发执行时给予其他的保护。</p><h4 id="5-1-2-SANCTUARY中的漏洞"><a href="#5-1-2-SANCTUARY中的漏洞" class="headerlink" title="5.1.2 SANCTUARY中的漏洞"></a>5.1.2 SANCTUARY中的漏洞</h4><p>通过调研，作者发现了名为shareability的缓存特性，该特性能够通过操作一个内核的L1 data cache进而读/写另一个内核的L1 data cache。–》缓存的一致性</p><p>inner shareability domain：在一个cluster中的core的数据一致性（一个cluster表示one group of cores）</p><p>outer shareability domain：所有的cluster的core的数据一致性</p><p>当处理器运行在Symmetric Multi-Processing(对称多核处理器，SMP)模式时，shareability属性将会被配置。（SMP模式在多核平台中是默认设置的）当shareability属性被设置，Snoop Control Unit（窥探控制单元，SCU）会通过处理直接的核之间cache-to-cache转移来保证数据一致性。如果设置为inner shareable，在某个内核中的L1 data缓存中的某个值的修改会同步到该簇上其他内核的L1数据缓存。但是non-secure cache中的数据不会扩散到secure cache。</p><p>结论：当内核都运行在normal world中，访问相同的物理内存地址，并且该物理内存的内存页表的缓存属性都是inner shareable或者outer shareable时，某个内核上的L1数据缓存可能会被另一个内核上的L1数据缓存读取或者篡改。（当设置为non-shareable时，就不会被窃取或者篡改）</p><p>（IEE能否去将SANCTUARY所在内核的内存页表的缓存属性设置为non-shareable）</p><h4 id="5-1-3-攻击过程"><a href="#5-1-3-攻击过程" class="headerlink" title="5.1.3 攻击过程"></a>5.1.3 攻击过程</h4><p>首先，为core1构造一个page table entry，将它的物理页表的缓存属性设置为shareable，并将它的物理地址指向core0的内存页。接下来，进入core1中对应的虚拟地址，core0中的L1数据缓存中的隐私数据就能够通过shareability属性被窃取或者修改。</p><p>（这边有个问题是：一个内存能否被两个内核共同访问吗？making its physical address point to a memory page of core_0）</p><p><img src="/2021/01/29/CIMT/image-20200826093249629.png" alt="image-20200826093249629"></p><p>对IEE内存范围的获取是通过排除法，排除已知的不可信内存，而TEE内存是secure的，IEE内存是non-secure的，对TEE内存的访问会返回0或者触发中断，在读取IEE内存时当内存数据在cache中缓存时，是会得到真实的数据值的，虽然cache要比内存小很多，但经过多次探测，也能确定IEE内存的地址范围。</p><h3 id="5-2-Ginseng：映射到不安全的缓存"><a href="#5-2-Ginseng：映射到不安全的缓存" class="headerlink" title="5.2 Ginseng：映射到不安全的缓存"></a>5.2 Ginseng：映射到不安全的缓存</h3><p>Ginseng是在多核平台上保护选定功能的敏感数据的IEE系统。为了避免被同时运行的有害OS攻击，Ginseng选择将敏感数据仅存放在寄存器中，而不是core-isolated内存，所以这就对漏洞1免疫。另外，由于寄存器中的数据不经过缓存，所以也不受漏洞3的影响。</p><p>Ginseng在switch out过程中依赖于secure world中的TEE monitor来执行data cleaning操作。（因为IEE中的rich OS是不可信的，所以需要借助于TEE）通过试图访问TEE中的安全内存来触发一个安全中断，从而由IEE进入TEE。但是secure memory所映射的缓存是non-secure的，通过操纵该缓存，可以阻止从IEE到TEE monitor的控制流切换，从而绕过data cleaning操作。</p><h4 id="5-2-1-数据保护措施"><a href="#5-2-1-数据保护措施" class="headerlink" title="5.2.1 数据保护措施"></a>5.2.1 数据保护措施</h4><p>Ginseng提供了一个编译器，通过静态污点分析识别携带隐私数据的变量，并将它们保存在寄存器中。包含隐私数据的函数将会被判定为隐私函数，在退出前要进行代码完整性检查。</p><p>Ginseng引入了六种安全的API函数，用于将控制流从normal world中的用户空间直接转移到GService（Ginseng中的IEE monitor）</p><ul><li>ss_write(),ss_read()：用于和GService安全通信</li><li>其余四种被编译器自动插入到程序中，</li><li>ss_saveCleanv()：被插入在敏感函数中的每次函数调用之前，用于加密隐私数据，将加密后的数据保存在内存中，并清除相应的寄存器</li><li>ss_readV()：被插入在敏感函数的每次函数调用之后，解密隐私数据，并恢复这些数据在寄存器中</li><li>ss_start()：被插入在每个敏感函数的开始，用于进行诸如代码完整性检查等准备工具</li><li>ss_end()：插入在敏感函数的末尾，清楚寄存器中的数据防止数据泄露。</li></ul><p><img src="/2021/01/29/CIMT/image-20200826140050212.png" alt="image-20200826140050212"></p><p>当需要GService进行安全敏感操作时，需要从normal world中的用户空间上下文切换到运行在secure world中的GService。cross-world的上下文切换是通过SMC指令来完成的。通过配置TZASC，每个API函数被分配了一个独特的安全内存，调用一个安全的API函数将会触发一个security violation，因为它试图在普通世界读取安全内存。</p><p>在处理该violation时，处理器会在normal world中发出一个external abort（EA）, GService在Secure Configuration Register中设置了external abort比特位，所以GService无需kernel的参与就可以直接处理EA和secure API发出的请求。</p><h4 id="5-2-2-Ginseng中的type-II-攻击"><a href="#5-2-2-Ginseng中的type-II-攻击" class="headerlink" title="5.2.2 Ginseng中的type II 攻击"></a>5.2.2 Ginseng中的type II 攻击</h4><p>ss_saveCleanv首先加载__channel_save_clean的地址（指向ss_saveCleanv函数的安全内存的虚拟地址）到寄存器4中，然后将该地址为x4的安全内存中的数据加载到寄存器x0中。</p><p><img src="/2021/01/29/CIMT/image-20200826161849045.png" alt="image-20200826161849045"></p><p><img src="/2021/01/29/CIMT/image-20200826160551699.png" alt="image-20200826160551699"></p><ol><li>当执行“安全内存加载”指令（第18行），处理器首先会尝试去缓存中加载数据；</li><li>由于缓存中不会存放敏感数据，所以应是cache miss；cache根据提供的地址去secure memory中获取数据；</li><li>由于是从normal world中尝试去访问secure world中的数据，所以会触发一个external abort，该EA被GService捕获；</li><li>GService根据该安全API的要求，加密敏感数据并清除相应的寄存器；</li><li>控制流回到secure API ss_saveCleanV()；</li><li>调用非敏感函数insensitive_func()</li></ol><p>其中，1中的cache是non-secure cache，这儿可以被攻击者利用。</p><p>在HiKey620开发板（8-core ARM Cortex-A53 processor）上实现了原型系统</p><p>攻击过程就是红线描述的过程，最重要的是其中的步骤0</p><p>步骤0在缓存中填充了映射secure memory的缓存行，这样在步骤1的时候就会cache hit，那么步骤2-5都不会执行，就直接执行了步骤6中的insensitive function。而insensitive_func()可能会被攻击者利用读取未被清零的敏感寄存器，insensitive function和sensitive function都运行在相同的内核中，但缺少了安全检查。所以，我们可以通过修改libc.so库利用printf()函数来读取寄存器中的隐私数据，比如说keys。</p><p>接下来详细阐述cache0的攻击过程：writeSM是用于向cache中写入__channel_save_clean（ss_saveCleanV()的安全内存）的函数。</p><ol><li>__channel_save_clean的虚拟地址被加载到寄存器x4中；</li><li>由于__channel_save_clean的虚拟地址-物理地址映射被保存在rich OS内核中，攻击者可以很容易地获得它的物理地址；</li><li>将寄存器x0中的数据保存到地址值为x4的安全内存。该数据会被首先写入到安全内存__channel_save_clean的缓存中，因为Ginseng中的安全内存被设置为write-back和write-allocate，所以数据会被暂时存放在缓存中，直到缓存满了之后才被驱逐。</li><li>作者利用lockdown技术将映射到同一个page cache set的内存页表设置为outer non-cacheable（阻止缓存到l2缓存中）。</li></ol><p>通过在ss_saveCleanV()之前调用writeSM函数，本文作者成功实现了绕过GService中的安全保护。</p><p><img src="/2021/01/29/CIMT/image-20200826170916865.png" alt="image-20200826170916865"></p><h3 id="5-3-TrustICE：不完整的cache-cleaning"><a href="#5-3-TrustICE：不完整的cache-cleaning" class="headerlink" title="5.3 TrustICE：不完整的cache cleaning"></a>5.3 TrustICE：不完整的cache cleaning</h3><p>TrustICE是在一个单核平台上实现的IEE系统，安全敏感app运行在包含一个用户程序和一个微内核的IEE中，该app不会受到rich OS的干扰。</p><h4 id="5-3-1-数据保护措施"><a href="#5-3-1-数据保护措施" class="headerlink" title="5.3.1 数据保护措施"></a>5.3.1 数据保护措施</h4><p>TrustICE静态地将物理内存分成了三个分离的区域给normal world中的rich OS，normal world中的IEE和secure world中的Trusted Domain Controller（TrustICE中的IEE monitor）。隐私数据保护是通过动态配置IEE内存的安全属性完成的。</p><ul><li><p>当系统boot up时，可信区域控制器设置IEE内存为安全的。</p></li><li><p>在新建一个IEE之前（switch in），可信区域控制器从IEE内存中给该IEE分配一块内存空间，并将其属性设置为non-secure。</p></li><li><p>当IEE结束运行时（switch out），IEE中的微内核通过调用SMC指令将当前控制流直接转移到secure world。在将控制权转交给rich OS之前，可信区域控制器将配置相应的IEE内存空间为secure。</p></li></ul><h4 id="5-3-2-TrustICE中的type-III-攻击"><a href="#5-3-2-TrustICE中的type-III-攻击" class="headerlink" title="5.3.2 TrustICE中的type III 攻击"></a>5.3.2 TrustICE中的type III 攻击</h4><p>TrustICE遵从了model2，所以对漏洞1来说是免疫的。</p><p>当malicious OS运行时，IEE内存被设置为secure；当security-sensitive app退出时IEE被设置为non-secure。在switch out过程中，通过动态配置IEE内存为secure，保证数据的安全性。该保护是无法绕过的，因为这是通过在secure world中调用SMC指令强制将控制流从IEE中的微内核转移到secure world。所以不受漏洞2的干扰。</p><p>虽然在上下文切换的过程中，内存得到了严格的保护，但相应的缓存还是non-secure的，并且没有被完全清理干净，因此，可以利用漏洞3。</p><h4 id="5-3-3-攻击过程"><a href="#5-3-3-攻击过程" class="headerlink" title="5.3.3 攻击过程"></a>5.3.3 攻击过程</h4><p>在normal world中构造一个页表条目，该页表条目的的物理地址指向IEE内存页，并且该内存页的cache属性被设置为write-back和write-allocate。</p><p>switch out：由于TrustICE并不会去清除缓存行中的数据，所以能够访问残留在对应缓存行的残留数据</p><p><img src="/2021/01/29/CIMT/image-20200826210642807.png" alt="image-20200826210642807"></p><p>switch in：rich OS根据IEE内存页向缓存中写入malicious data，并使用lockdown技术锁住这些缓存行。当IEE执行时，它首先读到的是被污染后的缓存行，而不是IEE内存页中的合法数据。</p><p><img src="/2021/01/29/CIMT/image-20200826210712579.png" alt="image-20200826210712579"></p><h2 id="6-应对措施"><a href="#6-应对措施" class="headerlink" title="6 应对措施"></a>6 应对措施</h2><p>本文作者通过配置IEE内存中的缓存属性以及在进行上下文切换时清除IEE内存来消除CITM漏洞。</p><h3 id="6-1-抵御措施"><a href="#6-1-抵御措施" class="headerlink" title="6.1 抵御措施"></a>6.1 抵御措施</h3><p>产生CITM漏洞的主要原因在于缓存和主存这两级内存架构之间的不连贯性。</p><p>漏洞1的原因：内存隔离并不能自动确保缓存隔离。比如在SANCTUARY中，当一个特定内核的内存区域通过TZC-400的identity-based filtering features获得了一块独立的内存区域，相应的L1缓存仍然能够在内核之间共享。</p><p>解决方法：将该core-isolated内存的cache属性设置为outer non-cacheable，non-shareable。</p><p>漏洞2产生的主要原因：内存和缓存中的读写操作是不同步的。Ginseng中的cross-world的切换就通过限制安全缓存中的读写绕过了。预加载并提前将恶意数据锁定在对应于secure memory的缓存中，IEE在读取安全内存时也会先hit预加载的恶意花奴才能。</p><p>解决方法：使内存和缓存中的读写同步。可以将IEE内存中cache属性设置为write-through,non-write-allocate.</p><p>漏洞3：缓存行是被自动设置的，当被一个运行在normal world中的内核访问时，该缓存行就被定义为non-secure；反之，如果被一个运行在secure world中的内核访问时，该缓存行就被定义为secure。所以，在TrustICE上完成的CITM攻击是通过在switch out之后读取IEE内存的non-secure缓存，并且在switch in之前在non-secure缓存中写入并锁定恶意数据。</p><p>解决办法：在switch in和switch out过程中清除缓存行，那么攻击者就不会读取缓存中残留的数据或者是在缓存中留下恶意数据。</p><p>综上所述，CITM漏洞可以通过以下几点来进行消除：</p><ul><li>配置IEE内存的页表属性为inner write-through non write-allocate,outer non-cacheable, non-shareable</li><li>在进行上下文切换时清除IEE内存对应的缓存。缓存清除可以通过调用IEE中的invalidation和cleaning指令来完成。在switch in中调用invalidation来保证cache的干净，在switch out中调用cleaning来同步cache和内存的数据，接着调用invalidation来清除cache数据。</li></ul><h3 id="6-2-defense-overhead"><a href="#6-2-defense-overhead" class="headerlink" title="6.2 defense overhead"></a>6.2 defense overhead</h3><p>设备：i.MX6Quad SABRE开发板（quad-core ARM Cortex-A9处理器 at 1.2GHz with 1GB DDR3 SDRAM)</p><p>强制缓存属性的情况，在一个IEE中运行一个AES加密app</p><p>第一列是大部分的IEE，第三列是本文中介绍的defense系统，由于关闭了L2，所以导致开销达到了90%，但是和同样关闭了L2的SANCTUARY相比，开销是忽略不计的。而第三列是开启了L2的defense系统，与第一列的开销类似。</p><p><img src="/2021/01/29/CIMT/image-20200826225035890.png" alt="image-20200826225035890"></p><p>评估在rich OS中引入额外的cross-domain上下文切换，该上下文切换针对针对页表更新操作。相比较没有进行保护时，仅有2.65%的额外开销。</p><p>数据库的I/O操作需要17.74%是由于从硬盘到内存的数据拷贝需要修改一堆页表映射。</p><p><img src="/2021/01/29/CIMT/image-20200826225341791.png" alt="image-20200826225341791"></p><p>在涉及到频繁的页表更新操作时的开销，所有的开销都小于10%</p><p><img src="/2021/01/29/CIMT/image-20200826230608632.png" alt="image-20200826230608632"></p><h2 id="7-讨论"><a href="#7-讨论" class="headerlink" title="7 讨论"></a>7 讨论</h2><p>intel SGX：对于SGX来说，CITM攻击是无效的。因为SGX中的敏感信息都放在EPC（enclave page cache）上。EPC的页表和对应的缓存只能由运行着enclave的处理器来访问（避免恶意OS对缓存行的操纵）。并且，每个EPC页只会被分配给一个enclave。（避免另一个恶意enclave对EPC页缓存行的访问）–》该解决方法搭载在intel架构上，而移动设备往往是使用的arm处理器</p><p>基于虚拟化的解决办法：ARMv7中引入了hyp CPU模式，该模式运行在一个高特权的hypervisor中，一般认为该hypervisor是安全且可信的。在利用该hypervisor的解决办法中，IEE内存通过两个阶段的地址转换机制来进行管理。第一步，是由OS内核来完成的，将虚拟地址转化成一个intermediate physical address（过渡物理地址，IPA）。在第二阶段，由hypervisor将IPA进一步转化成一个真正的物理地址。为了抵御恶意OS，hypervisor通常会根据IPA到PA的映射来进一步确认分配给IEE和rich OS的隔离物理地址空间。–》依赖于一个可靠的hypervisor，本文的TrustZone-based IEE系统基于一个secure world中的small-sized的IEE来保护安全敏感程序免受normal world中的不可信os和hypervisor的攻击。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cache-in-the-Middle (CITM) Attacks : Manipulating Sensitive Data in Isolated Execution Environments的精读笔记~&lt;/p&gt;
&lt;p&gt;这篇论文是我在组会讲解的第一篇论文，也很感激第一篇讲的是这篇，因为这篇完全就是中国人写的感觉，推荐阅读原文，非常好读懂&lt;/p&gt;
    
    </summary>
    
      <category term="TrustZone" scheme="http://yoursite.com/categories/TrustZone/"/>
    
    
      <category term="TrustZone" scheme="http://yoursite.com/tags/TrustZone/"/>
    
      <category term="paper" scheme="http://yoursite.com/tags/paper/"/>
    
      <category term="System Security" scheme="http://yoursite.com/tags/System-Security/"/>
    
  </entry>
  
  <entry>
    <title>SoK S&amp;P20</title>
    <link href="http://yoursite.com/2021/01/29/SoK-TrustZone/"/>
    <id>http://yoursite.com/2021/01/29/SoK-TrustZone/</id>
    <published>2021-01-28T16:00:00.000Z</published>
    <updated>2021-01-29T13:31:27.346Z</updated>
    
    <content type="html"><![CDATA[<p>S&amp;P2020中关于TrustZone的SoK精读笔记~</p><a id="more"></a><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li>understand which types of vulnerabilities and limitations affect existing TrustZone-assisted TEE system(威胁现存TrustZone支持下的漏洞和限制类型)</li><li>正确构建的challenges</li><li>现有研究中可以消除这些威胁的贡献</li><li>在研究了Qualcomm, Trustonic, Huawei, Nvidia, Linaro的TrustZone-TEE系统在publicly documented exploits和vulnerabilities和对TEE固件进行的逆向分析，定义了值得关注的关键vulnerabilities。</li></ul><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>对ARM Cortex-A设备中的TrustZone-assisted TEE公开的漏洞进行了系统性的研究（已公开的安全问题报告大多分散而且unverified，无法获得一个全面的理解）</p><ul><li>针对这样的问题，本文作者研究了从2013年到2018年的207个TEE bug，主要是Qualcomm, Trustonic, Huawei, Nvidia, 和Linaro五家主要生产厂家的TEE设备。</li><li>对这些漏洞检查并进行分类</li><li>通过分析和对TEE硬件manual analysis，获得了对产生existing vulnerabilities的不同的insights，并且有potential solutions 来缓解这些漏洞</li></ul><p>作者观察得到的问题：</p><ul><li>TEEs系统大多具有着critical implementation bugs (包括classic input validation errors，such as buffer overflows)</li><li>TrustZone<strong>架构的缺陷</strong>也催生了针对vulnerable TAs的利用。(在现代操作系统中比较常见的比如ASLR或者page guards等memory protection mechanisms在大多数被分析的系统中是缺失的。)TEE系统往往容易暴露a large attack surface，包括能够被TA调用的危险的TEE system calls。</li><li>在架构和微架构层面的TrustZone中的important hardware properties被忽略。（比如说侧信道攻击）</li></ul><p>我们认为，通过采用最新的防御措施，商用TrustZone-assisted TEEs在解决当前的漏洞的情况下会变得更加安全。针对architecture，implementation和hardware issues，提供了对应的解决方法。</p><p><strong>本文的贡献</strong></p><ul><li>对已有的漏洞进行系统的研究</li><li>architectural flaws</li><li>implementation bugs</li><li>hardware elements</li><li>分析main defenses</li><li>将TrustZone与可替代的TEE enabling technologies分析比较</li></ul><h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h2><p>trusted OS的核心是trusted kernel，为调度和管理TAs提供了基本的OS primitives。</p><p><img src="/2021/01/29/SoK-TrustZone/image-20201028105600728.png" alt="image-20201028105600728"></p><p>trusted OS完成</p><ul><li>device drivers for accessing trusted peripherals</li><li>handle cross-world requests through the world switching SMC instruction and shared memory</li><li>implement shared libraries and TEE primitives(remote attestation, trusted I/O, secure storage)</li></ul><p>TEE所包含的组件：</p><ul><li>secure monitor：完成mechanisms for secure context switching between worlds and runs with highest privilege, in protection ring EL3</li><li>TEE bootloader: bootstraps the TEE system into a secure state</li></ul><p>trusted OS, secure monitor, TEE bootloader共同组成了software TCB of a typical TEE system</p><h3 id="攻击TEE-enabled设备"><a href="#攻击TEE-enabled设备" class="headerlink" title="攻击TEE-enabled设备"></a>攻击TEE-enabled设备</h3><ul><li><p>compromise the TEE kernel.</p></li><li><p>compromise the REE kernel.</p><ul><li>一个vulnerable TA可能成为对linux kernel提权的一个跳板。</li></ul></li><li><p>the extent of the problem.</p></li></ul><h2 id="3-Overview"><a href="#3-Overview" class="headerlink" title="3 Overview"></a>3 Overview</h2><h3 id="3-1-研究方法"><a href="#3-1-研究方法" class="headerlink" title="3.1 研究方法"></a>3.1 研究方法</h3><p>在分析商用TEE系统时，遇到了很多问题。</p><ul><li>这些系统都是不开源的</li><li>因为缺少文档，并且采用了代码混淆技术，二进制文件也很难分析</li><li>相同厂家提供的legacy TEE software和TrustZone硬件的多样性和异构性共同存在带来新的复杂性</li></ul><p><strong>攻击模型</strong></p><p>攻击者的目标：</p><ul><li>obtain secrets from the TEE</li><li>obtain secrets from the REE</li><li>escalate privileges to the REE kernel</li><li>escalate privileges to the TEE</li></ul><p>通过以下两种方法从NW访问SMC interface：</p><ul><li>在N-EL1直接获取code execution privileges（允许伪造arbitrary SMC calls）</li><li>在N-EL0间接通过向一些目标TA发出命令。</li></ul><p><strong>分析的TEE系统</strong>：Qualcomm, Trustonic, Huawei, Nvidia(for Nvidia chips), Linaro(OP-TEE)</p><p><strong>数据来源</strong></p><ul><li><p>CVE：搜索相关的关键词，比如TrustZone</p></li><li><p>SVE（Samsung Vulnerabilities and Exposures）</p></li><li><p>SP （S&amp;P）</p></li><li><p>MR（miscellaneous reports available online）网络上可获得的多种报告</p></li><li><p>SC（source code）根据OP-TEE的changelog来分析对安全性问题的修订过程</p></li></ul><p><img src="/2021/01/29/SoK-TrustZone/image-20201028164343172.png" alt="image-20201028164343172"></p><p><strong>公开漏洞的分类</strong></p><p>critical（CVSS&gt;9) a compromise of configentiality or integrity in the TEE(对机密性和完整性的损害)</p><p>severe(CVSS[7,9])</p><p>medium(CVSS[5,7])</p><p>low(CVSS[0,5])</p><p><strong>binary analysis</strong></p><ul><li><p>量化每个系统TCB的大小</p></li><li><p>定义特定系统的软件架构（huawei：ARM Trusted Fireware)</p></li><li><p>分析每个TEE实施的memory protection features</p></li></ul><p><strong>threats to validity</strong></p><p>信息不完整的漏洞可能会对分类造成不精确的影响。</p><p>对于那些公开漏洞比较多的系统，需要给出general conclusions。</p><p>仅对公开的漏洞进行分析。</p><h3 id="3-2-观察结果概述"><a href="#3-2-观察结果概述" class="headerlink" title="3.2 观察结果概述"></a>3.2 观察结果概述</h3><p>124个漏洞中的53个被定义为critical，每一个TEE都有被发现non-low severity vulnerability。</p><p><img src="/2021/01/29/SoK-TrustZone/image-20201029090631064.png" alt="image-20201029090631064"></p><p>其中，高通被公开的漏洞最多，并不代表高通就是最不安全的，只是研究高通的TEE的研究者很多（类比intel和AMD，虽然intel被爆的漏洞更多，但不代表Intel没有AMD安全，只是研究Intel的安全人员更多）</p><p>还有一个点在于和Linux等系统被公开的漏洞比较，可以看到Linux系统中的critical和severe等级的漏洞占比明显小于TEE，这也可以侧面说明当前TEE开发所采用的方法远远不如其他系统健壮（robust），得到的启发是可以参考这些系统的开发方法。</p><h3 id="3-3-TrustZone-assisted-TEE漏洞的来源"><a href="#3-3-TrustZone-assisted-TEE漏洞的来源" class="headerlink" title="3.3 TrustZone-assisted TEE漏洞的来源"></a>3.3 TrustZone-assisted TEE漏洞的来源</h3><p>architecture：TEE system architecture中存在的缺陷，比如没有使用ASLR的内存保护</p><p>implementation：TEE system’s software中的实现问题，比如buffer overflows</p><p>hardware：考虑的是可能降低TEE安全性的hardware behavior，比如side-channels</p><p>即使有更少的critical and servere漏洞，但Trustonic面临着严重的architectural局限性，漏洞报告揭露了很多critical implementation bugs，很多都和Table I中漏洞本质相同。</p><p>另外，作者还叙述了其他可能未来被利用的bugs，比如 concurrency bugs</p><h2 id="4-Architectural-Issues"><a href="#4-Architectural-Issues" class="headerlink" title="4 Architectural Issues"></a>4 Architectural Issues</h2><h3 id="4-1-Attack-Surface"><a href="#4-1-Attack-Surface" class="headerlink" title="4.1 Attack Surface"></a>4.1 Attack Surface</h3><p><strong>TEE系统运行在TEE kernel space</strong>（driver）</p><p>SW中的drivers：协调对安全敏感设备的访问（用于用户身份验证的指纹传感器，用于安全DRM保护内容安全输出的显示缓存）驱动中往往容易存在很多复杂的bugs，所以不应该运行在TEE kernel space（S-EL1 mode），Trustonic和Nvidia都采用了一个运行在S-EL0中的microkernel架构；而Qualcomm，HUAWEI，Linaro都在S-EL1 mode中。其中，Qualcomm和Linaro采用了单一的结构，所有的priviledged code都运行在kernel space，Huawei将部分trusted OS功能移交给user space。</p><p><strong>wide interfaces between TEE system subcomponents.</strong>（interface）</p><p>参考图1，至少4种守护进程对TrustZone驱动有权限访问（N-EL0-》N-EL1）</p><p>SMC call interface赋予了NW软件访问相当可观数量的TAs——暴露了TEE kernel（N-EL1-》S-EL1）</p><p>TEE kernel给TA提供了很多系统调用（对TEE系统调用的访问权限是粗粒度的）比如，Qualcomm TEE中，TAs具有对所有的system calls非常大的访问权限。（S-EL0-》S-EL1）</p><p><strong>Excessively large TEE TCB.</strong>（TCB）</p><p>TEE系统设计的一个基本原则是需要依赖于一个很小的TCB。</p><p>作者认为，通过进行分析，当前的商用TEE没有遵守这条准则。下表中的TAs是相对保守的，因为一些TAs可能会被动态加载。由于TA通过SMC从NW接受输入，一些潜在的漏洞可能被利用。另外，对比microkernel（seL4)来说，TAs是很大的。</p><p><img src="/2021/01/29/SoK-TrustZone/image-20201029200129363.png" alt="image-20201029200129363"></p><h3 id="4-2-普通世界和安全世界之间的隔离"><a href="#4-2-普通世界和安全世界之间的隔离" class="headerlink" title="4.2 普通世界和安全世界之间的隔离"></a>4.2 普通世界和安全世界之间的隔离</h3><p><strong>TA can map physical memory in the NW.</strong></p><p>高效的内存共享会让不同世界之间的数据传输有很小的延迟。一些TEE系统提供的机制可能会很容易被滥用从而导致privilege escalation。</p><p>比如，Qualcomm TEE中的一个trusted OS system call会允许任何TA映射到属于NW的物理内存中。攻击者可能会通过扫描Linux kernel的physical address space来占领一个Android OS，并且patch it从而引入后门（E6）（emmm这个system call也太离谱了，这个call是想直接打破NW和SW的壁垒吗？）</p><p>Trustonic中规定了TA不能任意地读写physical memory（map in or modify），这是通过特定的TrustZone driver来限制的。因此，如果TAs希望在shared memory中交换data volumes，必须向特定的driver TA发出请求。</p><p>samsung中的TIMA（TrustZone-based Integrity Measurement Architecture）机制：a TA driver提供了physical memory的映射，而另一个TA使用该服务来测量system image的完整性。白名单中限制了TA driver可以被TA读写的数目，但这个数目被硬编码成了34，还是很大的。一旦损害了这些TA，攻击者也能很轻易地hijack Android。</p><p><strong>Information leaks to NW through debugging channels.</strong></p><p>TEE debug机制导致从SW到NW的信息泄露。《ATTACKING YOUR TRUSTED CORE: EXPLOITING TRUSTZONE ON ANDROID》中描述的privilege escalation attack利用了一种系统调用，该调用允许TA application将自己的stack trace（堆栈跟踪？）转存到NW的内存区域中。</p><p>应用这种机制，攻击者能够获取GlobalTask的物理内存区域，并利用这些信息实施攻击。</p><h3 id="4-3-内存保护机制"><a href="#4-3-内存保护机制" class="headerlink" title="4.3 内存保护机制"></a>4.3 内存保护机制</h3><p><strong>Absent or weak ASLR implementation.</strong></p><p>TA都被加载到了虚拟地址空间中的固定的地址（0x1000），每个TA都被提供了一个common library，从0x7D01000开始。(我知道他们每个TA初始加载的虚拟地址，有什么作用吗？)-》这样的话，在TA中发现的任何漏洞都能够在不需要决定TA的loading address的情况下进行利用。（问题是，固定的加载地址会带来啥危害吗？我感觉各自的地址空间貌似都是各自的，别的进程应该也看不了吧）</p><p>mcLib中有大量的代码，这也可能会提供a source of gadgets to call functions（类似于rop的原材料？），调用安全OS system calls。</p><p>除了Qualcomm TEE，其他的商用TEE都没有采用ASLR，并且Qualcomm TEE中只有非常小的一部分physical memory（100MB）提供了ASLR。（虽然理论上可以使用64bit的虚拟地址空间，但实际上Qualcomm TEE的地址范围被限制在9bit（512b）攻击者就相对来说比较容易猜出TA的基地址）研究的这些TEE系统并没有使用专门用于TEE kernel的KASLR。</p><p><strong>No stack cookies, guard pages, or execution protection</strong></p><p>Stack cookies: unique values that help detect stack smashing instances and abort the program execution.（一旦溢出了，就停止进程？）</p><p>Guard pages: 对每个进程中的mutable data segments（namely,stack,heap,global data)划定界限，以防止在一个segment中触发overflow来corrupt另外一个段，从而在非法访问时触发故障。（将进程中的数据段划分开来，从而避免某个段中的缓存区移除的影响）</p><p>Execution protection（XP）：阻止程序执行特定的memory regions。比如说使用memory page attributes XN（Execute Never），UXN，PXN（Privileged）</p><p>（这边的主要问题是Trustonic）</p><p>虽然Trustonic提供了secure driver，但是由于缺少stack cookies，导致它非常被利用用来实施缓冲区溢出攻击。它在没有设置guard pages的情况下从TA中的数据段分配globals以及stack。并且，stack在数据段的最后，globals在它之前，这非常容易被利用overflow一个区域到另一个区域。</p><p>huawei啥都没有，作者猜测应该是使用了Micrium µ/OS  用最少的内存保护机制换取一个最优的性能。</p><p><img src="/2021/01/29/SoK-TrustZone/image-20201030113819168.png" alt="image-20201030113819168"></p><h3 id="4-4-Trust-Bootstrapping"><a href="#4-4-Trust-Bootstrapping" class="headerlink" title="4.4 Trust Bootstrapping"></a>4.4 Trust Bootstrapping</h3><p><strong>Lack of software-independent TEE integrity reporting.</strong></p><p>Arm TrustZone中缺少将software integrity measurements的结果安全传送给remote third party的硬件机制。验证机制都是由软件来完成的话，会降低安全性，因为所有的信任链上的软件都必须运行在EL3 mode。</p><p><img src="/2021/01/29/SoK-TrustZone/image-20201030140016456.png" alt="image-20201030140016456"></p><p><strong>III-supported TA revocation.</strong></p><p>TA 的升级能够修正旧版本的漏洞和其他的错误，提高设备的安全性。TA revocation能够有效避免patched TAs被downgraded。</p><p>TA如果被downgraded就会带来很大的安全隐患。</p><h2 id="5-Implementation-Issues"><a href="#5-Implementation-Issues" class="headerlink" title="5 Implementation Issues"></a>5 Implementation Issues</h2><h3 id="5-1-Validation-Bugs"><a href="#5-1-Validation-Bugs" class="headerlink" title="5.1 Validation Bugs"></a>5.1 Validation Bugs</h3><p>validation bugs: 包含对input或者output values不正确的处理。</p><p><strong>Validation bugs within the secure monitor.</strong> </p><p>一旦在secure monitor中发现了bug，攻击者很容易获得整个设备的控制权。</p><p>通过在SMC call中构造一个输入，攻击者能够向SW memory的任何地方写入一个zero double word。为了降低critical bugs发生的概率，大部分的TEE系统采用了ATF。但不幸的是，ATF中也有critical bugs。举个例子， 下面的代码的本意是为了检测(ptr+inc)是否发生了溢出，但如果input base pointer和offset wrap around，就不会检测出溢出情况。在（伪造的）AArch32中，如果在2的32次方到2的64次方-1的情况下，是不会被判断为溢出的。</p><p><img src="/2021/01/29/SoK-TrustZone/image-20201030215959785.png" alt="image-20201030215959785"></p><p><strong>Validation bugs within TAs.</strong></p><p>TEE systems的漏洞报告中占比最大的是与TA相关的validation bugs。</p><p>举个例子：boomerang attacks：vulnerable TA并不会正确验证input memory address，允许攻击者访问NW内存区域并且读写REE apps或者OS的内存。</p><p><strong>Validation bugs within the trusted kernel.</strong></p><p>这边的意思大概是trusted kernel所提供的system call可能会带来风险隐患。（华为的这个例子是说没有任何输入检查，会带来很大的安全隐患）</p><p><strong>Validation bugs within secure boot loader.</strong></p><p>X.509 certificate parser中的stack-based buffer overflow可以让攻击者能够在image verification阶段安装或者加载一个伪造的X.509 certificate。</p><h3 id="5-2-功能性bugs"><a href="#5-2-功能性bugs" class="headerlink" title="5.2 功能性bugs"></a>5.2 功能性bugs</h3><p>functional bugs: 是由于programming errors导致的问题（实现与程序员设计的不一致）</p><p><strong>Bugs in memory protection.</strong></p><p>ATF中的一个bug：memory translation tables的一个配置错误，导致S-EL1中的原本只应该是只读的memory areas一直都是可执行的。</p><p><strong>Bugs in configuration of peripherals.</strong></p><p>有个例子：Qualcomm TEE CVE-2016-10423：TA可以读取前面一个TA在SPI interface中的数据（没有对SPI bus的隔离访问（同时也没有前面一个TA退出时没有清除上下文数据））</p><p><strong>Bugs in security mechanisms.</strong></p><p>安全协议以及密码原语中存在的bugs。在ATF中，攻击者可以利用authentication checks中的缺陷绕过Amlogic S905 SoC secure boot process，因为只检查了boot image的完整性，而不是signatures。</p><h3 id="5-3-Extrinsic-Bugs"><a href="#5-3-Extrinsic-Bugs" class="headerlink" title="5.3 Extrinsic Bugs"></a>5.3 Extrinsic Bugs</h3><p>extrinsic bugs：improper handling of external factors（外部因素的不正确处理）</p><p><strong>concurrency bugs.</strong></p><p>OP-TEE中对文件系统concurrent access，允许一个TA删除trusted storage中的directory，而该directory正在被另一个TA创建。</p><p><strong>software side-channels.</strong></p><p>由区别于program logic的specific implementation artifacts导致，会泄露基于program exectution time的undeired information。（与程序的编程逻辑无关，由攻击者故意构造的访问方式导致的）</p><h2 id="6-Hardware-Issues"><a href="#6-Hardware-Issues" class="headerlink" title="6 Hardware Issues"></a>6 Hardware Issues</h2><p><img src="/2021/01/29/SoK-TrustZone/image-20201031102703976.png" alt="image-20201031102703976"></p><p>阴影的部件表示这些trusted components被单独分配给TEE software，允许与off-SoC peripherals进行访问。（部分涂色的表示可以被部分或者全部地用于这些SW）</p><h3 id="6-1-Architectural-Implications"><a href="#6-1-Architectural-Implications" class="headerlink" title="6.1 Architectural Implications"></a>6.1 Architectural Implications</h3><p><strong>Attacks through reconfigurable hardware components.</strong></p><p>OP-TEE是可以支持在Xilinx Zynq-7000以及Zynq UltraScale+上运行的，但对新平台的支持也可能会带来新的攻击面。FPGA的可配置硬件通常链接到main bus中，这也就意味着硬件必须组织运行在主CPU中的软件访问memory regions。一些攻击可能通过reconfiguration hardware logic来打破TrustZone-based system的安全性。</p><p><strong>Attacks through energy management mechanisms.</strong></p><p>比如说通过运行恶意kernel driver，该kernel推动频率和电压调节器运行在超过供应商规定的限制上，直到出现错误计算，从而提取出密钥，绕过code signing operations。</p><h3 id="6-2-microarchitectural-side-channels"><a href="#6-2-microarchitectural-side-channels" class="headerlink" title="6.2 microarchitectural side-channels"></a>6.2 microarchitectural side-channels</h3><p><strong>leaking information through caches.</strong></p><p>虽然secure cache lines是无法被NW访问的，但是两个世界都在竞争cache lines的使用权时被保证有相同的权利。（一般使用的方法是prime+probe？具体怎么用的我不太清楚secure world和normal world难道不是实现就已经分配好了缓存空间吗？使用时再进行contention？）</p><p><strong>leaking information throuth branch predictor.</strong></p><p>BTB(branch target buffer)单元中存储的是计算得到的taken branch instructions的目标地址，当对应的分支指令成功预测了就取指。BTB是被secure world和normal world共享的。不同于cache的cache-line粒度，在BTB攻击中的力度是byte级别的，这里的probe机制会增加attack vector的spatial resolution。</p><p><strong>leaking information using Rowhammer.</strong></p><p>仅仅通过memory read operation，攻击者就能够翻转physical memory的bits。</p><p>Rowhmmaer通过在non-secure memory border高频率的memory read operations会导致secure memory发生错误。</p><p>rowhammer需要控制好环境，而且相对来说很容易缓解</p><h2 id="7-TrustZone-Assisted-TEEs的防御措施"><a href="#7-TrustZone-Assisted-TEEs的防御措施" class="headerlink" title="7 TrustZone-Assisted TEEs的防御措施"></a>7 TrustZone-Assisted TEEs的防御措施</h2><h3 id="7-1-Architectural-Defenses"><a href="#7-1-Architectural-Defenses" class="headerlink" title="7.1 Architectural Defenses"></a>7.1 Architectural Defenses</h3><p><strong>Multi-isolated environments</strong></p><ul><li>在TEE组件之间增加隔离粒度（隔离的更细），控制安全漏洞可能造成的损害</li><li>限制运行在SW中的代码总量，减少发生提权攻击的可能性</li></ul><p>进行的尝试1：在NW中创建隔离环境（IEE）</p><ul><li>SANCTUARY和TrustICE：利用TZASC的特性</li><li>vTZ等论文尝试在NW中使用了硬件虚拟化扩展</li></ul><p>进行的尝试2：增强TA之间的隔离</p><ul><li>让TA运行在不同的isolated secure guests OSes（但由于SW中缺少硬件虚拟化，采取该方法的系统都使用same-privilege isolation来secure hypervisor from secure guest OSes）</li></ul><p><strong>secure cross-world channels</strong></p><p>SW和NW的隔离可能是不安全的，SW中的秘密信息可能被攻击者窃取。</p><p>理论上可以通过</p><ul><li>fix vulnerable TEE kernel system calls</li><li>cross-world isolation</li></ul><p>这些措施来加强secure NW-SW channels</p><p>但实际上的情况是</p><ul><li>在NW访问TEE资源时几乎没有authentication</li><li>insecure shared-memory for data exchange within the channel</li></ul><p>研究人员的尝试：</p><ul><li>SANCTUARY完成了exclusive shared memory</li><li>TFence绕过kernel创建了一个partially privileged process（a shielded  portion of the REE application process)，该进程能够直接和TEE通信。</li></ul><p><strong>encryption memory</strong></p><p>TEE memory protection中存在的缺陷大部分都可以从主流OS中找到机制解决。不同于SGX，TrustZone也没有内置支持on-chip memory encryption.</p><p>针对这个问题，研究人员们提供的方法有：</p><ul><li>允许TAs完全运行在cache中，当他们写回主存中，对TA state进行加密</li><li>Ginseng通过对variables标记为sensitive，这些variables平时运行在CPU registers，在保存回memory中时加密处理</li></ul><p><strong>Trusted computing primitives</strong></p><p>commercial TEEs依赖于secure boot来保证TEE image的完整性。但是目前的机制还不足以保证TA的client（不管是远程的还是本地的）来验证TEE和TA binaries的完整性。</p><p>所以作者的观点是完成额外的computing primitives，比如remote attestation和sealed storage</p><h3 id="7-2-implementation-defenses"><a href="#7-2-implementation-defenses" class="headerlink" title="7.2 implementation defenses"></a>7.2 implementation defenses</h3><p><strong>managed code runtimes</strong></p><p>用C编写的TEE系统往往没有提供memory safety，很多validation bugs是由memory violation errors产生的。</p><p>在TLR（alternative TEE system），TA并不会被编译成native code，而是.Net managed code，该code还会翻译为small-sized managed code runtime。虽然性能变差了，但是避免了validation bugs。</p><p><strong>type-safe programming languages</strong></p><p>使用type-safe的编程语言来完成TrustZone-assisted TEE软件的特定部分，比如说RustZone，OP-TEE的extension，TA都是由Rust编写的。</p><p><strong>Software verification</strong></p><p>implementation产生的原因就在于软件部分的预期要求和具体实现的不一致。</p><p>所以作者提出的解决方法是进行software verification，其中包含了model checking，symbolic execution以及formal methods，在于保证实现完全符合需求。</p><p>本文提到了Komodo对特定TEE components的formal verification取得了非常重要的进步（which implements the specification of Intel SGX enclaves）</p><h3 id="7-3-hardware-defenses"><a href="#7-3-hardware-defenses" class="headerlink" title="7.3 hardware defenses"></a>7.3 hardware defenses</h3><p><strong>architectural countermeasures</strong></p><p><strong>microarchitectural countermeasures</strong></p><ul><li>软件上careful implementation of cryptographic algorithms或者使用特定的硬件来避免cryptographic-related operations的信息泄露</li><li>利用cache maintenance techniques来避免cache上的信息泄露（要不然就是不使用L2 cache，要不然就是使用L2 cache之后要记得cache flush。</li></ul><p>对于避免Rowhammer，TEEs应该避免在NW-SW boundary使用memory。</p><h2 id="8-Beyond-TrustZone-Assisted-TEEs"><a href="#8-Beyond-TrustZone-Assisted-TEEs" class="headerlink" title="8 Beyond TrustZone-Assisted TEEs"></a>8 Beyond TrustZone-Assisted TEEs</h2><p>基于RISC-V的TEE</p><ul><li>keystone</li><li>HexFive</li></ul><p><img src="/2021/01/29/SoK-TrustZone/image-20201101105647248.png" alt="image-20201101105647248"></p><p>一些思考</p><ul><li>虽然arm在设计中设计的非常优秀，但实现中可能存在非常多的问题。所以漏洞一直都是能挖到的</li><li>arm上应该也有很多rowhammer的攻击，通过翻转NS这根线的比特位来改变处于的状态。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;S&amp;amp;P2020中关于TrustZone的SoK精读笔记~&lt;/p&gt;
    
    </summary>
    
      <category term="TrustZone" scheme="http://yoursite.com/categories/TrustZone/"/>
    
    
      <category term="TrustZone" scheme="http://yoursite.com/tags/TrustZone/"/>
    
      <category term="paper - System Security" scheme="http://yoursite.com/tags/paper-System-Security/"/>
    
  </entry>
  
  <entry>
    <title>Sanctuary NDSS2019</title>
    <link href="http://yoursite.com/2020/06/20/Sanctuary-NDSS2019/"/>
    <id>http://yoursite.com/2020/06/20/Sanctuary-NDSS2019/</id>
    <published>2020-06-20T13:27:50.000Z</published>
    <updated>2021-01-29T09:54:02.675Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是对<strong>SANTUARY:ARMing TrustZone with User-space Enclaves</strong>这篇论文的阅读笔记。</p><a id="more"></a><h1 id="SANCTUARY：ARMing-TrustZone-with-User-space-Enclaves"><a href="#SANCTUARY：ARMing-TrustZone-with-User-space-Enclaves" class="headerlink" title="SANCTUARY：ARMing TrustZone with User-space Enclaves"></a>SANCTUARY：ARMing TrustZone with User-space Enclaves</h1><p>由于厂商的严格限制，开发人员在开发或使用TrustZone受到很多限制（设备提供商进行限制的原因主要是Trusted App（TA）数量的增加会增加TEE的攻击面：也就是任何安全配置不严格或者有害TA将会降低系统的安全性），配置一个TA需要开发者和供应商双方的信任，这对双方来说都有很大的开销。供应商提供一些TEE功能接口，但是，这对移动应用程序来说是远远不够的，比如银行业务。intel SGX技术在学术和工业界引发的巨大讨论解释了对不受限制的TEE应用的需求，但是目前还没有在移动端应用上有类似的安全架构。  </p><p>SANCTUARY是第一款不依赖于虚拟化的TrustZone生态体系中可以无限制使用TEEs的安全架构。SANCTUARY允许在TrustZone中的normal world中以比较强的隔离组件运行security-sensitive apps，类似于sgx中的用户空间的enclaves。</p><p>研究人员们考虑将sensitive app放到normal world中，通过利用TrustZone的Address-Space Controller（TZASP），提供了两个硬件级别的隔离：</p><ul><li>security-sensitive app are shielded against a compromised normal-world OS;（防normal world中的恶意os）</li><li><strong>the system is also protected from potentially malicious apps in isolated compartments</strong>（防IEEs环境中的恶意apps）</li></ul><p>IEEs的存在能够最小化TEE的攻击面，TEE的最大潜能能够被利用</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>由于移动设备上存在着巨大的攻击面，所以导致在保护敏感应用（银行，支付，电子身份服务）时面临这巨大的安全和隐私挑战。由此，arm公司提出了TEE和TrustZone的概念。</p><p>normal world中运行Legacy OS（老式操作系统，LS）和用户级别的app；而secure world中运行的是security-sensitive app，secure world是在TrustZone内核和硬件上的可信执行环境（Trusted Execution Environment，TEE）</p><p><strong>TrustZone的问题</strong></p><p>近十多年来，TrustZone主要是被生产提供商出于自己的目的使用，TrustZone研究缺乏进展的主要原因是Trusted APP（TA）的安装会增加了受到安全攻击的可能性。也就是，TrustZone-enabled app中的bug将会导致很大数量的设备暴露在真实世界中的安全威胁中。</p><p>Google总结TrustZone的设计缺陷如下：</p><ul><li>weak isolation between TAs in the TEE（TEE中TA之间的不牢固的隔离）</li><li>TCB expansion（可信计算基的扩展）</li><li>highly privileged access to platform, making TrustZone a high-value target for attackers（TrustZone能够以很高的权限进入平台，这使得TrustZone对于攻击者来说是一个很高价值的目标）</li></ul><p>因此，设备提供商总是控制和限制对TEE的访问。一方面，vendor和app开发者在建立信任关系时必须要一个全面的安全评估；另一方面，对于开发人员来说，在TEE中开发一个TA是需要很大的开发开销。虽然vendor提供了一些针对normal world app的TEE接口，比如密钥存储设备，但这些功能无法保护开发者自己的敏感代码和数据。</p><p><strong>现有的安全架构</strong></p><p>目前的很多基于ARM的安全架构依赖于虚拟内存进行隔离，但对于安全世界中的TrustZone中的TA的隔离还是不充分的。在目前的多核平台上完全利用时间隔离的措施将会极大地影响用户体验（悬挂整个系统来保护TA的运行）</p><p>在分析了开发者遇到的问题和TrustZone所作出的妥协和努力后，得出结论：<strong>目前提供的TEE服务是无法满足功能丰富的安全移动服务</strong>。</p><p>目标：解决上述提到的问题，方便第三方的app开发者在无需进行硬件修改的情况下能够最大程度地使用TEE。</p><p>名词解释：</p><ul><li>SA：Sanctuary Apps，在IEEs中的secure-sensitive app，相当于SGX用户空间中的enclaves</li><li>isolated compartments：IEEs，SANCTUARY实例</li><li>LA：Legacy Apps</li><li>LOS：Legacy OS</li><li>TF：Trusted Firmware</li></ul><p><strong>目标</strong></p><ul><li><p>将secure-sensitive app移植到IEE中，减少了TEE中的代码量</p></li><li><p>SANCTUARY通过dynamically partitioning和re-allocating系统资源达到了SA隔离：CPU内核和物理内存会被暂时保留给IEE来运行SA，并不会悬挂系统的剩余部分</p></li><li><p>利用TZASC（地址空间控制器）来保证SAs和其他系统组件之间的hardware-enforced，two-way isolation（硬件执行且双向的隔离）且无需硬件上的修改</p></li></ul><p>要解决的问题主要：1）如何动态分配内核；2）如何在普通世界中强制一个严格的隔离；3）提供和SGX类似的安全服务；4）在现实场景中能够提高性能</p><p><strong>贡献</strong></p><ul><li>提出了SANCTUARY的设计，在IEE环境中提供了类似于enclave的功能；（提出设计）</li><li>在HiKey 960开发板和OP-TEE上实现了概念验证；（实现）</li><li>分析了当有一个强大攻击者的设置下SANCTUARY的安全属性（安全性）</li><li>进一步探讨了SANCTUARY在建立和通信时的开销（性能）</li></ul><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2 背景"></a>2 背景</h2><p>TrustZone代表的是ARM架构中在处理器设计和SoCs中的安全加强。</p><p>TrustZone-enabled处理器在4个不同的privilege levels运行（EL0-EL3）</p><ul><li>EL3（monitor mode）：在ARM Trusted Firmware（TF）上，secure world和normal world在EL0-2三个等级上进行分割来管理各自的地址空间</li><li>EL2：optionally used for a hypervisor</li><li>EL1：OS kernel</li><li>EL0：used for execution of application</li></ul><p><img src="/2020/06/20/Sanctuary-NDSS2019/1.png" alt="img"></p><p>SMC（secure monitor call）：从normal world到secure world的上下文切换指令。当一个内核发出SMC指令时，在多核系统中的其他内核都可以仍然处于normal world mode。</p><p>内存地址空间也被分为secure world和normal world，这种隔离是由TrustZone地址空间控制器来完成的。</p><p>运行TrustZone的设备是在secure world中启动的。在secure world启动完毕之后Trusted OS（TOS），secure world就会切换到normal world，并开始启动老式操作系统（LOS）。（secure boot：在运行之前引导加载器以加密形式检查TOS。事实上，很多vendor就是通过secure boot锁定终端用户的修改，来保证安全世界的完整性。比如说，通过哈希获得安全验证码，一旦修改后，验证码不能对得上，就无法启动）</p><p>如图1所示，TZASC在系统总线和内存芯片之间的位置。TZASC基于不同的总线事务特征提供多个内存区域和访问控制设置。（通过总线事务特征对内存区域进行划分，并进行访问控制）</p><p>最开始的设计只限于两种不同的内存访问：non-secure（NS=1）和secure访问（NS=0）。secure模式下的内核能够访问secure和non-secure的内存；而non-secure模式下的内核只能访问non-secure的内存。</p><p>2013引入的TZC-400，可以利用总线事务上的额外特征——identity-based filtering（基于身份的过滤）来分隔受保护的内存区域。在目前的ARM参考设计中指出，每个设备（比如CPU，GPU，DMA控制器）都能够在硬件中被分配一个bus-master ID，从而充当一个总线主设备（bus master）的角色。这就可以将内存区域分配给特定的bus master来进行non-secure访问。</p><h2 id="3-攻击模型和要求"><a href="#3-攻击模型和要求" class="headerlink" title="3 攻击模型和要求"></a>3 攻击模型和要求</h2><p><strong>攻击者模型</strong></p><ul><li>攻击者可以破坏normal world中的所有软件，最高可以到optional hypervisor（EL2）（通过远程或者本地软件攻击）</li><li>进行passive physical attacks</li><li>攻击者无法破坏secure world软件以及monitor mode</li></ul><p>不考虑涉及硬件的物理攻击。SANCTUARY也不确保可用性，比如抵御DoS攻击。</p><p><strong>几点假设</strong></p><ul><li>normal world中的app和LOS是不可信的</li><li>不同特权级别的隔离是硬件通过虚拟内存执行的</li><li>现存的架构抵御措施，比如Execute Never(XN), Unprivileged Execute Never(UXN), Privileged Execute Never(PXN), Privileged Access Never(PAN)都被配置并且被激活</li><li>secure world中的boot loader和EL3硬件（monitor mode）都是可信的</li></ul><p>SANCTUARY可以通过将一部分Trusted Apps部署为Sanctuary Apps（IEEs App）来减少secure world中的软件数量。</p><p><strong>需求分析</strong></p><p>SANCTUARY必须达到的安全要求</p><ul><li>代码和数据完整性：1）SA执行的隔离；2）SA代码被装载到IEEs中进行认证</li><li>数据机密性：1）数据在安全信道中提供（运行之前）；2）执行期间的空间隔离；3）temperal isolation，在SA执行结束后，敏感信息不能被访问</li><li>通向安全世界的安全信道：通过exclusive shared memory，只能由SA和secure world访问</li><li>考虑恶意SA的存在，尽可能地限制SA的访问权限（EL0）</li><li>硬件执行的资源隔离：保证严格的空间隔离（spatial）和时间（temporal）隔离（空间的话，就是无法访问内存，时间我的理解是执行之前，执行中，执行之后三个时间段来考虑无法获取秘密信息）</li><li>最小的软件改变：利用现存的secure world OS和normal world OS的接口来避免最少的修改</li><li>积极的用户体验：通过最小化SA的run-time environment来保持低延迟</li></ul><h2 id="4-SANCUTARY设计"><a href="#4-SANCUTARY设计" class="headerlink" title="4 SANCUTARY设计"></a>4 SANCUTARY设计</h2><p>SANCTUARY allows <strong>the creation of multiple parallel isolated compartments</strong> on ARM devices in the normal world which are stricly isolated from the LOS and Legacy Apps(LAs).（SANCTUARY允许ARM设备上的normal world创建多个平行的isolated compartment，这些IEE与LOS和LA严格隔离。）</p><p>这边的isolated compartment，就是上一篇论文中的isolated execution environment，本文作者进一步把它阐述为SANCTUARY instances，其中运行的secure-sensitive app被称为Sanctuary Apps（SA）。每一个SANCTUARY instances一次只能运行一个SA。由于每个SANCTUARY instances与其他实例都严格隔离，所以每个SA之间也是严格隔离的。另外，SANCTUARY instances也是与secure world隔离的。</p><p>SANCTUARY实例通过以下几点保证空间的独立性：</p><ul><li>利用TZC-400 memory controller分割物理内存；</li><li>给SANCTUARY instances指定一个CPU core</li><li>exclude the SANCTUARY Instances’s memory from  shared caches.（不让使用共享缓存）</li></ul><p>时间的独立性（temporal isolation）</p><ul><li>从可信状态（TF）启动SANCTUARY CPU内核</li><li>在退出之前将内存中的所有敏感信息清空</li></ul><p>SANCTUARY对现有的TEE架构只需要扩展而无需影响normal world和secure world中已经配置好的软件功能。</p><p><img src="/2020/06/20/Sanctuary-NDSS2019/2.png" alt="img"></p><h3 id="4-1-SANCTUARY-Isolation"><a href="#4-1-SANCTUARY-Isolation" class="headerlink" title="4.1 SANCTUARY Isolation"></a>4.1 SANCTUARY Isolation</h3><p>SANCTUARY实现了normal world的隔离。通过利用ARM的新的内存访问控制器TZC-400，一块特定的内存可以被控制exclusively（专有的）被某个CPU内核访问。</p><p>图2展示了SANCTUARY的设计概览，同时也显示了SANCTUARY的two-way isolation：SANCTUARY instances被配置have exclusive access to Sanctuary RAM部分，而该实例同时也不允许访问normal world memory，也就是他们也不被允许访问core0和core1的内存或者是其他SA的内存。 </p><p>SANCTUARY支持</p><ul><li>shared memory between normal world and SA-》高效通信</li><li>shared memory between secure world and SA -》建立安全信道</li></ul><p>secure-world software是可信的，因此能够访问所有的内存（normal-world memory, SANCTUARY memory, secure-world memory）</p><p>多SA之间的隔离</p><p>SANCTUARY实例可以持续地运行在相同的内核也可以运行在不同的CPU内核上。</p><p>Multi-SA isolation: <strong>All SAs are executed completely independently of each other.</strong>当SA执行完毕时，系统返回初始状态，下一个SANCTUARY实例能够被启动。（<em>一次只能运行一个SA吗？</em>）</p><p>Privilege isolation: SAs被限制以user-mode运行。Sanctuary Library (SL)以EL1-mode（privileged mode）运行，是为了提供两个功能：1）initial an execution environment for the SA;2)provide service interfaces to the SA(为了访问SANCTUARY的安全服务) </p><h3 id="4-2-SANCTUARY初始化"><a href="#4-2-SANCTUARY初始化" class="headerlink" title="4.2 SANCTUARY初始化"></a>4.2 SANCTUARY初始化</h3><p>SA代码是由LOS加载的，所以它的完整性必须被验证。</p><ol><li><p>SANCTUARY在不影响系统可用性的情况下，选择一个CPU core，将该CPU core中之前运行的LOS的数据保存到normal world中。其他的CPU内核仍然处于LOS的控制之下，所以并不会影响系统的可用性。</p></li><li><p>将SL和SA的代码加载至separate memory section，在激活memory isolation后，通过digital signatures对加载的代码进行验证（SL的签名由device vendor提供，而SA的签名由SA开发者提供）。验证成功后，SANCTUARY core starts from a defined initial state,boots the SL  and executes the SA.</p></li><li><p>当SA结束后，the dedicated core移除memory中的信息，使缓存中的数据无效，并关闭。将被分配的memory和CPU core的使用权重新还给了LOS。</p></li></ol><h3 id="4-3-SANCTUARY安全服务"><a href="#4-3-SANCTUARY安全服务" class="headerlink" title="4.3 SANCTUARY安全服务"></a>4.3 SANCTUARY安全服务</h3><p>SA是从不可信的unprotected memory中加载的，所以SA的initial content中是不能包含机密信息的。而机密数据可以在SA被创建后通过一个secure channel传递过来。为了保证SA不是malicious的，TA需要在传递之前对SA的integrity和authenticity进行验证。为了确保SA机密数据的安全传递和安全存储，SANCTUARY提供了一系列的安全服务，这些安全服务由设备供应商提供的TA来完成，下文称之为vendor TA。</p><p>Remote Attestation：基于TrustZone平台身份特性（platform identity feature），SANCTUARY的完整性测量结果能够准确地传送给指定的第三方。将完整性可信报告与通向SA的可信信道相链接，将会创造一个安全可信的信道，通过该信道，我们能够传递机密信息（ Linking the authentic integrity report with the establishment of a secure channel to the SA creates a secure and authenticated channel through which confidential data can be provisioned.）（<strong>个人理解：可信信道的建立需要双方的信任，由于secure world是可信的，所以这里只需要SANCTUARY对secure world证明自己的完整性，SANCTUARY实例将自己的完整性报告通过NSAID准确地传送到指定的第三方，就是这边的secure world中的应用，secure world进行验证后，建立信道就可以进行机密信息的传输。</strong>）</p><p>sealing：类似于sgx的sealing，用从SA二进制文件计算得来的散列值派生出的unique encryption key（derived from the hash value computed over the SA binary）对机密信息进行加密（sgx中的sealing分为两种，两种的区别在于当应用更新换代后，密钥是否改变，如果不变后代还能解密前代应用的数据（sealing to sealing identity），反之则无法解密之前的数据（sealing to enclave identity））</p><h3 id="4-4-SANCTUARY软件模型"><a href="#4-4-SANCTUARY软件模型" class="headerlink" title="4.4 SANCTUARY软件模型"></a>4.4 SANCTUARY软件模型</h3><p><strong>（每个SA都隶属于一个不可信的LA）each SA belongs to an untrusted LA.</strong>也就是，SA就是LA的一部分，在应用程序市场上进行安装的时候，可以使用标准的安装流程。通过将SA和LA结合，SL的功能性将可以减小。LA作为一个代理，可以允许SA使用LOS提供的服务，另外，LA和SA可以通过共享内存交换信息。当SA需要将信息保存到LA中永久存储，就可以用sealing在传递给LA之前进行加密操作。（LA和SA的关系是什么，他们之间的互动）</p><p>总结一下，这边的sealing服务更像是为LA和SA通信设计的；而remote attestation是为了SA和secure world之间通信设计的。</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5 实现"></a>5 实现</h2><p>基于的硬件：HiKey960（four ARM Cortex-A73 and four Cortex-A53 cores），ARMv8 SoC。（HiKey960是少数几款允许开发者在secure world中配置自己的软件的开发板之一）</p><p>SANCTUARY软件组件</p><ul><li><p>secure world Trusted OS-》OP-TEE（SANCTUARY并不局限特定的TOS）</p></li><li><p>Legacy OS-》与使用的OP-TEE捆绑的Linux发行版</p></li><li><p>使用自定义的kernel module作为LOS的一部分，用于在normal world中管理SANCTUARY实例</p></li><li><p>在OP-TEE中，完成了两个vendor TA，分别是Proxy TA（用于remote attestation）和Sealing TA（用于sealing）</p></li><li><p>一个SANCTUARY实例包括Sanctuary Library（SL）和一个SA。在本文的原型实现中，使用了Zircon micro kernel（因为很小，只有1MB且多功能性）作为SL的基础。</p></li></ul><p>图3中的STA就是本文作者添加到OP-TEE中的自定义部分，代码量仅有1313行（所有secure部分的修改），其中两个vendor TA占一半的代码量。同时，由于将所有第三方开发者对TA的修改移出了TCB，TCB的大小也减小了。</p><p>以Pearl-TEE为例，实现一个mobile payment和chat TA包含了900和200LoC，这可以看做是完成一个有用的TA的最低标准。作者认为，这也表明了从将TA从secure world中移除比对OP-TEE和TF的代码量增加更重要。（增加这样的一个TA程序就会达到几百行，如果无限制地向secure world中写入代码，将会导致TCB越来越大，所以进行一次性的修改更好）</p><p>（对该表的解释：除了增加两个vendor TA，作者仅对TCB进行少量的一次性修改）</p><p><img src="/2020/06/20/Sanctuary-NDSS2019/3.png" alt="img"></p><p><strong>SANCTUARY 硬件组件</strong>。SANCTUARY利用的原理是每个CPU core都可以被分配一个unique master ID，因此，每个内存事务都只被一个core执行。事务ID也能够从硬件级别上过滤内存访问，这些过滤和许可操作都是由TZC-400内存控制器执行的。TZC-400基于两个特性来允许或者禁止对内存区域的访问： 1)CPU内核运行代码的访问事务类型（secure or non-secure）；2）执行SANCTUARY instances的CPU core的bus master ID（鉴别是secure world还是normal world；另一方面，鉴别bus master ID）（解释图3）</p><p><strong>SANCTUARY usage.</strong>当LA想要在SANCTUARY实例中的一个SA中执行敏感代码时，</p><ol><li>LA向KM请求执行与LA绑定的SA；</li><li>KM通过加载SANCTUARY二进制文件（SL和SA）启动SANCTUARY实例的设置。接着，KM将某个CPU内核上的LOS移除并将控制权移交给STA；</li><li>STA执行安全相关的步骤，比如SA的验证；</li><li>在成功建立起SANCTUARY实例，KM触发SANCTUARY的引导程序；</li><li>当引导程序结束后，SA能够运行敏感代码，并且能够与LA和TA进行通信。</li></ol><h3 id="5-1-Legacy-OS"><a href="#5-1-Legacy-OS" class="headerlink" title="5.1 Legacy OS"></a>5.1 Legacy OS</h3><p>KM主要负责管理SANCTUARY实例所需要的所有资源，位于LOS中。</p><ul><li>KM能够为SANCTUARY实例提供运行时所需要的CPU core，将LOS从某个CPUcore中清除出去，也可以在SANCTUARY实例结束运行时将该core归还给LOS。 </li><li>KM为SANCTUARY实例动态分配内存，并建立从SA到TA的双向信道</li><li>在SANCTUARY实例能够运行之前，KM将SANCTUARY binaries（SL和SA）加载至即将被exclusively分到SANCTUARY内核的内存中</li></ul><p>总结：KM就是准备各种资源，比如CPU core资源，内存资源，以及LA和SA的访问资源</p><h3 id="5-2-安全服务"><a href="#5-2-安全服务" class="headerlink" title="5.2 安全服务"></a>5.2 安全服务</h3><p>Trusted Apps-》SEL0（secure world user space)</p><p>OP-TEE -&gt;SEL1 (secure world kernel space)</p><p>Proxy TA：负责建立一个SA到remote servers连接的安全信道，所有通过Proxy TA传输的数据都用platform key认证过，并且与发送者SA的身份绑定。（私钥加密，公钥解密？或者是用plateform key对称加密？）</p><p>Sealing TA：将数据与一个特定的SA绑定，并且在设备上永久存储（sealing to enclave）每个SA使用一个individual key。</p><p>STA：代表OP-TEE中的kernel module。STA使用预先配置好的签名验证SL，建立SANCTUARY实例，最后tear them down。（对SA binary计算得哈希值；判断某个SANCTUARY实例中正在哪个运行的SA）</p><p>secure world和normal world中的上下文切换工作由TF负责</p><h3 id="5-3-Sanctuary"><a href="#5-3-Sanctuary" class="headerlink" title="5.3 Sanctuary"></a>5.3 Sanctuary</h3><p>一个SANCTUARY实例包含两个部分：SL和SA。SL为运行SA提供基本的进程和内存管理功能。</p><p>当Ziron启动后，它为SA准备好运行所需要的环境，包括配置CPU内核，设置内存映射以及一个基本的运行环境。</p><p>接着，SA作为Ziron微内核的一个normal world用户进程。在运行过程中，SA可以和LA或者TA进行通信。</p><h3 id="5-4-Memory-isolation-unit"><a href="#5-4-Memory-isolation-unit" class="headerlink" title="5.4 Memory isolation unit"></a>5.4 Memory isolation unit</h3><p>在给SANCTUARY的执行分配指定的内核进行隔离之外，通过利用TZASC可以保护SANCTUARY内存不受其他内核中来自normal world的访问。</p><p>TZC-400 基于bus master ID设置内存访问许可。</p><p>传统上，在ARMv8的架构中，所有的内核都被分配了一个独一无二的多处理器ID（uniquely-assigned multi-processor-IDs）。当内核中的事务被传送到系统总线上时，多处理器ID会通过一个指定的labeling component被转化为bus master ID。但是在HiKey960的开发板中，内核上的所有事务都被标记为同样的bus master ID。对于SANCTUARY来说，只需要修改映射策略（mapping policy）以便于内核中的bus transactions被标记上不同的bus master ID。（<em>物理地址映射到虚拟地址的时候，标记为某个特定的core的内存地址？</em> 还是<em>直接对core ID进行映射修改？</em>）</p><p>对labeling ID-mapping policy的修改使用的是ARM Fast Models virtualation工具。在软件上，配置TZC-400从而通过对bus transactions的bus master ID labels进行过滤，使得内存区域被唯一地分配给单独的内核。（SANCTUARY需要格外做的是标记上unique ID，对每个事物分配bus master ID labels已经是由TZC-400做好的）</p><p><img src="/2020/06/20/Sanctuary-NDSS2019/4.png" alt="img"></p><h3 id="5-5-execution-life-cycle"><a href="#5-5-execution-life-cycle" class="headerlink" title="5.5 execution life cycle"></a>5.5 execution life cycle</h3><p>假设SL的签名已经存储在了secure world中。</p><p><strong>Sancturay Setup.</strong>安装步骤是由normal world中的KM（管理系统资源）和secure world中的STA执行的（执行所有的安全相关的步骤）。1）在需要执行SA中的敏感代码时由LA触发，LA在文件系统中加载SL and SA binaries，并通过procfs转交给KM。SL binary只能被加载一次，并一直在内存中保持到系统关闭（shut down）；（Sanctuary Data是KM保留了用于SA运行时进行内存分配的内存，另外，部分也会用于SANCTUARY实例的通信信道，比如LA和SA之间进行通信，secure shared memory则是用于SA和TA之间进行通信。（LA）</p><p>2）KM选择a CPU core来运行SANCTUARY实例，接着，采用linux的hotplug技术shut down这个被选择的内核；（KM）</p><p>3）KM调用STA，并对选择的core提供了一个ID作为参数。这里的调用就进入了monitor mode（SMC调用，从normal world进入secure world），TF在进行上下文切换时检查被选择的core是否被shut down，然后将控制权转交给STA。STA通过配置TZC-400将SANCTUARY内存锁定。（STA）</p><p>TZC-400对内存区域的配置。举个例子</p><p>这里假设一共有8个core，将0-7分配给这8个core作为编号，假定SANCTUARY被选择的内核编号为ID 7。假设这里仅有CPU core有访问内存的需求。TZC-400对内存区域进行分块，最高可以分成9块，配置这9块地址空间覆盖SL和SA二进制文件，Sanctuary Data和secure shared memory所驻留的连续内存空间。</p><p>地址范围的确定，比如region1，最低地址（lowest address）由REGION_BASE_LOW_1和REGION_BASE_HIGH_1 registers设置，最高地址（highest address）由REGION_TOP_LOW_1和REGION_TOP_HIGH_1 register设置。</p><p>这里以region1举例，当region1被配置好后，接下来通过REGION_ID_ACCESS_1 register被分配给SANCTUARY core。如图5所示，其中，upper 16 bits定义了non-secure write access permissions，low16 bits定义了non-secure read access permissions.每个bit都和一个bus master ID相对应。假设这边的bit0和bit16都被配置为1，其他都为0，就意味着bus master ID为0的设备在region1上能够进行读写。</p><p><img src="/2020/06/20/Sanctuary-NDSS2019/5.png" alt="img"></p><p>external interrupts are configured using the core’s CPU interface of the GIC(General Interrupt Controller) which can not be accessed by other cores.</p><p>假设这边的REGION_ID_ACCESS_1的值为0x800080，那么就代表这region1的地址仅能被ID为7的设备访问。0x800080-》0x00800080，0080中的1在低8位上，也就是ID为7的bit上。</p><p>0x7F007F代表除了SANCTUARY core其他core都能访问的normal world内存。（SANCTUARY core ID为7）</p><p>non-secure shared memory：0xFF00FF</p><p>secure-world memory：0x0</p><p>最终对不同的内存区域，core ID和运行模式的内存许可在图3中。STA使用存储的电子签名验证SL binary。</p><p>（REGION_ID_ACCESS_1寄存器的设置，STA通过RSASSA_PKCS1-v1_5和SHA-256对SL进行认证）</p><p><strong>Sanctuary Boot.</strong> </p><p>1）在SANCTUARY被成功设置后，KM调用TF启动SANCTUARY core。（分成三步，分别是TF初始化，TF检查SANCTUARY实例，TF启动core）</p><p>在启动core之前，TF首先会检查SANCTUARY实例是否被正确地锁定和验证。SANCTUARY first executes the TF in EL3.在接受到boot命令后，SANCTUARY core在EL3上进行TF的初始化。在初始化的过程中，还需要配置好exception handler（在SL set up的过程中，exception handler会调用TF；而在teardown的过程中，TF也会被调用来shut down SL）</p><p>2）TF初始化完毕后，SANCTUARY core切换到EL1，并跳转到SL的入口点。</p><p>不允许SANCTUARY内存被缓存到L2 cache中。 外部中断配置使用core的GIC（General Interrupt Controller）的CPU接口，这个接口不能被其他内核访问。</p><p><strong>SA运行</strong>。</p><p>当与对应的LA通信时是通过non-secure shared memory。由于在non-secure shared memory中访问的数据都是可以被normal world访问的，所以这部分并不是SANCTUARY memory partition。这部分的通信，在SANCTUARY部分是通过Zircon system call完成的，而在normal world部分，是由LOS中的KM来配置的。</p><p>当与vendor TA通信时通过secure shared memory。在secure world这边，该通信是由STA完成。secure shared memory是指派给SANCTUARY core的受保护的SANCTUARY内存区域。</p><p>SA与TA的通信有两种实现方法：1）将Ziron中包含OP-TEE驱动，切换到secure world的工作就可以由SANCTUARY自己来完成；2）到安全世界的连接由SA对应的LA触发。本文作者选用的是第二种，这样可以对Ziron核进行更少的修改。</p><p><strong>SANCTUARY teardown</strong></p><p>由LA触发SANCTUARY的teardown操作。</p><p>1）当LA对SA发起信号表示SANCTUARY的服务并不再需要时，关闭SANCTUARY core。如果需要的话，SA通过sealing服务保存自己的状态。内部清理操作使Zircon核返回初始状态，并使L1 cache中的数据无效避免数据泄露，接着，SL对STA发起信号，表示自己已经成功完成了清理操作；（SA）</p><p>2）TF关闭该内核。在切换世界并将控制权转交给STA之前，TF进一步判断SANCTUARY core是否被真正地关闭；接着，STA检查SA是否完成了自己的清理操作，接着 unlock SANCTUARY内存，将secure memory和Sanctuary Data清零，防止信息泄露。（TF和STA）</p><p>3）TZC-400的配置被恢复，这样，SANCTUARY内存区域和SANCTUARY core都被释放。（内存部分）（TZC-400）</p><h2 id="6-安全性分析"><a href="#6-安全性分析" class="headerlink" title="6 安全性分析"></a>6 安全性分析</h2><p>根据图2，攻击者能够在本平台上从三个角度进行攻击：</p><ul><li>normal world用户空间</li><li>normal world OS</li><li>malicious SA</li></ul><p>在这三种情况下，攻击者的目标都是破坏victim SA的完整性或者数据机密性或者获取LOS的控制权。这些可以发生SA的整个life-cycle中（setup，boot，execution，teardown）。</p><p>本文从以下五个角度来进行安全分析：</p><ul><li>normal world中的恶意代码的目标可能是在SL和SA binaries被加载之前对他们进行操控；（加载前修改，通过完整性检测发现）</li><li>克服SANCTUARY的隔离；（？不知道咋克服）</li><li>操纵永久存储在SA中的数据；（sealing ？）</li><li>通过cache从某个SA中提取信息（可以做到吗？L2都关了）</li><li>恶意SA</li></ul><h3 id="6-1-binary-integrity"><a href="#6-1-binary-integrity" class="headerlink" title="6.1 binary integrity"></a>6.1 binary integrity</h3><p>SL和SA的binaries都在无加密地保存在normal world中的内存。对SL和SA的完整性是通过本地认证和远程认证来实现的。</p><p>SANCTUARY在secure-world内存中保存了一份SL的签名。在SANCTUARY实例执行之前，STA首先对SL binary的签名进行验证。如果验证失败，则证明SL binary一定是被修改过，那么该文件将不会被执行，SANCTUARY的建立过程也会被中断。</p><p>SANCTUARY通过remote attestation来验证SA的完整性。STA对SA生成一个签名，将该签名一并发给server，server在将敏感数据发送给SA前，将SA与该签名进行对比，如果SA处于一个invalid状态，则停止传递。</p><h3 id="6-2-code-and-data-isolation"><a href="#6-2-code-and-data-isolation" class="headerlink" title="6.2 code and data isolation"></a>6.2 code and data isolation</h3><p>在SL被验证之前，SANCTUARY memory isolation就被TrustZone完成。在SANCTUARY内存被锁定之后，只有SANCTUARY core才能在自己的内存区域中从normal world进行读写操作。</p><p>被选择的SANCTUARY core永远在TF中被启动，接着，跳转到SL的一个地址，该地址作为一个常数被保存在TF中。在SANCTUARY的启动过程中，其他内核的中断都被disabled，只有SANCTUARY core自己能够配置它的GIC。最后，也只有SANCTUARY core能够关闭自己。</p><p>在SANCTUARY的运行期间，到secure world的切换的调用必须由SANCTUARY core发起，如果是其他core发起，该调用会被blocked。如果确实是由SANCTUARY core发起，TEE中的vendor TA还会使用STA判断SANCTUARY实例是否在correct state，只有检查通过，才能在secure shared memory上读写数据。（就是在运行的过程中，会通过proxy TA利用remote attestation）</p><p>在SANCTUARY instances的内存区域被locked之前或者被释放（unlocked）之后，STA都会对SANCTUARY内存进行重写，而不是为SL或者SA保留一个固定值。在关闭之后，SL会恢复原来的值，所以并不会保留有SA数据。</p><h3 id="6-3-安全存储"><a href="#6-3-安全存储" class="headerlink" title="6.3 安全存储"></a>6.3 安全存储</h3><p>当需要将SA data进行永久性存储的时候，就会使用sealing技术，sealing所用到的密钥是从SA binary的散列值派生得来的。所以，只有一个未发生修改的SA能够成功解密自己的sealed data。</p><p>对sealed data的永久保存，SANCTUARY实例使用TEE提供的功能，可能需要SA将自己的数据与设备绑定（不太清楚）或者将数据保存到roll-back protected memory。</p><h3 id="6-4-抗击缓存攻击的能力"><a href="#6-4-抗击缓存攻击的能力" class="headerlink" title="6.4 抗击缓存攻击的能力"></a>6.4 抗击缓存攻击的能力</h3><p>在ARMv8平台上，考虑攻击者从L1 cache或者L2 cache层面上进行攻击，L1 是core-exclusive，而L2 cache是shared。配置攻击有两个场景：direct attacks和side-channel attacks。</p><p>一个拥有特权的攻击者即使在没有读取主存物理地址的允许时，也可能获得对SANCTUARY instances的cached data的直接访问。对于L1 cache，是通过将SANCTUARY instances运行在自己的core上，并在实例被关闭和解锁之前都对L1 cache的数据进行无效化处理。对于L2 cache，一个是通过设置outer uncacheable，就是不允许SANCTUARY 内存被缓存到L2上，这也会带来一定的开销。另一个方法是在硬件级别修改缓存，增加对L2访问时的基于身份的过滤。</p><p><strong>侧信道攻击</strong></p><p>L1 cache是在core中运行的，并且在shut down之前，L1 cache中的数据会全部无效化，所以L1 cache不会受到侧信道攻击的威胁。</p><p>但对于L2 cache，对L2 cache进行身份过滤时也无法避免侧信道攻击的问题。只有不允许SANCTUARY memory缓存到L2 cache中，才能解决这个问题。</p><h3 id="6-5-恶意SA"><a href="#6-5-恶意SA" class="headerlink" title="6.5 恶意SA"></a>6.5 恶意SA</h3><p>如果用户无意间安装了一个恶意的SA，以此尝试攻击normal world中的LA和LOS。SA仅仅拥有user privilege（EL0），而SL是EL1.即使攻击者进行了提权操作，获取了SL的控制权，secure world内存仍然是无法被攻击者访问，因为SA运行在normal world中，SA只能访问被分配的SANCTUARY内存，而不允许访问其他的normal world内存，所以仅有与LA通信用的non-secure shared memory会被影响。</p><p>SANCTUARY的设计针对于LOS和IEE同时运行的场景，但是一个时刻只能运行一个SA，所以不存在SA之间的非预期的信息流，也就是恶意SA泄露其他SA的信息。</p><h2 id="7-评估"><a href="#7-评估" class="headerlink" title="7 评估"></a>7 评估</h2><h3 id="7-1-基准测试"><a href="#7-1-基准测试" class="headerlink" title="7.1 基准测试"></a>7.1 基准测试</h3><p>评估平台：HiKey960 (four ARM Cortex-A73，four Cortex-A53 cores，每个Cortex-A73内核装载了64KB L1指令缓存和64KB的L1数据缓存，分享2MB的L2缓存，Cortex-A53分享512KB的L2缓存，具有32KB的L1指令缓存和32KB的数据缓存)</p><p>若需要使用L2 cache，则不考虑侧信道攻击（也就是侧信道攻击是无法避免的）在shared L2中，作者考虑的是identity-based filtering是实现的。</p><p>其中，方括号的值是表示在不使用L2的情况下，测量结果几乎未受到影响。</p><p>1）Sanctuary中的通信。</p><p>图2展示了在SANCTUARY中存在的不同的通信信道。</p><p>SA和TA之间通信的较高开销是由于上下文切换是由LA触发的，所以SA需要先与normal world进行通信，而后由LA进行触发。</p><p>虽然LA-》SA的通信时间增加了1.66倍，但所需要的时间仍然是practical的，与标准的TrustZone通信所需要的时间相当。</p><p><img src="/2020/06/20/Sanctuary-NDSS2019/6.png" alt="img"></p><p>2）Sanctuary设置</p><p><img src="/2020/06/20/Sanctuary-NDSS2019/7.png" alt="img"></p><p>运行SANCTUARY实例和TA的时间差别主要是在隔离一个CPU内核上。</p><p>首先是从加载Sanctuary binaries步骤，都只需要7ms；</p><p>第二步，使用linux的hotplug技术关闭内核；</p><p>第三步，SANCTUARY被锁定并验证；</p><p>第四步，Ziron核启动，这里作者分成了三个小步，1）对core的初始化；2）platform component被初始化，kernel 环境被设置；3）用户环境被设置。</p><p>虽然在不适用L2 cache时，所用到的时间分别是7倍和36倍，但总的时长是450ms。如果使用identity-based filtering特性，setup需要的时间大概是200ms。</p><p>3）SANCTUARY teardown</p><p>在shut up步骤，L1 cache被无效化，Zircon kernel恢复到原始状态。在unlock步骤，SANCTUARY内存被赋予0值。完整的teardown操作大概需要100ms。</p><p><img src="/2020/06/20/Sanctuary-NDSS2019/8.png" alt="img"></p><p>对于SANCTUARY来说，set up和teardown除去runtime的时间，在有L2的情况下需要340ms；而在没有L2的情况下大约需要600ms。</p><h3 id="7-2-Use-Case：OTP生成双因素认证"><a href="#7-2-Use-Case：OTP生成双因素认证" class="headerlink" title="7.2 Use-Case：OTP生成双因素认证"></a>7.2 Use-Case：OTP生成双因素认证</h3><p>OTP：One-time Password app：用于对SA密封一个密钥，在将来的某个点恢复它来生成一个新的OTP。使用SANCTUARY的话，服务提供商就可以提供保护密钥的自定义app，而且无需在TEE中安装自己的TA。</p><p>（1）场景定义：two-factor authentication，网站上用于认证用户的策略</p><p>第一个因素，代表的是用户和用户的密钥；第二个因素，代表着生成fresh OTPs的硬件token或者移动设备。OTPs通过用户设备和验证服务器之间共享的密钥生成而来。这里的OTPs是通过一个时间戳算法生成的。</p><p>GenOTP app，TEE中包含了一对非对称密钥（SKdevice，PKdevice），在GenOTP的安装过程中，PKdevice被传送给retailer的后端</p><p><img src="/2020/06/20/Sanctuary-NDSS2019/9.png" alt="img"></p><p>（2）生成密钥</p><p>通过上图第一行和第二行的操作后，SA得到了密钥KTOTP。SA可以一直保存该密钥，使用sealing技术将KTOTP进行加密，得到SSA_S（借助sealing TA根据SA binary 哈希值派生得到sealing操作的密钥KSA）。（也就是这边的第三行）</p><p>（3）产生OTP</p><p>当消费者想要生成一个fresh OTP来登录进零售商的online shop时，可以选择从LA生成OTP。SA通过get_state调用Sealing TA，Sealing TA恢复保存的数据，得到SSA_S，接下来根据SA binary哈希值得到Sealing的对称密钥，对SSA_S进行解密，解密后的数据为SSA，其中包含密钥KTOTP，运行TOTP算法利用KTOTP和当前的时间戳就可以得到OTP。</p><p>（4）GenOTP的性能</p><p><img src="/2020/06/20/Sanctuary-NDSS2019/10.png" alt="img"></p><p>不适用L2 cache的运行时间是使用的1.3倍。通过该实验证明，即使在没有L2参与的情况下，SANCTUARY使用一个normal world和secure world组件所需要的时间是不会影响用户体验的，而且在这个过程中，普通的应用程序也可以继续</p><p>思考：</p><p>SANCTUARY instances 被tear down后，SA何去何从？</p><h2 id="8-相关工作"><a href="#8-相关工作" class="headerlink" title="8 相关工作"></a>8 相关工作</h2><p> Secure Software Architecture</p><p>Disadvantage of providing isolation using virtualization: i)their TCB contains a relatively large hypervisor, ii)they block usaga of virtualization for non-security purposes, ii)they require additional hardware to protect  against DMA attacks, iv)they negatively inflence the performance of the OS.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是对&lt;strong&gt;SANTUARY:ARMing TrustZone with User-space Enclaves&lt;/strong&gt;这篇论文的阅读笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="ARM" scheme="http://yoursite.com/categories/ARM/"/>
    
    
      <category term="TrustZone" scheme="http://yoursite.com/tags/TrustZone/"/>
    
      <category term="paper" scheme="http://yoursite.com/tags/paper/"/>
    
      <category term="ARM" scheme="http://yoursite.com/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>ARM基础知识</title>
    <link href="http://yoursite.com/2020/06/20/ARM%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/06/20/ARM基本知识/</id>
    <published>2020-06-20T10:23:34.000Z</published>
    <updated>2020-06-20T13:22:36.013Z</updated>
    
    <content type="html"><![CDATA[<p>本笔记借鉴的主要是ARMv7的相关的介绍，目前的v8和v7在各方面有着一定的差异。</p><a id="more"></a><h1 id="ARM基本知识"><a href="#ARM基本知识" class="headerlink" title="ARM基本知识"></a>ARM基本知识</h1><h3 id="处理器模式"><a href="#处理器模式" class="headerlink" title="处理器模式"></a>处理器模式</h3><p>ARM处理器有7种CPU mode，其中6种特权模式：FIQ，IRQ，Supervisor（SVC），Abort（ABT），Undefined（UND），System（SYS）以及一种非特权模式：User（USR）。在引入TrustZone后，新增了一种monitor（MON） mode。</p><h3 id="FIQ和IRQ的区别"><a href="#FIQ和IRQ的区别" class="headerlink" title="FIQ和IRQ的区别"></a>FIQ和IRQ的区别</h3><ol><li>FIQ模式提供了更多的banked寄存器，r8到r16还有SPSR；而IRQ模式下，r8到r12没有对应的banked寄存器，也就意味着ARM的IRQ模式下，中断处理程序要自己保存这几个寄存器，退出中断处理程序时还要恢复这几个寄存器。而FIQ模式因为有这几个banked寄存器，模式切换时CPU自动保存这些值到banked寄存器，退出FIQ时自动恢复，节省了时间。</li><li>FIQ比IRQ优先级高，两者如果同时产生，FIQ先处理。</li><li>当CPU位于FIQ模式处理FIQ中断时，所有的中断都被屏蔽，FIQ会被很快执行。但当CPU位于IRQ模式处理IRQ中断时，如果此时有FIQ中断时，正在执行的IRQ中断会被抢断，CPU会切换到IFIQ模式去执行这个FIQ中断。</li><li>FIQ的入口地址是0x1c，IRQ的入口地址是0x18.0x18处只能放一条指令，为了不与0x1c处的FIQ冲突，这个位置只能跳转；而0x1c处之后没有任何中断向量表了，这样可以直接在1c处防止FIQ的中断处理程序，由于跳转的范围限制，至少少了一条跳转指令。（这条其实不是很理解）</li></ol><h3 id="ARM中断"><a href="#ARM中断" class="headerlink" title="ARM中断"></a>ARM中断</h3><p>通过特定指令触发的软件中断，引起CPU执行流程的改变，在ARMv7中有三个：SVC，SMC和HVC。</p><ul><li>SVC（supervisor call instruction)：通常在用户进程切换到内核进程中使用，比如syscall会让CPU进入到SVC mode；</li><li>HVC（Hypervisor call instruction）：为ARM虚拟化技术的扩展指令，触发CPU进入HYP mode；</li><li>而SMC（Secure Monitor Call）会触发CPU进入monitor mode。</li></ul><h2 id="ARM寄存器"><a href="#ARM寄存器" class="headerlink" title="ARM寄存器"></a>ARM寄存器</h2><p>关于arm的banked register的概念，翻译成中文的意思是影子寄存器。ARM有16个通用寄存器，这16个通用寄存器用4个bit来表示。但<strong>在不同的模式下，同样的4bit可能会指向不同的物理寄存器，这些物理寄存器就被称之为影子寄存器。</strong></p><p>不考虑TrustZone时，ARM中通用寄存器的数目：</p><ul><li>1个状态寄存器CPSR（Current Program Status Register，当前程序状态寄存器）（也就是R16）</li><li>5个异常模式下的状态寄存器的banked register（IRQ，FIQ，Abort，UND，SVC）</li><li>16个通用寄存器R0~R15</li><li>10个异常模式下的R13和R14的banked register</li><li>5个FIQ模式下的R8~R12的banked register</li></ul><p>CPSR可以在任何模式下被访问，每一种模式下的banked register是它专门的物理状态寄存器，称为SPSR（Saved Program Status Register，备份的程序状态寄存器），当异常发生时，SPSR用于保存CPSR的当前值，从异常退出时则由SPSR来恢复CPSR。</p><p>寄存器R13一般被用作堆栈指针SP。而处理器的每种运行模式都有自己独立的物理寄存器R13，在用户应用程序的初始化部分，一般都要初始化每种模式下的R13，使其指向该运行模式的栈空间。当程序运行进入异常模式时，将需要保护的寄存器放入R13所指向的堆栈，而当程序从异常模式返回时，则从对应的堆栈中恢复，采用这种方式从而保证异常发生后程序的正常执行。</p><p>R14是子程序链接寄存器LR（Link Register），当执行子程序调用指令（BL）时，R14可得到R15的备份。</p><p>常用的banked registers如下图所示。HYP模式是ARM为虚拟化扩展引入的Hypervisor mode，与TrustZone无关。</p><p><img src="/2020/06/20/ARM基本知识/1.jpg" alt="img"></p><p>另一类寄存器为CP15协处理器，主要用于系统配置，比如配置异常向量表、开关MMU等。一般在OS初始化时，首先会配置这些寄存器。与security extension相关的两个重要寄存器是SCR和MVBAR。</p><h3 id="SCR表格"><a href="#SCR表格" class="headerlink" title="SCR表格"></a>SCR表格</h3><table><thead><tr><th>Bits</th><th>Name</th><th>Function</th></tr></thead><tbody><tr><td>[0]</td><td>NS bit</td><td>0：secure；1：non-secure</td></tr><tr><td>[1]</td><td>IRQ</td><td>0：IRQ异常触发CPU进入IRQ mode；<br>1：IRQ异常触发进入monitor mode</td></tr><tr><td>[2]</td><td>FIQ</td><td>0：FIQ异常触发CPU进入FIQ mode；<br>1：IRQ异常触发进入monitor mode</td></tr><tr><td>[3]</td><td>EA</td><td>0：external abort异常触发CPU进入ABT mode； <br>1：external abort异常触发CPU进入monitor mode</td></tr><tr><td>[4]</td><td>FW</td><td>0：non-secure mode下CPSR的F bit不可写；<br>1：non-secure mode下CPSR的F bit可写</td></tr><tr><td>[5]</td><td>AW</td><td>0：non-secure mode下CPSR的A bit不可写；<br>1：non-secure mode下CPSR的A bit可写</td></tr><tr><td>[6:31]</td><td>reserved</td><td>-</td></tr></tbody></table><h3 id="MVBAR"><a href="#MVBAR" class="headerlink" title="MVBAR"></a>MVBAR</h3><table><thead><tr><th>Bits</th><th>Name</th><th>Function</th></tr></thead><tbody><tr><td>[5:31]</td><td>Monitor Vector Base Address</td><td>Monitor mode异常向量表的基地址</td></tr><tr><td>[0:4]</td><td>Reserved</td><td>-</td></tr></tbody></table><p>SCR和MVBAR都只能在secure state下才能修改。</p><h3 id="CPU状态"><a href="#CPU状态" class="headerlink" title="CPU状态"></a>CPU状态</h3><p>引入banked register的目的是，在当中断或者异常产生的时候，CPU会将当前“CPU的状态”保存在banked register中。从CPU角度来看，它的“状态”包括：</p><ol><li>PC（也就是R15）值；</li><li>CPSR的值</li></ol><p>当中断或异常发生的时候，CPU只是：</p><ol><li>被保存在当前模式下的R14中的PC值；</li><li>被保存在当前模式下的banked register中的CPSR值</li></ol><p>而通用寄存器R0中的是应用的状态，保存应用的状态是相对比较昂贵的，因为要保存至少13个寄存器（R0-12）。</p><h2 id="ARM-Cortex-A、R、M系列"><a href="#ARM-Cortex-A、R、M系列" class="headerlink" title="ARM Cortex-A、R、M系列"></a>ARM Cortex-A、R、M系列</h2><p>ARM Cortex-A(Application)：适用于应用领域，支持ARM和Thumb指令集，并支持虚拟地址和内存管理。</p><p>ARM Cortex-R(Realtime)：适用于高实时性领域，支持ARM和Thumb指令集，只支持物理地址，并支持内存管理</p><p>ARM Cortex-M(MicroController)：适用于微处理器领域，只支持Thumb指令集</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/locean/p/4945057.html" target="_blank" rel="noopener">ARM之FIQ（快速中断）IRQ（中断）</a></li><li><a href="https://www.jianshu.com/p/d786a65bbdc9" target="_blank" rel="noopener">ARM Trustzone技术（三）ARMv7-A Exceptions&amp;Interrupts Handling的安全扩展</a></li><li><a href="https://blog.csdn.net/qq405180763/article/details/39203037" target="_blank" rel="noopener">ARM寄存器（R13/R14/R15)</a></li><li><a href="[https://baike.baidu.com/item/%E5%BD%B1%E5%AD%90%E5%AF%84%E5%AD%98%E5%99%A8/6435933](https://baike.baidu.com/item/影子寄存器/6435933)">影子寄存器</a></li><li><a href="https://www.jianshu.com/p/ee41a4544874" target="_blank" rel="noopener">ARM Trustzone技术（二）ARMv7-A Processor mode&amp;registers的安全扩展</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本笔记借鉴的主要是ARMv7的相关的介绍，目前的v8和v7在各方面有着一定的差异。&lt;/p&gt;
    
    </summary>
    
      <category term="ARM" scheme="http://yoursite.com/categories/ARM/"/>
    
    
      <category term="ARM" scheme="http://yoursite.com/tags/ARM/"/>
    
      <category term="汇编" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>TrustZone介绍</title>
    <link href="http://yoursite.com/2020/06/20/TrustZone%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://yoursite.com/2020/06/20/TrustZone笔记-1/</id>
    <published>2020-06-20T10:23:34.000Z</published>
    <updated>2020-06-20T13:18:17.654Z</updated>
    
    <content type="html"><![CDATA[<p>本篇基于一些是对TrustZone的介绍，同样基于ARMv7.</p><a id="more"></a><h1 id="TrustZone"><a href="#TrustZone" class="headerlink" title="TrustZone"></a>TrustZone</h1><p>TPM（Trusted Platform Module）加解密的动作在芯片中进行，将信息存储在芯片中。但TPM无法给予运行时攻击。攻击者可能会在运行时进行破解，直接在内存中读取解密过的东西。</p><p><img src="/2020/06/20/TrustZone笔记-1/0.jpg" alt="img"></p><p>而TrustZone仅相信trust app，也就是由他保护的硬件，只有trust app才能够访问。这样，即使攻击者获得了操作系统的权限，也无法访问到敏感数据。这就是常说的“支持TrustZone技术的芯片能够提供对外围硬件资源的硬件级别的保护和安全隔离”。</p><p>TrustZone 是ARM公司未来解决可能遇到的软硬件问题提出来的一种硬件解决方案。关键思想在于<strong>隔离</strong>。</p><h2 id="TrustZone构成"><a href="#TrustZone构成" class="headerlink" title="TrustZone构成"></a>TrustZone构成</h2><p>该技术将CPU的工作装填分成了正常世界状态（Normal World Status，NWS）和安全世界状态（Secure World Status，SWS）。</p><p>设备启动之后CPU运行在普通世界，执行的是普通世界的APP。当触发了SMC系统调用进入安全世界后，CPU就跑在安全世界，运行安全世界的APP。此时，普通世界的APP是无法访问到安全APP所用的资源，包括内存、缓存、touch、display等，攻击者也无法获取到信息。</p><p><img src="/2020/06/20/TrustZone笔记-1/1.jpg" alt="img"></p><p>可选部分是看SOC是否支持保护外设功能。</p><p>软件部分所要完成的核心工作就是基于第二点可虚拟化内核，使用SMC调用，使CPU进行安全世界，从而跑安全世界的APP。内核虚拟化是指通过CPU虚拟化出两个内核，并且把安全世界的OS运行在内核0中，普通世界的OS运行在内核1中。两个OS独立运行在不同的虚拟内核中，通过时间片进行两个内核见切换执行。</p><p>TrustZone的硬件架构主要体现在内核虚拟化、内存隔离、外设/总线隔离技术和中断隔离技术。</p><h2 id="外设-总线隔离技术"><a href="#外设-总线隔离技术" class="headerlink" title="外设/总线隔离技术"></a>外设/总线隔离技术</h2><h3 id="AXI总线"><a href="#AXI总线" class="headerlink" title="AXI总线"></a>AXI总线</h3><p>AXI总线上每个读写信道都增加了一个额外的控制信号</p><ul><li>AWPROT[1]：总线写事务控制信号——低电平为安全写事务，高电平为非安全写事务</li><li>ARPROT[1]：总线读事务控制信号——低电平为安全读事务，高电平为非安全读事务</li></ul><p>当设备向总线提出读写事务请求时必须将控制信号发送到总线上。总线根据这个信号和CPU当前所处于的世界来判断是否能够读写。</p><h3 id="外设如何隔离？"><a href="#外设如何隔离？" class="headerlink" title="外设如何隔离？"></a>外设如何隔离？</h3><p>外设是与APB相连的，但APB总线没有诸如AXI总线上的相关安全控制信号，所以这里引入了APB-to-AXI桥，外设还是与APB总线连接，而APB-to-AXI桥上的TZPCDECPORT信号决定配置外设是否安全。该桥保证非安全世界无法访问外设。</p><p>TZPCDECPORT输入信号可以在SoC设计时静态地设置，也可以通过TrustZone保护控制器（TrustZone Protection Controller，TZPC）进行编程，在程序运行时动态地设置，也就是可以通过TZPC动态配置地外设是安全或者是非安全的。</p><h2 id="内存隔离技术"><a href="#内存隔离技术" class="headerlink" title="内存隔离技术"></a>内存隔离技术</h2><h3 id="RAM，ROM如何隔离？"><a href="#RAM，ROM如何隔离？" class="headerlink" title="RAM，ROM如何隔离？"></a>RAM，ROM如何隔离？</h3><p>CPU core MMU 的安全隔离主要针对的是CPU内存空间的安全访问控制，TrustZone通过地址空间控制器（TrustZone Address Space Controller，TZASC）和存储适配器（TrustZone Memory Adaptor，TZMA）来保障物理内存（DRAM）的安全。针对on-SoC的静态内存（ROM和SRAM）的区域划分，通过使用TZMA来完成。</p><p><img src="/2020/06/20/TrustZone笔记-1/2.jpg" alt="img"></p><p>TZASC可以把内存地址空间划分为一系列的内存空间，对两个世界的APP分别配置（通过新增一条地址线表示NS位），运行在安全世界的被配置为安全的，并防止非安全事务访问安全内存空间。另外，TZASC将设备分区为几个安全设备，防止非安全事务访问安全设备。（<em>TZASC只能用来支持存储映射设备，不能用于块设备？</em>）</p><p>cache和内存为了支持TrustZone的安全策略，也做了相应的扩展。cache的tag增加了NS位，用于标识这一行的安全状态。低电平标识安全状态，而高电平标识处于非安全状态。内存管理单元（memory management unit，MMU）的tag增加了NSTID位，功能与NS一样。</p><p>TZC400接在SRAM上用于保护SRAM内存，可接在DDRC上用于保护DDR内存。保护内存，将内存划分成16个region，每个Master都有一个nsaid标识。设置每个region对nsaid的访问权限，也可以设置每个region的secure/non-secure权限。访问的控制流程：如果PE是以secure发起的访问，则直接检查该region的secure权限；如果是以non-secure发起的访问，则先检查的non-secure权限，再检查该region的nsaid权限。</p><h2 id="中断隔离技术"><a href="#中断隔离技术" class="headerlink" title="中断隔离技术"></a>中断隔离技术</h2><h3 id="如何进入安全世界"><a href="#如何进入安全世界" class="headerlink" title="如何进入安全世界"></a>如何进入安全世界</h3><p><img src="/2020/06/20/TrustZone笔记-1/3.jpg" alt="img"></p><p><img src="/2020/06/20/TrustZone笔记-1/4.jpg" alt="img"></p><p>上面两张图显示了如何在两个世界中进行切换，这里引入了特殊机制——监控模式（MON），负责不同执行环境的切换。</p><ol><li>普通世界的APP通过syscall svc指令进入kernel space OS（SVC mode）；</li><li>kernel space OS通过smc指令进入monitor mode；</li><li>运行在monitor mode的代码首先保存non-secure状态的CPU contexts（上下文），比如说lr，sp，spsr等等，然后将CPU NS位置为0，表示进入secure status，通过rfe（return from exception）进入secure OS；</li><li>secure OS唤醒secure APP处理完相应的安全资源访问请求后，发送smc指令，再次回到monitor mode；</li><li>运行在monitor mode下的代码同样首先保存secure状态的CPU contexts，然后将CPU NS位置为1，表示进入non-secure status，并恢复non-secure状态下的CPU contexts，通过rfe指令重新回到non-secure OS。</li></ol><p>除了软件调用SMC，上图1中的”2步骤“显示了也可以通过配置硬件中断触发进入monitor模式，比如FIQ，IRQ，external data abort，external prefetch abort，都可以通过配置系统寄存器来决定哪些硬件中断可以触发CPU陷入monitor mode。</p><p><strong>ARM处理器是如何知道当前处于什么状态的？</strong></p><p>支持TrustZone的ARM处理器的协处理器CP15有个安全配置寄存器（Secure Configuration Register，SCR），该寄存器的NS位用于指明当前的系统状态。NS为低电平时，处于安全状态；否则，就处于非安全状态。</p><p>从上面的图中可以看出来，系统的安全状态与系统的应用模式和特权模式无关。两个世界都有用户模式和特权模式，但在不同模式下所具有的权限是不一样的，NS位只能被运行在处于特权模式的安全世界中的APP改变，系统在非安全状态下不能访问SCR。 而当系统位于monitor模式下，不管NS是0还是1，都可以访问所有安全世界的资源。</p><p><strong>如何进入monitor模式？</strong></p><p><img src="/2020/06/20/TrustZone笔记-1/5.jpg" alt="img"></p><p>进入monitor模式有以下三个方法：</p><ul><li>SMC是一个特殊指令，类似于软件中断指令（software interrupt，SWI），由此进入monitor模式；</li><li>外部中止预取指令外部中止和数据中止，外部中止是访问存储系统时发生，但不被MMU所检测到异常，通常发生在普通世界访问安全世界资源时发生；</li><li>中断，包括FIQ（Fast Interrupt Request，快速中断请求），IRQ（Interrupt Request，中断请求）（FIQ是安全世界的中断源，IRQ是普通世界的中断源）</li></ul><p>第一类进入monitor模式是无条件的，而后两种则依赖于SCR的配置。</p><ul><li>针对第二类，EA=0时，表示外部中止时处理器进入中止模式；EA=1时，表示外部中止时处理器进入monitor模式</li><li>针对第三类（IRQ），IRQ=0时，表示发生IRQ时处理器进入中止模式；IRQ=1时，表示发生IRQ时处理器进入monitor模式</li><li>针对第三类（FIQ），FIQ=0时，表示发生FIQ时处理器进入中止模式；FIQ=1时，表示发生FIQ时处理器进入monitor模式</li></ul><p><strong>如何从安全世界返回普通世界？</strong></p><p>也要从monitor模式切换回来（应该是上述流程图的反向）。</p><p>运行在安全世界的软件有权改变SCR的NS位，但不建议这么做，因为一旦NS位被置为1，系统就会立马切换到non-secure状态，此时pipline中缓存的secure state下运行的指令、data register中保存的secure data都会变成non-secure，这样会使得非安全世界看到流水线的指令以及正在寄存器中的数据的可能。通常只有monitor可能直接修改主SCR的NS位。</p><p><strong>TrustZone的中断控制器</strong></p><p>在ARM传统的向量中断控制器（VIC）基础上，还添加了TrustZone中断控制器（TZIC）。TZIC和VIC通过菊花链的方式连接组成两级中断控制系统，从而做到普通中断和安全中断的隔离，安全中断无法被普通世界截获。TZIC是第一级中断控制器，所有中断源的中断请求都连在TZIC上，最先截获设备的中断请求，通过对TZIC的TZICIntSelect寄存器进行编程，可以对中断源产生的中断类型进行设置。这儿举个例子，如果TZICIntSelect中的某一位为1，相应的中断源请求被配置为FIQ中断，如果为0，则该中断源的中断请求就被交给VIC来处理。</p><p>TZICIntSelect寄存器复位值为0，也就是默认所有中断都交给VIC处理。这样，对于不支持TrustZone的软件系统来说，可以把TZIC看作是全透明的。</p><p>下图中，中断1和2在TZICIntSelect中都设置为1，所以直接交给了TZIC处理；</p><p>中断3在TZICIntSelect设置为0，交给VIC处理；</p><p>中断4在TZICIntSelect中设置为0，交给VIC处理，但在VICIntSelect中也设置为0，又交还给了TZIC。</p><p>也就是中断1,2,4都属于FIQ，而中断3属于IRQ。</p><p><img src="/2020/06/20/TrustZone笔记-1/5.jpg" alt="img"></p><p><strong>TrustZone的异常向量表</strong></p><p>异常向量表的作用就是告诉CPU在不同的异常发生后，入口函数分别在哪里。</p><p>支持TrustZone的ARM处理器有三个异常向量表：普通世界的异常向量表，安全世界的异常向量表和monitor的异常向量表。</p><p>配置Vector table除了需要指定各个exception handler的入口函数以外，最重要的是指定vector table的地址，这样CPU才能计算出各个入口函数的地址。系统开机时，安全世界的异常向量表基地址是0x00000000（normal vectors）或0xffff0000（high vectors），取决于处理器输入信号VINTHI（cp15寄存器SCTLR的V bit），其他两个向量表的基地址开机时未定义，使用前必须软件设置。</p><p>与以往的ARM处理器不同的是，每个异常向量表的位置在运行时可以动态移动，将新的向量表基地址写入CP15的VBAR寄存器即可，monitor的向量表基地址由monitor的异常向量表基地址寄存器指定。</p><p>另外，普通世界与安全世界的向量表基地址除了与VBAR有关，还与处理器的V位有段，v=1，则向量表基地址采用高地址，而与VBAR无关。普通世界和安全世界的V位是独立的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/hovan/article/details/42520879" target="_blank" rel="noopener">trust zone之我见</a></li><li><a href="https://zhuanlan.zhihu.com/p/88629648" target="_blank" rel="noopener">浅析ARM TrustZone与Intel SGX</a></li><li><a href="https://www.jianshu.com/p/3f952f2c8bf4" target="_blank" rel="noopener">ARM Trustzone技术（一）综述</a></li><li><a href="https://paper.seebug.org/296/" target="_blank" rel="noopener">TrustZone安全技术研究</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇基于一些是对TrustZone的介绍，同样基于ARMv7.&lt;/p&gt;
    
    </summary>
    
      <category term="ARM" scheme="http://yoursite.com/categories/ARM/"/>
    
    
      <category term="TrustZone" scheme="http://yoursite.com/tags/TrustZone/"/>
    
      <category term="ARM" scheme="http://yoursite.com/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>python hahslib</title>
    <link href="http://yoursite.com/2020/04/19/python%E4%BD%BF%E7%94%A8hahslib/"/>
    <id>http://yoursite.com/2020/04/19/python使用hahslib/</id>
    <published>2020-04-19T06:23:34.000Z</published>
    <updated>2020-06-20T10:14:38.483Z</updated>
    
    <content type="html"><![CDATA[<p>在python环境中调用AES-GCM库</p><a id="more"></a><p>毕设中需要一个文件加密的步骤，本来是打算随便找个库来加密解密就好了，但是导师建议使用AES-GCM，阅读了有关文献，GCM模式能够进行身份验证，相对来说比较推荐。</p><p>开始考虑的还是希望直接调用已有的库比如openssl，就比较方便嘛，但是openssl不支持对AES-GCM模式的命令行调用。但是openssl中是有GCM的头文件的，但是C处理文件实在太麻烦了。。所以还是选择了python吧。</p><p>python中有个库cryptemis是可以对图片文件进行AES加密处理的，但是看代码用的模式是AES-CFB。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aes_cipher = AES.new(key, AES.MODE_CFB, iv)</span><br></pre></td></tr></table></figure><p>git clone下来之后把mode改成了GCM也得到了预期的效果。但是在两个容器中配置的过程比较繁琐，这里记录一下。</p><p>python3中AES相关的库是pycryptodome，python2中是pycryptodom。<br>这里调用了hashlib库是为了获得相对来说更乱序的iv值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key = hl.sha3_512(hl.sha1(password.encode()).hexdigest().encode()).hexdigest()[:AES.block_size].encode()</span><br><span class="line">iv = hl.sha3_512(hl.blake2s(password.encode()).hexdigest().encode()).hexdigest()[:AES.block_size].encode()</span><br></pre></td></tr></table></figure><p>直接测试的时候发现出现了下述错误</p><blockquote><p>AttributeError: module ‘hashlib’ has no attribute ‘blake2b’</p></blockquote><p>直接百度或者google的时候都说是自己的文件名与导入的报名撞了，但这里并没有呀。而且在我电脑上的环境上跑的很顺畅。hashlib是python内建模块，它的版本与python挂钩，我windows上的python是3.7，而服务器中的是2.7，大概率是版本问题。通过dir(hashlib)查看了一下，确实没有相应的函数，那么接下来就是升级python了。hashlib的官方文档中说3.6中升级有了blake2b，也就是说只需要升级到3.6及以上即可。</p><p>安装python3.7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install python3.7</span><br><span class="line">python3.7 –version</span><br></pre></td></tr></table></figure><p>将python3的链接指向python3.7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /usr/bin/python3</span><br><span class="line">sudo rm -rf /usr/bin/pip3</span><br></pre></td></tr></table></figure><p>添加python3的软链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/python3.7 /usr/bin/python3</span><br></pre></td></tr></table></figure><p>安装pip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">python3 get-pip.py   //运行安装脚本</span><br></pre></td></tr></table></figure><p>添加pip3的软链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/pip3.7 /usr/bin/pip3</span><br></pre></td></tr></table></figure><p>然后就可以依次安装numpy包、pillow包、pycryptodome包。</p><p>参考文献</p><ul><li><a href="https://kb.kutu66.com/encryption/post_131657" target="_blank" rel="noopener">encryption-如何选择AES加密模式</a></li><li><a href="https://github.com/0x01h/cryptemis" target="_blank" rel="noopener">cryptemis</a></li><li><a href="https://www.digitalocean.com/community/questions/unable-to-install-pyhton-3-7-version-on-ubuntu-16-04-error-couldn-t-find-any-package-by-regex-python3-7" target="_blank" rel="noopener">下载python3.7</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在python环境中调用AES-GCM库&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>NVDLA学习</title>
    <link href="http://yoursite.com/2019/12/29/NVDLA%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/12/29/NVDLA学习/</id>
    <published>2019-12-29T14:17:15.000Z</published>
    <updated>2020-04-19T07:56:32.326Z</updated>
    
    <content type="html"><![CDATA[<p>毕设要用NVDLA，在这里记录一下NVDLA的安装过程和学习。</p><a id="more"></a><h1 id="NVDLA-Virtual-Simulator"><a href="#NVDLA-Virtual-Simulator" class="headerlink" title="NVDLA Virtual Simulator"></a>NVDLA Virtual Simulator</h1><p>NVDLA的安装文档写的很详细，但已经是2017年写的，很长时间没更新，而且对很多工具的版本要求都很emm怀旧，安装的时候还是遇到几个问题。NVDLA也可以直接运用docker版本的，但直接用原代码编译能加强对NVDLA整体的理解嘛（虽然我编译完根本不知道发生了啥:(）</p><p>NVDLA Open Source Project中主要有四个文件夹。</p><ul><li><p>doc<br>Docunmentation for NVDLA</p></li><li><p>hw<br>RTL, Cmodel and testbench for NVDLA</p></li><li><p>sw<br>NVDLA SW</p></li><li><p>vp<br>Virtual Platform for NVDLA</p></li></ul><h2 id="下载Virtual-Simulator"><a href="#下载Virtual-Simulator" class="headerlink" title="下载Virtual Simulator"></a>下载Virtual Simulator</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nvdla/vp.git  </span><br><span class="line">cd vp  </span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><h3 id="install-required-tools-and-libraries"><a href="#install-required-tools-and-libraries" class="headerlink" title="install required tools and libraries"></a>install required tools and libraries</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install g++ cmake libboost-dev python-dev libglib2.0-dev libpixman-1-dev liblua5.2-dev swig libcap-dev libattr1-dev</span><br></pre></td></tr></table></figure><h3 id="install-SystemC-2-3-0"><a href="#install-SystemC-2-3-0" class="headerlink" title="install SystemC 2.3.0"></a>install SystemC 2.3.0</h3><p>这里需要注意的是必须用的systemC 2.3.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget -O systemc-2.3.0a.tar.gz http://www.accellera.org/images/downloads/standards/systemc/systemc-2.3.0a.tar.gz</span><br><span class="line">tar -xzvf systemc-2.3.0a.tar.gz</span><br><span class="line">cd systemc-2.3.0a</span><br><span class="line">sudo mkdir -p /usr/local/systemc-2.3.0/</span><br><span class="line">mkdir objdir</span><br><span class="line">cd objdir</span><br><span class="line">../configure --prefix=/usr/local/systemc-2.3.0</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="install-perl-package-required"><a href="#install-perl-package-required" class="headerlink" title="install perl package required"></a>install perl package required</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wget -O YAML-1.24.tar.gz http://search.cpan.org/CPAN/authors/id/T/TI/TINITA/YAML-1.24.tar.gz</span><br><span class="line">tar -xzvf YAML-1.24.tar.gz</span><br><span class="line">cd YAML-1.24</span><br><span class="line">perl Makefile.PL</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">wget -O IO-Tee-0.65.tar.gz http://search.cpan.org/CPAN/authors/id/N/NE/NEILB/IO-Tee-0.65.tar.gz</span><br><span class="line">tar -xzvf IO-Tee-0.65.tar.gz</span><br><span class="line">cd IO-Tee-0.65</span><br><span class="line">perl Makefile.PL</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="install-NVDLA-CMOD"><a href="#install-NVDLA-CMOD" class="headerlink" title="install NVDLA CMOD"></a>install NVDLA CMOD</h3><p>CMOD安装需要保证环境配置得当，我的环境配置版本与readme中略有不同。</p><ul><li>java -jdk1.8</li><li>Perl</li><li>CPP</li><li>python</li><li>System -systemc-2.3.0</li><li>[for Verilator builds] Verilator-Verilator</li><li>[for Verilator builds] clang-clang </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nvdla/hw.git</span><br><span class="line">cd hw</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>这一步执行完毕后需要按照提示输入对应的工具路径，这里我的工具路径如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_CPP:=/usr/bin/cpp</span><br><span class="line">DEFAULT_GCC:=/usr/bin/g++</span><br><span class="line">DEFAULT_PERL:=/usr/bin/perl</span><br><span class="line">DEFAULT_JAVA:=/usr/bin/java</span><br><span class="line">DEFAULT_SYSTEMC:=~/systemc-2.3.0</span><br><span class="line">DEFAULT_VERILATOR:=verilator</span><br><span class="line">DEFAULT_CLANG:=clang</span><br><span class="line">DEFAULT_PROJ:=nv_small</span><br></pre></td></tr></table></figure><p>make执行完毕后再输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tools/bin/tmake -build cmod_top</span><br></pre></td></tr></table></figure><h2 id="Build-and-Install-the-Virtual-Simulator"><a href="#Build-and-Install-the-Virtual-Simulator" class="headerlink" title="Build and Install the Virtual Simulator"></a>Build and Install the Virtual Simulator</h2><h3 id="Cmake-build-under-the-vp-repository-directory"><a href="#Cmake-build-under-the-vp-repository-directory" class="headerlink" title="Cmake build under the vp repository directory"></a>Cmake build under the vp repository directory</h3><p>build/是希望安装virtual simulator的位置，/usr/local/systemC是SystemC的安装目录，~/hw是本地NVDLA HW仓库的位置，nv_small是NVDLA HW project name.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=build/ -DSYSTEMC_PREFIX=~/usr/local/systemc-2.3.0/ -DNVDLA_HW_PREFIX=~/hw -DNVDLA_HW_PROJECT=nv_small</span><br></pre></td></tr></table></figure><h3 id="Compile-and-install"><a href="#Compile-and-install" class="headerlink" title="Compile and install"></a>Compile and install</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd vp/</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>编译vp中遇到了很多问题，里面直接导致无法运行的是这个</p><blockquote><p>/usr/local/systemc-2.3.0/include/sysc/packages/boost/get_pointer.hpp:21:40: error: ‘template<class> class std::auto_ptr’ is deprecated [-Werror=deprecated-declarations]<br> template<class t> T * get_pointer(std::auto_ptr<t> const&amp; p)</t></class></class></p></blockquote><p>产生的主要原因issue上的作者说是gcc版本应该用4.8的，后来在网上查到了不用修改gcc版本就可以成功编译的方法。<br><strong>修改vp/CMakeLists.txt</strong>(参考网址：<a href="https://blog.csdn.net/hywCogost/article/details/82114529" target="_blank" rel="noopener">https://blog.csdn.net/hywCogost/article/details/82114529</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 注释掉以下三行</span><br><span class="line"># set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -DSC_INCLUDE_DYNAMIC_PROCESSES -Wall -Werror $&#123;AWS_FPGA_CFLAGS&#125; $&#123;TRACE_CFLAGS&#125;&quot;)</span><br><span class="line"># set(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -DSC_INCLUDE_DYNAMIC_PROCESSES -Wall -Werror -DDEBUG_LOG=1 $&#123;AWS_FPGA_CFLAGS&#125; $&#123;TRACE_CFLAGS&#125;&quot;)</span><br><span class="line"># set(CMAKE_CXX_FLAGS_RELEASE &quot;$&#123;CMAKE_CXX_FLAGS_RELEASE&#125; -DSC_INCLUDE_DYNAMIC_PROCESSES -Wall -Werror $&#123;AWS_FPGA_CFLAGS&#125; $&#123;TRACE_CFLAGS&#125;&quot;)</span><br><span class="line"># 添加如下：</span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -DSC_INCLUDE_DYNAMIC_PROCESSES -Wall  $&#123;AWS_FPGA_CFLAGS&#125; $&#123;TRACE_CFLAGS&#125;&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -DSC_INCLUDE_DYNAMIC_PROCESSES -Wall  -DDEBUG_LOG=1 $&#123;AWS_FPGA_CFLAGS&#125; $&#123;TRACE_CFLAGS&#125;&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS_RELEASE &quot;$&#123;CMAKE_CXX_FLAGS_RELEASE&#125; -DSC_INCLUDE_DYNAMIC_PROCESSES -Wall  $&#123;AWS_FPGA_CFLAGS&#125; $&#123;TRACE_CFLAGS&#125;&quot;)</span><br></pre></td></tr></table></figure><p>也就是将这三条语句中的Werror去掉，同样的操作还要将子目录下CMakeList.txt中的CMake_CXX_FLAGS语句中国的-Werror删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./models/nvdla/CMakeLists.txt +87</span><br><span class="line">./models/nvdla/CMakeLists.txt +88</span><br><span class="line">./models/nvdla/CMakeLists.txt +89</span><br><span class="line"></span><br><span class="line">./fpga/aws-fpga/fpga_sc_wrapper/CMakeLists.txt +91</span><br><span class="line">./fpga/aws-fpga/fpga_sc_wrapper/CMakeLists.txt +92</span><br><span class="line">./fpga/aws-fpga/fpga_sc_wrapper/CMakeLists.txt +93</span><br><span class="line"></span><br><span class="line">./fpga/aws-fpga/cosim_sc_wrapper/CMakeLists.txt +82</span><br><span class="line">./fpga/aws-fpga/cosim_sc_wrapper/CMakeLists.txt +83</span><br><span class="line">./fpga/aws-fpga/cosim_sc_wrapper/CMakeLists.txt +84</span><br></pre></td></tr></table></figure><h2 id="Running-the-Virtual-Simulator"><a href="#Running-the-Virtual-Simulator" class="headerlink" title="Running the Virtual Simulator"></a>Running the Virtual Simulator</h2><p>要运行virtual simulator首先要准备好linux kernel image，可以自己手动编译或者直接用NVDLA项目中已经编译好的image。我因为开始的一个智障报错把两个都试了一遍。用NVDLA中已经编译好的image比较省事且快，但文档中说的不是很清楚，但在这个<a href="https://github.com/nvdla/vp/issues/1" target="_blank" rel="noopener">issue</a>解释清楚了。</p><p>我就简单说一下里面没有提到的部分，就是修改aarcha64_nvdla.lua中的kernel和driver的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-kernel /path/to/sw/prebuilt/arm64-linux/image/linux/Image</span><br><span class="line">-driver /path/to/sw/prebuilt/arm64-linux/image/linux/rootfs.ext4</span><br></pre></td></tr></table></figure><p>以下来简单说一下手动交叉编译一个linux内核的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://buildroot.org/downloads/buildroot-2017.11.tar.gz</span><br><span class="line">tar -zxvf buildroot-2017.11.tar.gz</span><br><span class="line">cd buildroot-2017.11/</span><br><span class="line">sudo apt-get install libncurses5-dev // make menuconfig时会用到</span><br><span class="line">make qemu_aarch64_virt_defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>需要自定义的配置如下：</p><blockquote><ul><li>Target Options -&gt; Target Architecture -&gt; AArch64 (little endian)  </li><li>Target Options -&gt; Target Architecture Variant -&gt; cortex-A57  </li><li>Toolchain -&gt; Custom kernel headers series -&gt; 4.13.x  </li><li>Toolchain -&gt; Toolchain type -&gt; External toolchain    </li><li>Toolchain -&gt; Toolchain -&gt; Linaro AArch64 2017.08  </li><li>Toolchain -&gt; Toolchain origin -&gt; Toolchain to be downloaded and installed  </li><li>Kernel -&gt; () Kernel version -&gt; 4.13.3  </li><li>Kernel -&gt; Kernel configuration -&gt; Use the architecture default configuration  </li><li>System configuration -&gt; Enable root login with password -&gt; Y  </li><li>System configuration -&gt; Root password -&gt; nvdla  </li><li>Target Packages -&gt; Show packages that are also provided by busybox -&gt; Y  </li><li>Target Packages -&gt; Networking applications -&gt; openssh -&gt; Y  </li></ul></blockquote><p>最后，编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure><h3 id="Running-Kernel-Image-in-the-Virtual-Simulator"><a href="#Running-Kernel-Image-in-the-Virtual-Simulator" class="headerlink" title="Running Kernel Image in the Virtual Simulator"></a>Running Kernel Image in the Virtual Simulator</h3><p>在运行之前，需要修改conf/aarch64_nvdla.lua中的路径信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-driver ~/vp/buildroot-2017.11/output/images/rootfs.ext4</span><br><span class="line">-kernel ~/vp/buildroor-2017.11/output/images/Images</span><br></pre></td></tr></table></figure><p>接下来，就可以运行文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> SC_SIGNAL_WRITE_CHECK=DISABLE</span><br><span class="line">./build/bin/aarch64_toplevel -c conf/aarch64_nvdla.lua</span><br></pre></td></tr></table></figure><p>然后我又遇到了这个问题</p><blockquote><p>Could not set up host forwarding rule ‘tcp::6666-:6666’</p></blockquote><p>针对这个问题，我直接把lua文件中的<code>tcp::6666-:6666</code>这段给删了，接下来运行未发生报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount -t 9p -o trans=virtio r /mnt</span><br><span class="line">cd /mnt/tests/hello</span><br><span class="line">./aarch64_hello</span><br></pre></td></tr></table></figure><p>运行成功，没有报错。</p><h1 id="NVDLA-documentation"><a href="#NVDLA-documentation" class="headerlink" title="NVDLA documentation"></a>NVDLA documentation</h1><p>NVDLA在accelerate deep learning 中起到的是inference的作用，也就是一个网络已经训练好了，需要做实际应用了。</p><h1 id="nvdla-vp模拟推断"><a href="#nvdla-vp模拟推断" class="headerlink" title="nvdla vp模拟推断"></a>nvdla vp模拟推断</h1><p>nvdla的文档真的太少了。。。官方文档给了就跟没给一样，开发过程完全靠issue上一起摸着石头过河的人的提问。。。这里还是要感谢导师和学长的帮助。</p><p>NVDLA在virtual platform上应该只能进行inference的操作，并且会很慢。nvdla_compiler是编译器，将caffe网络文件编译成NVDLA可读的nvdla文件，也就是最后生成的fast-math.nvdla。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nvdla_compiler --profile fast-math --configtarget nv_small --cprecision int8 --prototxt models/deep-residual-networks/prototxt/ResNet-50-deploy.prototxt --caffemodel ResNet-50-model.caffemodel --informat nchw --calibtable resnet50.json</span><br></pre></td></tr></table></figure><ul><li><p><code>--profile</code>：编译生成的nvdla的四种模式（performance|basic|default|fast-math），fast_math应该是占用资源最少的一种模式，fast-math的时候一共162层，但如果是default，一共有334层</p></li><li><p><code>--configtarget</code>：生成的文件的规模，可以选择的是nv_small,nv_large,nv_full,对应的分别是资源的多少，nv_small&lt;nv_large&lt;nv_full;</p></li><li><p><code>--cprecision</code>：精度，默认fp16，nv_small只支持int8，如果使用int8的话，需要加上calibtable参数（for quantizing pre-trained models from floating point to int8 and programming converters in NVDLA for scaling/re-scaling tensors）;</p></li><li><p><code>--prototxt</code>：prototxt文件是负责网络结构的定义,我这边的prototxt和caffemodel文件都来源于<a href="https://github.com/KaimingHe/deep-residual-networks" target="_blank" rel="noopener">何恺明的github</a></p></li><li><p><code>--caffemodel</code>：caffemodel文件存储net参数以及所有layer的weights.</p></li><li><p><code>--informat</code>：该参数的设置是为了消除一个错误警报，但是作者在github上面有说该error其实出现了也无所谓，建议无视</p></li><li><p><code>--calibtable</code>：调用resnet50.json文件，该文件是vp自带的，应该是精度转化的json文件，如果是测试int8就需要</p></li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nv_runtime  --loadable fast_math.nvdla --image boat.jpg  --rawdump --normalize 1</span><br></pre></td></tr></table></figure><p>runtime只能在aarch64架构下运行，所以在vp上会利用qemu先进入aarch64架构中，然后会安装nvdla driver，这里分别有opendla_1.ko和opendla_2.ko，opendla_1.ko是专门给nv_full的，opendla_2.ko供nv_small和nv_large使用。</p><ul><li><p><code>--image</code>：后面跟的要进行推断的图片文件</p></li><li><p><code>--normalize</code>：标准化输入的图片</p></li><li><p><code>--rawdump</code>：将输出结果从小数变成0、1</p></li></ul><p>我目前在软件上推断一次要两个小时，用的nv_full，用nv_small一直中间没有推断结束就断掉，貌似issue上有人有类似问题、、尴尬。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://nvdla.org/vp.html" target="_blank" rel="noopener">Virtual Platform</a></li><li><a href="https://blog.csdn.net/hywCogost/article/details/82114529" target="_blank" rel="noopener">Ubuntu16.04 NVDLA环境搭建</a></li><li><a href="https://blog.csdn.net/smiler_sun/article/details/89608320" target="_blank" rel="noopener">NVDLA virtual platform环境搭建</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毕设要用NVDLA，在这里记录一下NVDLA的安装过程和学习。&lt;/p&gt;
    
    </summary>
    
      <category term="NVDLA" scheme="http://yoursite.com/categories/NVDLA/"/>
    
    
      <category term="NVDLA" scheme="http://yoursite.com/tags/NVDLA/"/>
    
  </entry>
  
  <entry>
    <title>最近读的闲书20191222</title>
    <link href="http://yoursite.com/2019/12/22/%E6%9C%80%E8%BF%91%E8%AF%BB%E7%9A%84%E9%97%B2%E4%B9%A620191222/"/>
    <id>http://yoursite.com/2019/12/22/最近读的闲书20191222/</id>
    <published>2019-12-22T09:02:52.000Z</published>
    <updated>2019-12-22T09:50:24.987Z</updated>
    
    <content type="html"><![CDATA[<p>发现了“微信读书”这个宝藏APP，大部分的名家作品都能找得到www。这两周读了汪曾祺的散文集《宋朝人的吃喝》和张爱玲的《沉香屑第一炉香》和《小团圆》。随便写写读后感。</p><a id="more"></a><p>汪曾祺，张爱玲，木心是近现代我最喜欢的三个作家。汪曾祺的作品尤为适合心情闲散的时候读，有一种治愈的感觉。</p><h1 id="宋朝人的吃喝"><a href="#宋朝人的吃喝" class="headerlink" title="宋朝人的吃喝"></a>宋朝人的吃喝</h1><p>打算入手这本的实体书了，叫宋朝人的吃喝不过是里面有一章节的名字，谈写作，谈名人，谈食物的都有。谈写作的部分写的极好，适合广大高中生阅读。我很赞同汪老“随遇而安”的人生态度，有一说一，这样容易过的幸福。</p><p>前两天和同学聊天，他一段话说的极好。</p><blockquote><p>不过生活的本质，都是回归无聊和平淡的，哪怕结了婚也一样，所以还是得学会生活。</p></blockquote><p>汪老我觉得是个骨子里非常会生活的人，他这一生没有吃过多少苦，吃的那一点点苦，反而给平淡的生活加了点料，晚年回想起来有种甘之若饴的滋味。</p><h1 id="张爱玲小说集"><a href="#张爱玲小说集" class="headerlink" title="张爱玲小说集"></a>张爱玲小说集</h1><p>《沉香屑第一炉香》听说要拍了，选角是什么鬼(╯‵□′)╯︵┻━┻</p><p>原作本身是极有电影画面感的，电影配上这阵容，算了算了。</p><p>张爱玲本人其实就是一个很有意思的人，杨绛说她古怪、奇装异服、丑，我觉得有点偏颇。张爱玲自己也知道自己性格孤僻，不是个开朗活泼的人，所以朋友少，其实也很容易感到自卑。而在衣服上，张爱玲是个很注重生活情调的人，她不管是骨子里还是表现出来的，都是个完完全全的小资产阶级。而长相上，我觉得可以用当代话来说，是一种超模脸，冷淡有气质。</p><p>张爱玲的家境是让人羡慕的，祖上三代赫赫有名，但同时也是不幸。荣耀的像贾府一样的家庭在走到她这一代的时候已经是非常畸形的，而她也没有得到像贾宝玉那样的宠爱。父亲暴戾，母亲任性，上天赋予了她天才的一面，也给了她异于常人的敏感多思。敏感的人，往往是不容易感到幸福的。  </p><p>读小团圆，读到前面，她絮絮叨叨地说自己的家庭，谈的最多的是蕊秋，总说着对母亲的死心，足见她有多么爱自己的母亲。因为爱的浓烈，也最容易被伤害。蕊秋作为母亲，是极其不合格的，她从来没有想过如何做好一名母亲，孩子很小的时候，就离开他们去追求自己的幸福，寻求称为一名新时代的女性。回来了之后，也少有母女、母子的温存，吃饭的时候也只是教育批评。终其一生，不过是一个被宠坏了的富家小姐，从来就没有成长过。张爱玲和张子静生活在这样的家庭，着实是让人心疼的。</p><p>张爱玲一生自己活的清清楚楚明明白白，她不会表面一套背地一套，作品也总是就地取材，身边的人都是她的作品原型，她就是个天生的作家。</p><p>读张爱玲，有时候有种梦回高中的感觉，那时候读《金锁记》，有一种后背发凉的悲哀；读《天才梦》，被文笔惊艳到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现了“微信读书”这个宝藏APP，大部分的名家作品都能找得到www。这两周读了汪曾祺的散文集《宋朝人的吃喝》和张爱玲的《沉香屑第一炉香》和《小团圆》。随便写写读后感。&lt;/p&gt;
    
    </summary>
    
      <category term="读书杂谈" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>keystone-qemu手动安装测试</title>
    <link href="http://yoursite.com/2019/12/03/keystone-qemu%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/12/03/keystone-qemu手动安装测试/</id>
    <published>2019-12-03T06:16:06.000Z</published>
    <updated>2020-04-19T07:47:28.991Z</updated>
    
    <content type="html"><![CDATA[<p>还是docker装吧。（摊手</p><a id="more"></a><h1 id="Install-Dependencies"><a href="#Install-Dependencies" class="headerlink" title="Install Dependencies"></a>Install Dependencies</h1><p>在执行<code>sudo apt update</code>后执行<code>sudo apt install autoconf automake autotools-dev bc bison build-essential curl expat libexpat1-dev flex gawk gcc git gperf libgmp-dev libmpc-dev libmpfr-dev libtool texinfo tmux patchutils zlib1g-dev wget bzip2 patch vim-common lbzip2 python pkg-config libglib2.0-dev libpixman-1-dev libssl-dev screen device-tree-compiler expect makeself unzip cpio rsync</code><br>然后出现了如下问题</p><blockquote><p>Some packages could not be installed. This may mean that you have requested an impossible situation or if you are using the unstable distribution that some required packages have not yet been created or been moved out of Incoming.<br>The following information may help to resolve the situation:<br>The following packages have unmet dependencies:<br>gnupg : Breaks: software-properties-common (&lt;= 0.96.24.3) but 0.96.20.9 is to be installed<br>E: Error, pkgProblemResolver::Resolve generated breaks, this may be caused by held packages.</p></blockquote><p>用失败信息去google搜索，根据句askubuntu和stackflow中得到的信息，应该是因为Ubuntu版本号的原因。用<code>cat /etc/issue</code>命令查看当前Ubuntu版本，是18.04，继续查看更新源，也都是最新的阿里源。</p><p>根据<a href="https://askubuntu.com/questions/1108428/ubuntu-16-04-desktop-ui-is-broken-missing-features" target="_blank" rel="noopener">Ubuntu 16.04 desktop UI is broken/missing features</a>中一个老哥给出的<code>sudo apt dis-upgrade</code>的建议，运行该命令，成功更新，再安装依赖包，成功。</p><h1 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h1><p>本部分要完成三件事：(1)安装RISC-V toolchain；(2)检查git submodules；(3)安装SDK。</p><h2 id="同步并更新所有的子模块"><a href="#同步并更新所有的子模块" class="headerlink" title="同步并更新所有的子模块"></a>同步并更新所有的子模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule sync --recursive  </span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>在执行第一条命令的时候又出现了<code>dy_ms@test:~$ git submodule sync --recursivefatal: not a git repository (or any of the parent directories): .git</code>这样的错误，这是因为没有初始化git本地版本管理仓库，所以要执行<code>git init</code>，而后就可以顺利进行同步和更新。</p><h2 id="安装RISC-V-GNU-toolchain"><a href="#安装RISC-V-GNU-toolchain" class="headerlink" title="安装RISC-V GNU toolchain"></a>安装RISC-V GNU toolchain</h2><p>安装GNU toolchain我事先在虚拟机上尝试过，过程很漫长，结果很悲惨。我的虚拟机因为硬盘空间不够直接宕机了，然后重新装了虚拟机，现在都不敢在虚拟机上重新来一遍。T^T<br>当我看到服务器硬盘是1000G的时候，露出了满意的微笑，这时候再也没有什么能阻碍我的装机之旅了。然后在运行了以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/riscv/riscv-gnu-toolchain</span><br><span class="line">cd riscv-gnu-toolchain</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>然后出现了以下错误  </p><blockquote><p>error: RPC failed; curl 18 transfer closed with outstanding read data remaining<br>fatal: The remote end hung up unexpectedly<br>fatal: early EOF<br>fatal: index-pack failed<br>fatal: clone of ‘<a href="https://github.com/riscv/riscv-binutils-gdb.git&#39;" target="_blank" rel="noopener">https://github.com/riscv/riscv-binutils-gdb.git&#39;</a> into submodule path ‘/data/dy_ms/riscv-gnu-toolchain/riscv-binutils’ failed  </p></blockquote><p>google了相关问题，是因为网速太慢。(╯‵□′)╯︵┻━┻<br>本来我以为是实验室的网速慢，确实，实验室的网速也很慢。所以我昨天特地早早回家用家里的无线网连，还是10k每秒？？？今天跟学长老师交流了一下，是因为对面服务器的网速太慢了，晕了，这也太慢了。这个网速太坑了，我已经打算再试一下docker装了。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>然后我用docker了，docker大法好，躺平任嘲XD</p><h1 id="其他细节的知识点"><a href="#其他细节的知识点" class="headerlink" title="其他细节的知识点"></a>其他细节的知识点</h1><h2 id="ubuntu更新的区别与联系"><a href="#ubuntu更新的区别与联系" class="headerlink" title="ubuntu更新的区别与联系"></a>ubuntu更新的区别与联系</h2><p>update：是下载源里面的metadata，比如软件包的版本信息、系统要求、翻译、依赖项等等。apt get update是对软件包列表的更新过程，而upgrade是对软件包的更新过程。</p><p>upgrade: 系统将现有的package升级，如果有相依性的问题，而相依性需要安装其他新的package或影响到其他package的相依性时，此时package就不会被升级而会保留下来；<br>dist-upgrade：可以聪明地解决相依性的问题，如果有相依性问题，需要安装或移除新的package，就会尝试去安装或者移除它。</p><p>upgrade和disupgrade本质上没有什么不同，但dist-upgrade会识别出依赖关系改变的情况并作出处理，而upgrade对此情形不处理。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/wangyezi19930928/article/details/54928201" target="_blank" rel="noopener">apt-get update,upgrade和dist-upgrade的区别</a></li><li><a href="https://www.zhihu.com/question/20709809" target="_blank" rel="noopener">Linux ssh状态下如何后台运行程序</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还是docker装吧。（摊手&lt;/p&gt;
    
    </summary>
    
      <category term="keystone" scheme="http://yoursite.com/categories/keystone/"/>
    
    
      <category term="实验" scheme="http://yoursite.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="keystone" scheme="http://yoursite.com/tags/keystone/"/>
    
      <category term="qemu" scheme="http://yoursite.com/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>2019.11日记</title>
    <link href="http://yoursite.com/2019/11/26/2019-11%E6%97%A5%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/26/2019-11日记/</id>
    <published>2019-11-26T08:47:48.000Z</published>
    <updated>2019-12-22T09:03:55.942Z</updated>
    
    <content type="html"><![CDATA[<p>对这段时间的生活总结。</p><a id="more"></a><p>intel sgx explained的阅读笔记以及单词记录，看的论文笔记后期转到OneNote上写了。有一说一，OneNote除了字体非常非常非常丑以外，其他讲道理都还可以。  </p><p>blog上接下来我打算填暑假留下来的天坑：</p><ul><li>《深入理解计算机系统》的阅读笔记；</li><li>Git学习</li><li>linux内核学习</li></ul><p>还有背单词！！！好久没打卡百词斩了，虽然我从从前地看中文小说转成了看AO3上的英文小说，词汇量上去了一丢丢，但是我英语还是好菜啊QAQ。</p><p>今天认真想了一下，感觉如果老师不布置任务，学习动力就–了，本来我们实验室的氛围就比较自由（一旦都不push），还是希望自己在有限的时间内多学到点东西，所以还是把暑假填的坑全部补上去。</p><p>本周依然是看论文，一遍扫完论文确实还是一知半解，这两天打算重新看一遍论文，自己总结一下，具体思考一下如何来搭建这个系统。  </p><p>啊，vscode的字体真好看。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>生活教我好好做人，逼迫我学会做饭。  </p><p>认清楚的还有一点就是我前三年的生活作息过于反人类，我不烂脸谁烂脸。早睡早起，清淡饮食，拒绝甜品，远离肥宅水。  </p><h1 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h1><p>这个月依然没有足够吸引人的番</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对这段时间的生活总结。&lt;/p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="日记" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统day0</title>
    <link href="http://yoursite.com/2019/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fday0/"/>
    <id>http://yoursite.com/2019/08/06/深入理解计算机系统day0/</id>
    <published>2019-08-06T06:13:24.000Z</published>
    <updated>2019-08-06T06:31:27.215Z</updated>
    
    <content type="html"><![CDATA[<p>从今天开始，开始看CMU的深入理解计算机系统。今天主要飞快地过了第一章。</p><a id="more"></a><p>第一章作为对本书主题的漫游，简略地讲了内存、进程、中央处理器几个概念。这里对最后提到的几个重要主题进行记录。</p><h1 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h1><p>要想显著地加速整个系统，必须提升全系统中相当大部分的速度。</p><h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><p>并发(concurrency)表示的是一个同时具有多个活动的系统；而并行(parallelism)指的是用并发使一个系统运行得更快。其具体的实现可以从线程级并发、指令级并行和单指令、多数据并行。</p><h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><p>在处理器中，指令集架构是对实际处理器硬件的抽象。文件是对I/O设备的抽象，虚拟内存是对程序存储器的抽象，而进程是对正在运行的程序的抽象，虚拟机提供对整个计算机的抽象，包括操作系统、处理器和程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从今天开始，开始看CMU的深入理解计算机系统。今天主要飞快地过了第一章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>专业单词记录</title>
    <link href="http://yoursite.com/2019/08/02/%E4%B8%93%E4%B8%9A%E5%8D%95%E8%AF%8D%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/08/02/专业单词记录/</id>
    <published>2019-08-02T07:54:26.000Z</published>
    <updated>2019-08-31T08:46:37.977Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要用于记录在论文中看到的常见的专业单词以及感觉很有意思的短语句子之类的。</p><a id="more"></a><p>hypervisor 系统管理程序<br>homomorphic encryption  同态加密<br>endorsement  认可，支持<br>predecessor  前驱，前辈<br>software attestation  软件认证<br>peripheral  外围的，次要的<br>compatible  兼容的<br>manual 手册<br>dedicated  专用的<br>asynchronous  异步的<br>delegate  委托<br>evict  驱逐<br>asynchronous enclave exit  异步安全区退出<br>scatter  分散<br>prerequisite  先决条件<br>lauch control feature  发射控制功能<br>hint  暗示<br>disclose  揭示<br>sidestep  回避<br>peculiarity  特性<br>refrain  节制<br>intricacy  复杂性<br>multiplex  多路传输<br>disposal  处理<br>register file  寄存器堆<br>thrust  重点<br>terminology  术语<br>acronyms  首字母缩略词<br>peripheral  外设<br>intuition  直观<br>building block  基石<br>salient feature  鲜明特征<br>procedural  程序<br>internal memory  内部存储器，内存<br>execution context  执行上下文<br>instruction pointer  指令指针<br>stack point  堆栈指针<br>precondition  前置条件<br>execution flow  执行流<br>in a nutshell  简而言之<br>processor  处理器<br>issue by 发出的<br>interrupt request  中断请求输入信号<br>Infrastructure-as-a-Service(IaaS)  基础设施即服务<br>implicitly  隐式地<br>motherboard  主板<br>bootstrapping  引导程序<br>firmware  固件<br>manufacture  厂商<br>emulate  仿真<br>benchmark and optimize software  基准测试和优化软件<br>fine-grained  细粒度的<br>virtually  事实上<br>load  加载<br>concurrently  同时地<br>codebase  代码库<br>monolithic kernel  单内核<br>video rendering functionality  视频渲染功能<br>a high-speed scratch space  一个高速暂存空间<br>memory-mapped device  内存映射设备<br>memory space  内存空间<br>shorthand for  简写为<br>over_commit  过量使用<br>page swapping  页调换<br>extend page table  扩展页表<br>attributes  属性<br>give … insight into  使…深入了解<br>memory access pattern  内存访问模式<br>fetch  取指令<br>pointer arithmetic  指针运算<br>context switching  上下文切换<br>general-purpose register  通用寄存器<br>procedure  程序<br>procedure call stack  过程调用堆栈<br>further-proof  永不过时的<br>wart  缺点<br>descriptor  描述符<br>vestigial segmentation model  残留细分模式<br>TLS=Thread-Local-Store  线程本地存储<br>disable  禁用<br>addressable space  可寻址空间<br>unnamed  未指定的<br>entry  条目<br>map  映射<br>interrupt  中断<br>invoke  调用<br>invariant  不变量<br>entry point  入口点<br>have deep implications for  对…有深刻影响<br>intimidating  吓人的<br>rogue application  流氓应用<br>recursive  递归<br>exception handler  异常处理程序<br>resume  恢复<br>restore  恢复</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要用于记录在论文中看到的常见的专业单词以及感觉很有意思的短语句子之类的。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机英语" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="计算机英语" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基本知识</title>
    <link href="http://yoursite.com/2019/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/08/01/操作系统基本知识/</id>
    <published>2019-08-01T06:10:04.000Z</published>
    <updated>2019-08-06T06:09:12.253Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章断断续续地记录了在读书中回顾到的以前遇到的基本知识，算是对计算机专业课中基本知识的回顾。</p><a id="more"></a><h1 id="内存、cache和寄存器之间的关系"><a href="#内存、cache和寄存器之间的关系" class="headerlink" title="内存、cache和寄存器之间的关系"></a>内存、cache和寄存器之间的关系</h1><p>把CPU比作大脑的话，寄存器相当于当前正在思考问题，而cache则相当于临时的记忆。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器是中央处理器(CPU)的组成部分，是有限存储容量的高速存储部件，可以用来暂存指令、数据和位址。CPU的控制部件中，包含的寄存器有指令寄存器(IR)和程序寄存器(PC)。在CPU的算数逻辑部件中，包含的寄存器有累加器(ACC)。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存用来存放当前正在使用的程序和数据。RAM可以分为静态存储器(Staic Random Access Memory,SRAM)和动态存储器(Dynamic Random Access Memory)，一般我们提到的DRAM就是内存。</p><p>SRAM中的存储单元相当于一个锁存器，只有0、1两个稳态；而DRAM是利用电容存储电荷来保存0和1两个状态，需要定时刷新。</p><p>DRAM，其中，随机访问表示的是以无序的顺序访问DRAM中的任何信息的这种能力。动态表示的是暂时性存储数据的基本能力。</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>Cache就是高速缓冲存储器，是位于CPU和主内存之间的容量小但速度很快的存储器。Cache中保存着CPU刚用过的一部分数据，当CPU再次使用这部分数据直接从Cache中直接调用即可，从而减少了CPU的使用时间提高了效率。Cache分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2早起焊在主板上，现在也都集成在CPU内部。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，寄存器(register file)位于CPU内部，内存是连接CPU和磁盘的桥梁，而缓存是为了解决内存和CPU的运算速度差异而设置的组件。数据的流向过程是内存-Cache-寄存器。</p><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>最后补一个磁盘缓存，缓存的概念目前已经从CPU和主内存之间的Cache扩充到内存和磁盘之间的Cache（磁盘缓存）。凡是速度差异较大的两个硬件之间，用于协调两者数据传输速度差异的结构，就可以称之为Cache。</p><p>磁盘缓存实际上是将需要下载的数据先保存到系统为软件分配的内存空间中（该内存空间被称之为“内存池”），当保存到内存池中的数据达到一定程度时，便将数据保存到硬盘中，这样就可以减少实际的磁盘操作，有效保护磁盘避免重复的读写操作而造成的损坏。</p><blockquote><p>磁盘缓存是为了减少CPU透过I/O读取磁盘的次数，提高I/O的效率，用一块内存来存储存取较为频繁的磁盘内容。因为内存的存取是电子动作，而磁盘的存取是I/O动作。</p></blockquote><h1 id="Intel-VMM"><a href="#Intel-VMM" class="headerlink" title="Intel VMM"></a>Intel VMM</h1><p>intel提供了处理器级别的VMX(Virtual-Machine Extensions)技术.intel VMX的体系结构可以划分为两层：VMM和VM。</p><p>VMM(Virtual-Machine Monitors)作为host，具有对processor和平台硬件的完全控制权限。它为guest提供了VCPU(virtual processor)的抽象，并允许guest直接运行在逻辑处理器上，具有对处理器资源、物理内存、中断和IO的控制的权利。  </p><p>VM(Virtual-Machine)相应地作为guest，其实提供了一种guest的软件环境。它维护了一个栈，其中包含了OS和application software。其中每个操作都独立于其他的VM，并且使用由同一个物理平台所提供的处理器、内存、硬盘、显卡和IO访问的统一接口。这些栈并不知道VMM的存在。运行于VM中的软件其权限是受限的，也就保障了VMM对整个平台资源的完全控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章断断续续地记录了在读书中回顾到的以前遇到的基本知识，算是对计算机专业课中基本知识的回顾。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="基本知识复习" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>SGX-Ubuntu-makefile</title>
    <link href="http://yoursite.com/2019/08/01/SGX-Ubuntu-makefile/"/>
    <id>http://yoursite.com/2019/08/01/SGX-Ubuntu-makefile/</id>
    <published>2019-08-01T05:04:10.000Z</published>
    <updated>2019-08-01T05:10:59.651Z</updated>
    
    <content type="html"><![CDATA[<p>本次实验是在虚拟机上配置好了Ubuntu16.04之后，在该系统上进行SGX实验。主要参照qiu_pengfei的blog<a href="https://blog.csdn.net/qiu_pengfei/article/details/78798644" target="_blank" rel="noopener">Ubuntu16.04下Intel SGX应用程序程序开发——打印Hello World！</a>。</p><a id="more"></a><h1 id="sgx-helloworld程序"><a href="#sgx-helloworld程序" class="headerlink" title="sgx_helloworld程序"></a>sgx_helloworld程序</h1><p>在SGX SDK中，在/sgxsdk/SampleCode文件下提供了6个SGX应用程序示例。</p><h1 id="文件夹介绍"><a href="#文件夹介绍" class="headerlink" title="文件夹介绍"></a>文件夹介绍</h1><p>其中，SampleEnclave示例实现了安全printf函数，可以用来安全打印需要打印的字符串。该项目中一共包含了3个文件夹。 </p><h2 id="App文件夹"><a href="#App文件夹" class="headerlink" title="App文件夹"></a>App文件夹</h2><p>该文件夹中存储着应用程序中的不可信代码部分，其中包含了Edger8rSyntax、TrustedLibrary文件夹、App.h、App.cpp文件。</p><h3 id="App-cpp文件"><a href="#App-cpp文件" class="headerlink" title="App.cpp文件"></a>App.cpp文件</h3><p>应用程序中的不可信部分代码，其中包含了创建Enclave以及销毁Enclave的代码、返回码供使用者查看Enclave程序的执行状态。其中，main函数是整个项目的入口函数。</p><h3 id="App-h文件"><a href="#App-h文件" class="headerlink" title="App.h文件"></a>App.h文件</h3><p>该文件是应用程序中不可信部分代码的头文件，定义了一些宏常量和函数声明。</p><h3 id="Edger8rSyntax文件夹"><a href="#Edger8rSyntax文件夹" class="headerlink" title="Edger8rSyntax文件夹"></a>Edger8rSyntax文件夹</h3><p>提供了一些工具，无需进行修改。</p><h3 id="TrustedLibrary文件夹"><a href="#TrustedLibrary文件夹" class="headerlink" title="TrustedLibrary文件夹"></a>TrustedLibrary文件夹</h3><p>提供了一些函数库，无需进行修改，</p><h2 id="Enclave文件夹"><a href="#Enclave文件夹" class="headerlink" title="Enclave文件夹"></a>Enclave文件夹</h2><p>该文件夹存放的是应用程序中的可信代码部分、可信与不可信代码接口文件。</p><h3 id="Enclave-config-xml文件"><a href="#Enclave-config-xml文件" class="headerlink" title="Enclave.config.xml文件"></a>Enclave.config.xml文件</h3><p>Enclave的配置文件，定义了Enclave的元数据信息。  </p><h3 id="Enclave-cpp文件"><a href="#Enclave-cpp文件" class="headerlink" title="Enclave.cpp文件"></a>Enclave.cpp文件</h3><p>该文件是应用程序中的可信部分代码，包括了可信函数的实现，是需要修改的文件。  </p><h3 id="Enclave-h文件"><a href="#Enclave-h文件" class="headerlink" title="Enclave.h文件"></a>Enclave.h文件</h3><p>是应用程序中的可信部分代码的头文件，定义了一些宏常量和函数声明，是需要修改的文件。</p><h3 id="Enclave-edl文件"><a href="#Enclave-edl文件" class="headerlink" title="Enclave.edl文件"></a>Enclave.edl文件</h3><p>该文件是Enclave的接口定义文件，定义了不可信代码调用可信代码的ECALL函数接口和可信代码调用不可信代码的OCALL函数接口。其中trusted{}中定义了ECALL函数接口，untrusted{}中定义了OCALL函数接口。</p><h3 id="Enclave-lds文件"><a href="#Enclave-lds文件" class="headerlink" title="Enclave.lds文件"></a>Enclave.lds文件</h3><p>定义了Enclave可执行文件信息。</p><h3 id="Enclave-private-pem文件"><a href="#Enclave-private-pem文件" class="headerlink" title="Enclave_private.pem文件"></a>Enclave_private.pem文件</h3><p>该文件是SGX生成的私钥，无需修改。</p><h3 id="Edger8rSyntax文件夹-amp-TrustedLibrary文件夹"><a href="#Edger8rSyntax文件夹-amp-TrustedLibrary文件夹" class="headerlink" title="Edger8rSyntax文件夹&amp;TrustedLibrary文件夹"></a>Edger8rSyntax文件夹&amp;TrustedLibrary文件夹</h3><p>同上</p><h2 id="include文件夹"><a href="#include文件夹" class="headerlink" title="include文件夹"></a>include文件夹</h2><p>该文件夹存放被Enclave接口定义文件Enclave.edl使用的头文件，包括一些宏定义，其中只包含了user_types.h文件，该文件主要定义了用户自定义的类型。</p><h2 id="Makefile文件"><a href="#Makefile文件" class="headerlink" title="Makefile文件"></a>Makefile文件</h2><p>该文件保存着编译相关的信息。  </p><h3 id="修改SDK路径"><a href="#修改SDK路径" class="headerlink" title="修改SDK路径"></a>修改SDK路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SGX_SDK ?= ~/下载/sgxsdk //sgx SDK安装的位置</span><br><span class="line">SGX_MODE ?= SIM  //模拟运行</span><br></pre></td></tr></table></figure><h3 id="修改不可信代码编译的源文件"><a href="#修改不可信代码编译的源文件" class="headerlink" title="修改不可信代码编译的源文件"></a>修改不可信代码编译的源文件</h3><p>由于不可信代码可能是多个文件，所以最好在App_Cpp_Files文件中包括App文件夹中的所有cpp文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App_Cpp_Files := $(wildcard App/*.cpp) $(wildcard App/Edger8rSyntax/.cpp) $(wildcard App/TrustedLibrary/*.cpp)</span><br></pre></td></tr></table></figure><h3 id="修改可信代码编译的源文件"><a href="#修改可信代码编译的源文件" class="headerlink" title="修改可信代码编译的源文件"></a>修改可信代码编译的源文件</h3><p>同理，可信代码也可能是多个文件，最好在Encalve_Cpp_Files中包括Enclave文件夹中的所有cpp文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App_Cpp_Files := $(wildcard Enclave/*.cpp) $(wildcard Enclave/Edger8rSyntax/.cpp) $(wildcard Enclave/TrustedLibrary/*.cpp)</span><br></pre></td></tr></table></figure><h1 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h1><p>需要修改的文件包括Enclave.edl文件、Enclave.cpp文件、Enclave.h文件、App.cpp文件和makefile文件（已修改完成）。</p><h2 id="Enclave-edl文件修改"><a href="#Enclave-edl文件修改" class="headerlink" title="Enclave.edl文件修改"></a>Enclave.edl文件修改</h2><p>该文件中添加不可信代码调用可信函数的接口，也就是ECALL，添加到untrusted{}之前。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trusted&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printf_helloworld</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enclave-cpp文件修改"><a href="#Enclave-cpp文件修改" class="headerlink" title="Enclave.cpp文件修改"></a>Enclave.cpp文件修改</h2><p>该文件就是实现printf_helloworld函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_helloword</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enclave-h文件修改"><a href="#Enclave-h文件修改" class="headerlink" title="Enclave.h文件修改"></a>Enclave.h文件修改</h2><p>将printf_helloworld函数声明添加到Enclave.h文件中。添加到原先的printf函数的下方即可。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_helloworld</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="App-cpp文件修改"><a href="#App-cpp文件修改" class="headerlink" title="App.cpp文件修改"></a>App.cpp文件修改</h2><p>该文件中调用自定义的ECALL函数printf_helloworld，将下面的代码放到<code>sgx_destroy_enclave(global_eid);</code>之前。其中，global_eid是必须的，表示的是enclave的id。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf_helloworld(global_eid);</span><br></pre></td></tr></table></figure><h1 id="编译文件"><a href="#编译文件" class="headerlink" title="编译文件"></a>编译文件</h1><p>打开终端，进入文件夹中，首先<code>source ~/下载/sgxsdk/environment</code>将sgx sdk设置到环境变量中。而后，输入make进行编译。</p><h1 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h1><p>在终端输入./app，可以看到hello world，说明程序编写正确。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次实验是在虚拟机上配置好了Ubuntu16.04之后，在该系统上进行SGX实验。主要参照qiu_pengfei的blog&lt;a href=&quot;https://blog.csdn.net/qiu_pengfei/article/details/78798644&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu16.04下Intel SGX应用程序程序开发——打印Hello World！&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="SGX" scheme="http://yoursite.com/categories/SGX/"/>
    
    
      <category term="SGX" scheme="http://yoursite.com/tags/SGX/"/>
    
      <category term="实验" scheme="http://yoursite.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>阅读英文文献建议</title>
    <link href="http://yoursite.com/2019/08/01/%E9%98%85%E8%AF%BB%E8%8B%B1%E6%96%87%E6%96%87%E7%8C%AE%E5%BB%BA%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/08/01/阅读英文文献建议/</id>
    <published>2019-08-01T04:52:53.000Z</published>
    <updated>2019-08-01T05:02:32.619Z</updated>
    
    <content type="html"><![CDATA[<p>最近正在读老师建议的Intel SGX Explained，相当于对SGX的入门综述，100多页的全英文，读的脑阔疼，真~看了上句忘了下句….然后我就很困惑，我到底要怎么去读这本书，从知乎上了看了相关的经验后，总结如下。</p><a id="more"></a><h1 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h1><h2 id="如何阅读文献"><a href="#如何阅读文献" class="headerlink" title="如何阅读文献"></a>如何阅读文献</h2><ul><li><p>注重摘要</p></li><li><p>确立句子的架构</p></li><li><p>增加阅读量</p></li></ul><h2 id="如何提高阅读的效率"><a href="#如何提高阅读的效率" class="headerlink" title="如何提高阅读的效率"></a>如何提高阅读的效率</h2><ul><li><p>集中时间看文献</p></li><li><p>做好标记和记录</p></li></ul><h1 id="三步走方法"><a href="#三步走方法" class="headerlink" title="三步走方法"></a>三步走方法</h1><p>三步走方法参考的是滑铁卢大学教授的paper<a href="http://ccr.sigcomm.org/online/files/p83-keshavA.pdf" target="_blank" rel="noopener">How to Read a Paper</a>，写的非常有意思，而且易懂。</p><h2 id="first-pass"><a href="#first-pass" class="headerlink" title="first pass"></a>first pass</h2><p>first pass主要强调的是”get a bird’s-eye view”，快速地扫一遍</p><h3 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h3><blockquote><p>认真读标题、摘要和介绍(introduction)<br>读标题和子标题，忽略其他一切<br>过一遍(glance)公式<br>阅读结论<br>扫一遍参考文献，在心中标记处已经读过</p></blockquote><h3 id="需要回到的five-Cs"><a href="#需要回到的five-Cs" class="headerlink" title="需要回到的five Cs"></a>需要回到的five Cs</h3><blockquote><p>种类(category)：这篇paper是那种类型的？<br>内容(Context)：这篇文章与哪些文章有关联？哪些理论基础会被用来分析这个问题？<br>这些假设是否是有依据的？<br>这篇论文的主要贡献是什么？<br>这篇文章写得好吗？</p></blockquote><h2 id="second-pass"><a href="#second-pass" class="headerlink" title="second pass"></a>second pass</h2><p>第二步需要更好的耐心来看，但同时也需要忽略诸如证明之类的细节。本部分能够帮助记下key points（核心点），并在空白处记下评论。</p><blockquote><p>仔细看图表、图片以及论文中的其他的说明。<br>记得要去标注相关的未读过的参考文献for further reading</p></blockquote><h2 id="third-pass"><a href="#third-pass" class="headerlink" title="third pass"></a>third pass</h2><p><strong>复现论文</strong>  </p><p>在这一步，需要考虑的是我们自己应该如何定义或者挑战假设，更多的是，我们需要考虑自己如何提出一个特别的idea。在这一部分，我们需要记下敢于未来干工作的想法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近正在读老师建议的Intel SGX Explained，相当于对SGX的入门综述，100多页的全英文，读的脑阔疼，真~看了上句忘了下句….然后我就很困惑，我到底要怎么去读这本书，从知乎上了看了相关的经验后，总结如下。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="英语" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="读后感" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>intel sgx explained阅读笔记</title>
    <link href="http://yoursite.com/2019/07/31/intel-sgx-explained%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/31/intel-sgx-explained阅读笔记/</id>
    <published>2019-07-31T08:17:08.000Z</published>
    <updated>2019-09-01T09:15:41.060Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要是对SGX经典入门综述intel SGX Explained这本书的阅读笔记。</p><p>希望能够坚持下来，在这个过程中得到从英语和知识水平两个方面的提高。  </p><a id="more"></a><h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p>之前看的时候还很不连贯，会在最后第2,5章全部读完时再回头重新读一遍时，再进行相关的记录。</p><h1 id="computer-architecture-background"><a href="#computer-architecture-background" class="headerlink" title="computer architecture background"></a>computer architecture background</h1><p>本部分主要是对intel目前最为流行的计算机处理器背后的总体架构进行概括，以及运行在这些处理器上的系统所需要的安全特性。</p><p>在经过一个月艰(mo)苦(yu)卓(wan)绝(le)的学习下，终于把第二章读完了。第二章主要是从操作系统和体系结构的角度来对intel计算机体系架构进行了介绍。</p><p>计算机最为重要的资源就是处理器(processor)和内存(memory)。DRAM提供了内存资源，而CPU芯片则提供了逻辑处理器资源。计算机资源是由系统软件来进行管理，而系统软件主要分成两类：操作系统(operating system)和管理程序(hypervisor)。操作系统将计算机资源分配给正在运行的进程，而一台计算机中可能有多个操作系统，管理程序便负责将计算机资源分配给不同的操作系统。</p><p>为了让多个同时运行的操作系统之间不互相影响，计算机使用了虚拟化技术(virtualization)。其中一个就是地址映射技术，而另一个则是软件特权等级。</p><p>另外，每个进程由包含着一个或多个线程(thread)，每个线程都有执行上下文信息(execuation context)，其中包含了计算所必要的信息。计算机让每个进程都认为自己可以无限制地使用计算机资源，但实际上处理器资源是有限的，这里就用到了复用技术，也就是一个逻辑处理器可能会被多个进程或操作系统使用。</p><p>DRAM和CPU之间的速度差距非常大，当代intel体系结构中的很多复杂性都源于缩小这种差距的需要。比如说hyperthreading、out-of-order execuation、caching。cache是其中最为典型的代表(cache分为不同的level，level1在CPU内核内部)，由于不止存在一个cache，同时也不会有不同的内存对其进行读写，所以使用cache coherence mechanism来保证对于所有的缓存来说，看到的DRAM都是一致的。</p><p>CPU与DRAM和I/O设备都是使用system bus来进行通信的。intel架构的软件是通过I/O地址空间与I/O设备进行通信，使用内存地址空间对DRAM进行访问。</p><p>计算机由于有非常多的外设，所以初始化是一件复杂的过程，初始化序列也带来的一定的安全妥协和问题。</p><p>最后讲述了microcode。</p><h1 id="计算模型-Computation-Model"><a href="#计算模型-Computation-Model" class="headerlink" title="计算模型(Computation Model)"></a>计算模型(Computation Model)</h1><p>计算机最基本的几个组成部件就是DRAM、处理器，DRAM与处理器和I/O设备之间都通过系统总线进行连接。</p><p>DRAM其实也就是一般所说的内存，表现为一个存储单元构成的数组。一个显著的特征是<strong>在一个地址读取到的内存单元的值必须等于它被写入的最新值</strong>.</p><p>处理器最核心的功能就是处理指令，当处理器开始处理指令时，首先会判断当前是否是中断（interrupt）。如果是中断，则首先将当前中断数据写入exception register，而后进行异常管理：定位到异常管理程序的位置–&gt;定位异常管理程序栈顶–&gt;将RIP和RSP压入栈中–&gt;像RIP中写入异常管理程序地址–&gt;向RSP中写入栈顶地址。而如果没有发生中断，则在RIP中进行取指令–&gt;对指令进行译码–&gt;读取目前指令的输入寄存器(current register’s input register)（这边这个我理解的是不是说指令是不是寄存器寻址这些？）–&gt;执行。在执行过程中，可能会遇到出错，在遇到出错时，将出错信息写入到exception register中，而后进行异常管理操作（和上面的一样）。如果没有出错，将当前指令结果写入到输出寄存器中，并判断输出寄存器中是否包含了RIP。如果包含，则下一条指令就直接从结果指定的地方执行（类似于jmp之类的跳转指令）；反之，则将RIP中的值加上当前执行指令的长度。接下来，就是下一轮的指令执行。</p><p>由于RISC（精简指令集）中的指令都是可变大小的指令，所以每条指令的大小都是不可预测的，所以必须要当前指令执行结束，才能够进行下一条指令的执行。</p><p>总线上连接着很多个不同的设备，在每个时钟周期中，这些设备能够发送消息，这些消息会被该总线上连接的所有设备接收。每个设备对消息进行解码后，发现目标地址不是自己后，就会忽视掉这条不需要自己参与的信息。</p><h1 id="软件特权级别-Software-Privilege-Levels"><a href="#软件特权级别-Software-Privilege-Levels" class="headerlink" title="软件特权级别(Software Privilege Levels)"></a>软件特权级别(Software Privilege Levels)</h1><p>设置不同的priviege level是处于对计算机安全的考虑。高安全级别的软件，能够访问低安全级别，而相反咋不能。这在一定程度上，保护了高安全级别软件的安全。所带来的另一层问题：计算机上的软件必须要信任所有更高安全级别的软件。对于一台计算机的安全分析，也应该囊括所有安全级别的软件。</p><p>intel架构中的安全级别分为三层。第一层，SMM模式下，主要包含BIOS（基本输入输出系统）；第二层：VMX root，主要是hypervisor（管理程序），hypervisor负责对使用着同一个物理机的不同操作系统进行资源分配；第三次：VMX non-root：ring0是OS kernel；而ring3是普通的应用程序。</p><p>根据kernel不同的设计思想，可以分为微内核和单内核。微内核中强调kernel尽可能地小，只包含核心组件，而其他相应不那么重要的组件可以运行在非内核中（比如Windows）。但另一方面，单内核中虽然有大量的组件，但执行效率高，不同组件之间重要通过进行模块调用即可（Linux），而相对的，微内核不同模块的调用是需要进行调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要是对SGX经典入门综述intel SGX Explained这本书的阅读笔记。&lt;/p&gt;
&lt;p&gt;希望能够坚持下来，在这个过程中得到从英语和知识水平两个方面的提高。  &lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="SGX" scheme="http://yoursite.com/tags/SGX/"/>
    
      <category term="基本知识复习" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>SGX官方视频笔记</title>
    <link href="http://yoursite.com/2019/07/31/sgx%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/31/sgx笔记/</id>
    <published>2019-07-31T05:23:58.000Z</published>
    <updated>2019-11-10T02:58:10.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="intel-sgx笔记"><a href="#intel-sgx笔记" class="headerlink" title="intel sgx笔记"></a>intel sgx笔记</h1><p>本文是根据b站上的sgx介绍视频整理而来的对sgx的基本概念的介绍。</p><p>intel sgx是使得程序能够在可信的环境下执行代码并保护机密信息，从而让开发者直接控制程序的安全性。<br>intel sgx在内存中划定了名为安全区（enclave）的隔离区域，用来存放代码和数据。</p><a id="more"></a><h2 id="features-and-benefits"><a href="#features-and-benefits" class="headerlink" title="features and benefits"></a>features and benefits</h2><ul><li>这些不可寻址的分页内存是从系统的物理内存中保留的，并且经过了加密；</li><li>安全区是受保护的内存区域，应用程序可以在里面处理它的机密数据而不必担心泄露；</li></ul><p>包含intel SGX技术的应用程序分为两个部分，分别是可信部分和不可信部分。当应用程序需要处理机密时，会创建一个位于可信内存的安全区，然后调用可信函数。可信函数是由开发者创建的，专门在安全区内执行的函数。一旦这个函数被调用，应用程序就会在可信区域执行，并且明文访问安全区内的代码和数据。而试图从安全区之外的地方访问安全区内存的行为都会被处理器拒绝，即使是系统特权用户的行为。</p><p>当可信函数执行完毕之后，安全区的数据依然会保留在可信内存中，而应用程序返回到不可信区域继续执行，并且失去了对可信内存的访问权限。</p><h2 id="检测和开启intel-SGX"><a href="#检测和开启intel-SGX" class="headerlink" title="检测和开启intel SGX"></a>检测和开启intel SGX</h2><p>应用程序可以使用intel SGX的四个条件</p><blockquote><p>CPU必须支持intel SGX的指令<br>BIOS必须支持intel SGX<br>必须在BIOS设置中开启intel SGX<br>必须安装intel SGX PSW</p></blockquote><p>BIOS设置中intel SGX可能的三种选项是启用、禁用以及软件控制</p><blockquote><p>“启用”：严格开启了intel SGX<br>“禁用”：严格关闭了intel SGX<br>“软件控制”：允许包含intel SGX技术的应用程序在系统重启后启用intel SGX  </p></blockquote><p>安装程序时检查的步骤：</p><blockquote><p>检查CPU和BIOS是否支持intel SGX<br>检查intel SGX PSW是否安装，如果没有安装，就安装<br>检查intel SGX是否在BIOS中开启，如果没有开启，则用软件控制开启</p></blockquote><p>应用程序本身的检查</p><blockquote><p>检查intel SGX PSW是否安装<br>检查SGX是否可用，如果不可用，则使其变为启用</p></blockquote><p>如果上述步骤中的任一步骤失败，则说明系统不支持intel SGX。</p><h2 id="如何设计intel-SGX应用程序"><a href="#如何设计intel-SGX应用程序" class="headerlink" title="如何设计intel SGX应用程序"></a>如何设计intel SGX应用程序</h2><p>所有的intel SGX应用程序都有相同的基本结构，也就是他们在设计时都要遵循一些通用的原则。intel SGX应用程序分成两个部分，可信部分和不可信部分。</p><p>应用程序的可信部分由它的安全区（enclaves）组成，一个应用程序可以拥有一个或多个安全区。安全区存储在加密的内存中，并受intel SGX的保护。安全区是可信的，它们一旦被建立就不能被篡改。如果安全区的数据被恶意篡改，就会被CPU检测到，并不会被加载。</p><p>可信部分之外的被称为非可信部分，也就是不会被intel SGX保护的应用程序或内存区域。</p><p>如果我们需要设计一个intel SGX程序，就需要将程序分成两个不同的部分，需要判断哪些代码应该放在安全区，哪些代码应该放在安全区之外以及可信部分和非可信部分的交互。</p><p>划分代码的关键步骤：</p><ul><li>确定机密信息  </li><li>确定机密数据的提供者和使用者(画出机密数据在应用程序中的各个组件的流程图，也就是机密数据的来源和去向)  </li><li>确定安全边界(划定边界时，需要尽量包含尽可能多的机密数据，并最大限度地减少与非信任代码的交互)  </li><li>精简安全区的代码<br>在为安全区以及它的接口编写代码时需要记住：<blockquote><p>单一系统中，用于运行所有安全区的内存容量是固定的。    </p></blockquote></li></ul><p>安全区的体积应该尽可能地小。当不再需要机密数据时，安全区应该被销毁。  </p><blockquote><p>进出安全区的调用会产生性能损失，就和CPU上下文切换一样。 </p></blockquote><p>通过一次调用完成大量工作，会比分成多次调用来完成等量的工作更有效率。</p><h2 id="安全区定义语言（EDL）"><a href="#安全区定义语言（EDL）" class="headerlink" title="安全区定义语言（EDL）"></a>安全区定义语言（EDL）</h2><p>intel SGX提供的基本保护措施是安全区的机密数据仅能够被安全区内的代码访问。执行安全区内的代码的唯一方式是通过开发人员创建的接口函数。</p><p>每个安全区可以定义一个或多个e-call，e-call是非可信应用程序进入安全区的入口点；安全区也可以定义o-call，o-call使得安全函数可以调用外部的非可信应用程序，而后再返回安全区。ECALL和OCALL共同组成了安全区的接口，这些函数并非由非可信应用程序执行。</p><p>处理器对安全区出入口的访问严格控制，同时为了完成出入安全区的转换，必须依序执行特定的CPU指令。</p><p>intel SGX SDK把这些底层细节做了抽象，从而让软件开发者可以用熟悉的编程环境进行开发，名为Edger8r的特殊工具会自动为E-CALL和O-CALL生成代理函数，从而应用程序就可以像调用其他C语言函数一样调用它。</p><p>Edger8r从EDL文件中读取安全区接口的定义来创建代理函数。</p><p>安全区定义语言(enclave definition language,EDL)，EDL文件和声明函数原型的C语言风格的头文件十分相似。</p><p>EDL文件由可信区和非可信区组成。E-CALL定义在可信区，而O-CALL定义在非可信区。这些函数原型与C非常相似，但还需要一些额外的关键字。<br>所有能够被非可信程序调用的E-CALL都必须声明为public，每个安全区都至少有一个声明为public的E-CALL，不含public关键字的E-CALL只能被另一个O-CALL执行。</p><p>在进行E-CALL或O-CALL调用时，函数参数要从非可信内存和可信内存之间进行封送处理。若函数参数是值传递，对应的封送处理就是单向的。在E-CALL或O-CALL内部进行的更改不会反映到被调用的函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enclave&#123;</span><br><span class="line">    from <span class="string">"sgx_tstdc.edl"</span> <span class="keyword">import</span> *;</span><br><span class="line">    trusted&#123;</span><br><span class="line">        <span class="comment">/*define ECALLs here. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ecall_private</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    untrusted&#123;</span><br><span class="line">        <span class="comment">/*define OCALLs here. */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">an_ocall</span><span class="params">(<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果函数参数时引用传递，就必须完整地描述数据的封送处理过程，每个指针或参数之前必须有方括号来描述封送处理的方向以及封送处理的元素数量</p><p>in关键字表示数据需要封送到E-CALL或O-CALL之内，而如果是out关键字则意味着数据需要从E-CALL或O-CALL封送回调用的函数。如果需要out，则需要在调用E-CALL或O-CALL之前分配好数据的缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in] <span class="keyword">int32_t</span> *value)</span></span>;</span><br></pre></td></tr></table></figure><p>如果同时指定了in和out关键字，意味着要进行两个方向的封送处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,out] <span class="keyword">int32_t</span> *value)</span></span></span><br></pre></td></tr></table></figure><p>在缺省情况下，Edger8r假定数据的缓冲区大小等于参数的sizeof。如果指针指向的是一个数组，那么需要提供count参数来指定需要复制的元素个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,count=<span class="number">10</span>] <span class="keyword">int32_t</span> *<span class="built_in">array</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如果参数的个数要等到运行的时候才能确定，也可以用另一个函数参数来表示个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,count=len] <span class="keyword">int32_t</span> *<span class="built_in">array</span>,<span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>如果使用in关键字封送一个以’\0’作为终止符的字符串，可以选择使用string或者是wstring来代替count关键字，string或wstring不能和out关键字一起使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,<span class="built_in">string</span>] <span class="keyword">int32_t</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_wecall</span><span class="params">([in,wstring] <span class="keyword">wchar_t</span> *unicodename)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="EDL语言的进阶主题"><a href="#EDL语言的进阶主题" class="headerlink" title="EDL语言的进阶主题"></a>EDL语言的进阶主题</h2><p>有时需要把void指针传给E-CALL或O-CALL，问题在于边界例程无法知道void类型对应的大小，无法计算封送处理需要的数据缓冲区大小。为了解决这个问题，EDL语法提供了size关键字，通过指定单个元素的大小，边界例程就知道需要拷贝多少数据。在下面的例子中，32个8字节数据将会被封送到E-CALL中。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,count=<span class="number">32</span>,size=<span class="number">8</span>] <span class="keyword">void</span> *buffer)</span></span></span><br></pre></td></tr></table></figure><p>在不希望封送完整的数据缓冲区时，仅仅希望把指针指向的地址传给E-CALL或O-CALL，这可以通过user_check关键字来完成。这样行为传递的指针不进行边界例程的安全检查和数据封送处理，E-CALL和O-CALL将会直接作用于指针的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([user_check] <span class="keyword">void</span> *buff)</span></span>;</span><br></pre></td></tr></table></figure><p>只有被声明为public的E-CALL可以被不安全的函数调用，被称之为root E-CALL，由EDL文件中使用的public关键字指定，不含public关键字的E-CALL只能被另一个O-CALL调用，但是，在缺省情况下，O-CALL不能调用任何E-CALL，必须通过allow关键字声明该O-CALL可以调用哪些E-CALL,allow后面跟着允许的E-CALL名称列表。在本例中，O-CALL get_msg_block()只能调用E-CALL update_hash()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enclave&#123;</span><br><span class="line">    from <span class="string">"sgx_tstdc.edi"</span> <span class="keyword">import</span> *;</span><br><span class="line">    trusted&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init_hash</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_hash</span><span class="params">([out] <span class="keyword">char</span> hash[<span class="number">32</span>])</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">update_hash</span><span class="params">([in,count=len],<span class="keyword">char</span> *block,<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    untrusted&#123;</span><br><span class="line">        <span class="keyword">size_t</span> get_msg_block() allow(updata_hash);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试intel-SGX应用程序"><a href="#调试intel-SGX应用程序" class="headerlink" title="调试intel SGX应用程序"></a>调试intel SGX应用程序</h2><p>intel SGX安全区可以以debug模式或release模式构建。</p><ul><li>debug模式<blockquote><p>debug模式下的安全区是可以调试的；<br>可以使用intel SGX调试器附加到上面；<br>查看当前的状态；<br>以及对代码进行逐句调试，就和调试其他程序一样  </p></blockquote></li></ul><p>当在调试intel SGX应用程序时，它很有可能是以debug模式构建的，CPU允许运行任何以debug模式构建的安全区，由于您可以用intel SGX调试器附到安全区上，这些安全区显然是不安全的，所以<strong>永远不要在生产环境上部署以debug模式构建的安全区</strong></p><ul><li>release模式</li></ul><p>release模式构建的安全区无论如何也无法进行调试，CPU严格执行这条限制。对于intel SGX安全区的调试，仍然需要相关的CPU指令支持，这就意味着必须使用随intel SGX SDK安装的intel SGX调试器进行调试，而其他的调试器只会跳过安全区的代码。</p><h2 id="intel-SGX的数据密封功能"><a href="#intel-SGX的数据密封功能" class="headerlink" title="intel SGX的数据密封功能"></a>intel SGX的数据密封功能</h2><p>intel SGX应用程序也有可能需要把机密数据保存到安全区以外。安全区从本质上来说是无状态的：</p><blockquote><p>当电脑进入睡眠、关机或者应用程序退出时，安全区就会被销毁；<br>应用程序显示将其销毁时，安全区也会被销毁，当安全区被销毁后，其中的所有内容都会丢失。</p></blockquote><p>为了持久保存安全区内存储的数据，必须显式地将其发送到安全区以外的非可信内存中。由于不可信内存是不可信的，所以系统为数据提供密封功能。当数据被密封时，数据在安全区内用密钥加密，这个密钥是直接从CPU中取得的。加密的数据块被称为密封的数据，它只能在创建的电脑上进行解密。</p><p>密封数据时可以选择的密钥策略有两种：</p><ul><li>安全区标识(MRENCLAVE)  </li></ul><p>安全区标识策略生成一个该安全区独有的密钥，这就意味着只有同一台电脑的同一个安全区可以解封数据</p><ul><li>密封标识(MRSIGNER)  </li></ul><p>密封标识基于安全区密封授权方的密钥生成一个密钥，这使得一个安全区密封的数据可被另一个安全区解封。只要是同一台电脑，而且软件是由相同开发商开发（密封授权方的密钥相同）即可。该策略可以允许数据被新版应用程序或其他构建版本的应用程序所读取。该方法可以在两个不同的应用程序的两个不同的安全区中共享数据。</p><p>这两种策略的相同点是密封数据的电脑的指纹是密钥的一个输入，这就意味着如果密封的数据被复制到了另一台电脑上就无法被解封。</p><p>密钥的另一个输入是安全区的debug模式或release模式，debug的安全区无法解封release模式的安全区密封的数据，反之亦然。这项安全机制是用于防止intel SGX调试器在调试debug的安全区时，泄露来自release模式的安全区的数据。</p><p>注意，密封数据可能具有非常严重的安全隐患：<strong>安全区并不会检验非可信应用程序的真实性，绝不能假设只有自己的应用程序能加载安全区或者说E-CALL一定会按照预期的顺序执行！</strong> 任何人都可以加载安全区，并按照他们希望的顺序执行E-CALL。安全区API绝不能因为密封数据和解封数据而泄露了机密或授予了不该授予的权限。</p><p>总而言之，密封数据的功能是为了安全地把机密数据导出到安全区以外，并确保这些机密数据不会被篡改、替换、窃听或者是在解封数据时，被复制到另一台电脑上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;intel-sgx笔记&quot;&gt;&lt;a href=&quot;#intel-sgx笔记&quot; class=&quot;headerlink&quot; title=&quot;intel sgx笔记&quot;&gt;&lt;/a&gt;intel sgx笔记&lt;/h1&gt;&lt;p&gt;本文是根据b站上的sgx介绍视频整理而来的对sgx的基本概念的介绍。&lt;/p&gt;
&lt;p&gt;intel sgx是使得程序能够在可信的环境下执行代码并保护机密信息，从而让开发者直接控制程序的安全性。&lt;br&gt;intel sgx在内存中划定了名为安全区（enclave）的隔离区域，用来存放代码和数据。&lt;/p&gt;
    
    </summary>
    
      <category term="SGX" scheme="http://yoursite.com/categories/SGX/"/>
    
    
      <category term="SGX" scheme="http://yoursite.com/tags/SGX/"/>
    
  </entry>
  
</feed>
