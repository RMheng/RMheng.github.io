<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rww&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/875500b7339ad8bf5d54b6a28209fad0</icon>
  <subtitle>半夏花已开，未来诚可期</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-02T07:40:03.202Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rmheng</name>
    <email>2961930359@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统基本知识</title>
    <link href="http://yoursite.com/2019/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/08/01/操作系统基本知识/</id>
    <published>2019-08-01T06:10:04.000Z</published>
    <updated>2019-08-02T07:40:03.202Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章断断续续地记录了在读书中回顾到的以前遇到的基本知识，算是对计算机专业课中基本知识的回顾。</p><a id="more"></a><h1 id="内存、cache和寄存器之间的关系"><a href="#内存、cache和寄存器之间的关系" class="headerlink" title="内存、cache和寄存器之间的关系"></a>内存、cache和寄存器之间的关系</h1><p>把CPU比作大脑的话，寄存器相当于当前正在思考问题，而cache则相当于临时的记忆。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器是中央处理器(CPU)的组成部分，是有限存储容量的高速存储部件，可以用来暂存指令、数据和位址。CPU的控制部件中，包含的寄存器有指令寄存器(IR)和程序寄存器(PC)。在CPU的算数逻辑部件中，包含的寄存器有累加器(ACC)。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存用来存放当前正在使用的程序和数据。RAM可以分为静态存储器(Staic Random Access Memory,SRAM)和动态存储器(Dynamic Random Access Memory)，一般我们提到的DRAM就是内存。</p><p>SRAM中的存储单元相当于一个锁存器，只有0、1两个稳态；而DRAM是利用电容存储电荷来保存0和1两个状态，需要定时刷新。</p><p>DRAM，其中，随机访问表示的是以无序的顺序访问DRAM中的任何信息的这种能力。动态表示的是暂时性存储数据的基本能力。</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>Cache就是高速缓冲存储器，是位于CPU和主内存之间的容量小但速度很快的存储器。Cache中保存着CPU刚用过的一部分数据，当CPU再次使用这部分数据直接从Cache中直接调用即可，从而减少了CPU的使用时间提高了效率。Cache分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2早起焊在主板上，现在也都集成在CPU内部。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，寄存器(register file)位于CPU内部，内存是连接CPU和磁盘的桥梁，而缓存是为了解决内存和CPU的运算速度差异而设置的组件。数据的流向过程是内存-Cache-寄存器。</p><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>最后补一个磁盘缓存，缓存的概念目前已经从CPU和主内存之间的Cache扩充到内存和磁盘之间的Cache（磁盘缓存）。凡是速度差异较大的两个硬件之间，用于协调两者数据传输速度差异的结构，就可以称之为Cache。</p><p>磁盘缓存实际上是将需要下载的数据先保存到系统为软件分配的内存空间中（该内存空间被称之为“内存池”），当保存到内存池中的数据达到一定程度时，便将数据保存到硬盘中，这样就可以减少实际的磁盘操作，有效保护磁盘避免重复的读写操作而造成的损坏。</p><blockquote><p>磁盘缓存是为了减少CPU透过I/O读取磁盘的次数，提高I/O的效率，用一块内存来存储存取较为频繁的磁盘内容。因为内存的存取是电子动作，而磁盘的存取是I/O动作。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章断断续续地记录了在读书中回顾到的以前遇到的基本知识，算是对计算机专业课中基本知识的回顾。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="基本知识复习" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SGX-Ubuntu-makefile</title>
    <link href="http://yoursite.com/2019/08/01/SGX-Ubuntu-makefile/"/>
    <id>http://yoursite.com/2019/08/01/SGX-Ubuntu-makefile/</id>
    <published>2019-08-01T05:04:10.000Z</published>
    <updated>2019-08-01T05:10:59.651Z</updated>
    
    <content type="html"><![CDATA[<p>本次实验是在虚拟机上配置好了Ubuntu16.04之后，在该系统上进行SGX实验。主要参照qiu_pengfei的blog<a href="https://blog.csdn.net/qiu_pengfei/article/details/78798644" target="_blank" rel="noopener">Ubuntu16.04下Intel SGX应用程序程序开发——打印Hello World！</a>。</p><a id="more"></a><h1 id="sgx-helloworld程序"><a href="#sgx-helloworld程序" class="headerlink" title="sgx_helloworld程序"></a>sgx_helloworld程序</h1><p>在SGX SDK中，在/sgxsdk/SampleCode文件下提供了6个SGX应用程序示例。</p><h1 id="文件夹介绍"><a href="#文件夹介绍" class="headerlink" title="文件夹介绍"></a>文件夹介绍</h1><p>其中，SampleEnclave示例实现了安全printf函数，可以用来安全打印需要打印的字符串。该项目中一共包含了3个文件夹。 </p><h2 id="App文件夹"><a href="#App文件夹" class="headerlink" title="App文件夹"></a>App文件夹</h2><p>该文件夹中存储着应用程序中的不可信代码部分，其中包含了Edger8rSyntax、TrustedLibrary文件夹、App.h、App.cpp文件。</p><h3 id="App-cpp文件"><a href="#App-cpp文件" class="headerlink" title="App.cpp文件"></a>App.cpp文件</h3><p>应用程序中的不可信部分代码，其中包含了创建Enclave以及销毁Enclave的代码、返回码供使用者查看Enclave程序的执行状态。其中，main函数是整个项目的入口函数。</p><h3 id="App-h文件"><a href="#App-h文件" class="headerlink" title="App.h文件"></a>App.h文件</h3><p>该文件是应用程序中不可信部分代码的头文件，定义了一些宏常量和函数声明。</p><h3 id="Edger8rSyntax文件夹"><a href="#Edger8rSyntax文件夹" class="headerlink" title="Edger8rSyntax文件夹"></a>Edger8rSyntax文件夹</h3><p>提供了一些工具，无需进行修改。</p><h3 id="TrustedLibrary文件夹"><a href="#TrustedLibrary文件夹" class="headerlink" title="TrustedLibrary文件夹"></a>TrustedLibrary文件夹</h3><p>提供了一些函数库，无需进行修改，</p><h2 id="Enclave文件夹"><a href="#Enclave文件夹" class="headerlink" title="Enclave文件夹"></a>Enclave文件夹</h2><p>该文件夹存放的是应用程序中的可信代码部分、可信与不可信代码接口文件。</p><h3 id="Enclave-config-xml文件"><a href="#Enclave-config-xml文件" class="headerlink" title="Enclave.config.xml文件"></a>Enclave.config.xml文件</h3><p>Enclave的配置文件，定义了Enclave的元数据信息。  </p><h3 id="Enclave-cpp文件"><a href="#Enclave-cpp文件" class="headerlink" title="Enclave.cpp文件"></a>Enclave.cpp文件</h3><p>该文件是应用程序中的可信部分代码，包括了可信函数的实现，是需要修改的文件。  </p><h3 id="Enclave-h文件"><a href="#Enclave-h文件" class="headerlink" title="Enclave.h文件"></a>Enclave.h文件</h3><p>是应用程序中的可信部分代码的头文件，定义了一些宏常量和函数声明，是需要修改的文件。</p><h3 id="Enclave-edl文件"><a href="#Enclave-edl文件" class="headerlink" title="Enclave.edl文件"></a>Enclave.edl文件</h3><p>该文件是Enclave的接口定义文件，定义了不可信代码调用可信代码的ECALL函数接口和可信代码调用不可信代码的OCALL函数接口。其中trusted{}中定义了ECALL函数接口，untrusted{}中定义了OCALL函数接口。</p><h3 id="Enclave-lds文件"><a href="#Enclave-lds文件" class="headerlink" title="Enclave.lds文件"></a>Enclave.lds文件</h3><p>定义了Enclave可执行文件信息。</p><h3 id="Enclave-private-pem文件"><a href="#Enclave-private-pem文件" class="headerlink" title="Enclave_private.pem文件"></a>Enclave_private.pem文件</h3><p>该文件是SGX生成的私钥，无需修改。</p><h3 id="Edger8rSyntax文件夹-amp-TrustedLibrary文件夹"><a href="#Edger8rSyntax文件夹-amp-TrustedLibrary文件夹" class="headerlink" title="Edger8rSyntax文件夹&amp;TrustedLibrary文件夹"></a>Edger8rSyntax文件夹&amp;TrustedLibrary文件夹</h3><p>同上</p><h2 id="include文件夹"><a href="#include文件夹" class="headerlink" title="include文件夹"></a>include文件夹</h2><p>该文件夹存放被Enclave接口定义文件Enclave.edl使用的头文件，包括一些宏定义，其中只包含了user_types.h文件，该文件主要定义了用户自定义的类型。</p><h2 id="Makefile文件"><a href="#Makefile文件" class="headerlink" title="Makefile文件"></a>Makefile文件</h2><p>该文件保存着编译相关的信息。  </p><h3 id="修改SDK路径"><a href="#修改SDK路径" class="headerlink" title="修改SDK路径"></a>修改SDK路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SGX_SDK ?= ~/下载/sgxsdk //sgx SDK安装的位置</span><br><span class="line">SGX_MODE ?= SIM  //模拟运行</span><br></pre></td></tr></table></figure><h3 id="修改不可信代码编译的源文件"><a href="#修改不可信代码编译的源文件" class="headerlink" title="修改不可信代码编译的源文件"></a>修改不可信代码编译的源文件</h3><p>由于不可信代码可能是多个文件，所以最好在App_Cpp_Files文件中包括App文件夹中的所有cpp文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App_Cpp_Files := $(wildcard App/*.cpp) $(wildcard App/Edger8rSyntax/.cpp) $(wildcard App/TrustedLibrary/*.cpp)</span><br></pre></td></tr></table></figure><h3 id="修改可信代码编译的源文件"><a href="#修改可信代码编译的源文件" class="headerlink" title="修改可信代码编译的源文件"></a>修改可信代码编译的源文件</h3><p>同理，可信代码也可能是多个文件，最好在Encalve_Cpp_Files中包括Enclave文件夹中的所有cpp文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App_Cpp_Files := $(wildcard Enclave/*.cpp) $(wildcard Enclave/Edger8rSyntax/.cpp) $(wildcard Enclave/TrustedLibrary/*.cpp)</span><br></pre></td></tr></table></figure><h1 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h1><p>需要修改的文件包括Enclave.edl文件、Enclave.cpp文件、Enclave.h文件、App.cpp文件和makefile文件（已修改完成）。</p><h2 id="Enclave-edl文件修改"><a href="#Enclave-edl文件修改" class="headerlink" title="Enclave.edl文件修改"></a>Enclave.edl文件修改</h2><p>该文件中添加不可信代码调用可信函数的接口，也就是ECALL，添加到untrusted{}之前。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trusted&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printf_helloworld</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enclave-cpp文件修改"><a href="#Enclave-cpp文件修改" class="headerlink" title="Enclave.cpp文件修改"></a>Enclave.cpp文件修改</h2><p>该文件就是实现printf_helloworld函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_helloword</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enclave-h文件修改"><a href="#Enclave-h文件修改" class="headerlink" title="Enclave.h文件修改"></a>Enclave.h文件修改</h2><p>将printf_helloworld函数声明添加到Enclave.h文件中。添加到原先的printf函数的下方即可。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_helloworld</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="App-cpp文件修改"><a href="#App-cpp文件修改" class="headerlink" title="App.cpp文件修改"></a>App.cpp文件修改</h2><p>该文件中调用自定义的ECALL函数printf_helloworld，将下面的代码放到<code>sgx_destroy_enclave(global_eid);</code>之前。其中，global_eid是必须的，表示的是enclave的id。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf_helloworld(global_eid);</span><br></pre></td></tr></table></figure><h1 id="编译文件"><a href="#编译文件" class="headerlink" title="编译文件"></a>编译文件</h1><p>打开终端，进入文件夹中，首先<code>source ~/下载/sgxsdk/environment</code>将sgx sdk设置到环境变量中。而后，输入make进行编译。</p><h1 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h1><p>在终端输入./app，可以看到hello world，说明程序编写正确。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次实验是在虚拟机上配置好了Ubuntu16.04之后，在该系统上进行SGX实验。主要参照qiu_pengfei的blog&lt;a href=&quot;https://blog.csdn.net/qiu_pengfei/article/details/78798644&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu16.04下Intel SGX应用程序程序开发——打印Hello World！&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="SGX" scheme="http://yoursite.com/categories/SGX/"/>
    
    
      <category term="SGX" scheme="http://yoursite.com/tags/SGX/"/>
    
      <category term="实验" scheme="http://yoursite.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>阅读英文文献建议</title>
    <link href="http://yoursite.com/2019/08/01/%E9%98%85%E8%AF%BB%E8%8B%B1%E6%96%87%E6%96%87%E7%8C%AE%E5%BB%BA%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/08/01/阅读英文文献建议/</id>
    <published>2019-08-01T04:52:53.000Z</published>
    <updated>2019-08-01T05:02:32.619Z</updated>
    
    <content type="html"><![CDATA[<p>最近正在读老师建议的Intel SGX Explained，相当于对SGX的入门综述，100多页的全英文，读的脑阔疼，真~看了上句忘了下句….然后我就很困惑，我到底要怎么去读这本书，从知乎上了看了相关的经验后，总结如下。</p><a id="more"></a><h1 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h1><h2 id="如何阅读文献"><a href="#如何阅读文献" class="headerlink" title="如何阅读文献"></a>如何阅读文献</h2><ul><li><p>注重摘要</p></li><li><p>确立句子的架构</p></li><li><p>增加阅读量</p></li></ul><h2 id="如何提高阅读的效率"><a href="#如何提高阅读的效率" class="headerlink" title="如何提高阅读的效率"></a>如何提高阅读的效率</h2><ul><li><p>集中时间看文献</p></li><li><p>做好标记和记录</p></li></ul><h1 id="三步走方法"><a href="#三步走方法" class="headerlink" title="三步走方法"></a>三步走方法</h1><p>三步走方法参考的是滑铁卢大学教授的paper<a href="http://ccr.sigcomm.org/online/files/p83-keshavA.pdf" target="_blank" rel="noopener">How to Read a Paper</a>，写的非常有意思，而且易懂。</p><h2 id="first-pass"><a href="#first-pass" class="headerlink" title="first pass"></a>first pass</h2><p>first pass主要强调的是”get a bird’s-eye view”，快速地扫一遍</p><h3 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h3><blockquote><p>认真读标题、摘要和介绍(introduction)<br>读标题和子标题，忽略其他一切<br>过一遍(glance)公式<br>阅读结论<br>扫一遍参考文献，在心中标记处已经读过</p></blockquote><h3 id="需要回到的five-Cs"><a href="#需要回到的five-Cs" class="headerlink" title="需要回到的five Cs"></a>需要回到的five Cs</h3><blockquote><p>种类(category)：这篇paper是那种类型的？<br>内容(Context)：这篇文章与哪些文章有关联？哪些理论基础会被用来分析这个问题？<br>这些假设是否是有依据的？<br>这篇论文的主要贡献是什么？<br>这篇文章写得好吗？</p></blockquote><h2 id="second-pass"><a href="#second-pass" class="headerlink" title="second pass"></a>second pass</h2><p>第二步需要更好的耐心来看，但同时也需要忽略诸如证明之类的细节。本部分能够帮助记下key points（核心点），并在空白处记下评论。</p><blockquote><p>仔细看图表、图片以及论文中的其他的说明。<br>记得要去标注相关的未读过的参考文献for further reading</p></blockquote><h2 id="third-pass"><a href="#third-pass" class="headerlink" title="third pass"></a>third pass</h2><p><strong>复现论文</strong>  </p><p>在这一步，需要考虑的是我们自己应该如何定义或者挑战假设，更多的是，我们需要考虑自己如何提出一个特别的idea。在这一部分，我们需要记下敢于未来干工作的想法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近正在读老师建议的Intel SGX Explained，相当于对SGX的入门综述，100多页的全英文，读的脑阔疼，真~看了上句忘了下句….然后我就很困惑，我到底要怎么去读这本书，从知乎上了看了相关的经验后，总结如下。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="英语" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="读后感" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>intel sgx explained阅读笔记</title>
    <link href="http://yoursite.com/2019/07/31/intel-sgx-explained%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/31/intel-sgx-explained阅读笔记/</id>
    <published>2019-07-31T08:17:08.000Z</published>
    <updated>2019-08-02T07:50:17.763Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要是对SGX经典入门综述intel SGX Explained这本书的阅读笔记。</p><p>希望能够坚持下来，在这个过程中得到从英语和知识水平两个方面的提高。  </p><a id="more"></a><h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p>之前看的时候还很不连贯，会在最后第2,5章全部读完时再回头重新读一遍时，再进行相关的记录。</p><h1 id="computer-architecture-background"><a href="#computer-architecture-background" class="headerlink" title="computer architecture background"></a>computer architecture background</h1><p>本部分主要是对intel目前最为流行的计算机处理器背后的总体架构进行概括，以及运行在这些处理器上的系统所需要的安全特性。</p><h2 id="overview-1"><a href="#overview-1" class="headerlink" title="overview"></a>overview</h2><p>同样等第二章全部读完之后再进行阅读。</p><h2 id="computational-model"><a href="#computational-model" class="headerlink" title="computational model"></a>computational model</h2><p>本部分呈现了一个实现了intel架构的高度简化的计算机模型。</p><p>内存是存储单元的数组，使用从0开始的自然数来进行地址标记。它的一个显著特征就是<strong>即将读取的内存单元的地址等于最近的写入的地址单元的值</strong>。</p><p>RIP和RSP</p><blockquote><p>RIP(instruction pointer)指令指针，保存着即将被处理器执行的下一条指令的内存地址<br>RSP(stack pointer)堆栈指针，保存堆栈中最顶层元素的内存地址  </p></blockquote><p>和许多常见的RISC架构不同，intel架构采用的是可变大小的指令编码，所以当且仅当指令被读取到内存中，才能知道指令长度。</p><p>在指令的先决条件没有得到满足的情况下，就会导致出现错误(fault)。当一条指令导致故障时，处理器会停止下正常的执行流，转而执行故障处理程序。简而言之，处理器首先会根据故障的性质查找能够处理故障的代码地址，而后为处理该故障准备执行环境。</p><p>处理器之间或与内存是通过系统总线进行通信的，这之间构成了一个广播网络。<br>&nbsp;</p><p><img src="/intel-sgx-explained%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-1/system-bus-abstraction.png" alt="system-bus-abstraction"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要是对SGX经典入门综述intel SGX Explained这本书的阅读笔记。&lt;/p&gt;
&lt;p&gt;希望能够坚持下来，在这个过程中得到从英语和知识水平两个方面的提高。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="SGX" scheme="http://yoursite.com/tags/SGX/"/>
    
  </entry>
  
  <entry>
    <title>SGX官方视频笔记</title>
    <link href="http://yoursite.com/2019/07/31/sgx%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/31/sgx笔记/</id>
    <published>2019-07-31T05:23:58.000Z</published>
    <updated>2019-08-01T05:02:32.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="intel-sgx笔记"><a href="#intel-sgx笔记" class="headerlink" title="intel sgx笔记"></a>intel sgx笔记</h1><p>intel sgx是使得程序能够在可信的环境下执行代码并保护机密信息，从而让开发者直接控制程序的安全性。<br>intel sgx在内存中划定了名为安全区（enclave）的隔离区域，用来存放代码和数据。</p><a id="more"></a><h2 id="features-and-benefits"><a href="#features-and-benefits" class="headerlink" title="features and benefits"></a>features and benefits</h2><ul><li>这些不可寻址的分页内存是从系统的物理内存中保留的，并且经过了加密；</li><li>安全区是受保护的内存区域，应用程序可以在里面处理它的机密数据而不必担心泄露；</li></ul><p>包含intel SGX技术的应用程序分为两个部分，分别是可信部分和不可信部分。当应用程序需要处理机密时，会创建一个位于可信内存的安全区，然后调用可信函数。可信函数是由开发者创建的，专门在安全区内执行的函数。一旦这个函数被调用，应用程序就会在可信区域执行，并且明文访问安全区内的代码和数据。而试图从安全区之外的地方访问安全区内存的行为都会被处理器拒绝，即使是系统特权用户的行为。</p><p>当可信函数执行完毕之后，安全区的数据依然会保留在可信内存中，而应用程序返回到不可信区域继续执行，并且失去了对可信内存的访问权限。</p><h2 id="检测和开启intel-SGX"><a href="#检测和开启intel-SGX" class="headerlink" title="检测和开启intel SGX"></a>检测和开启intel SGX</h2><p>应用程序可以使用intel SGX的四个条件</p><blockquote><p>CPU必须支持intel SGX的指令<br>BIOS必须支持intel SGX<br>必须在BIOS设置中开启intel SGX<br>必须安装intel SGX PSW</p></blockquote><p>BIOS设置中intel SGX可能的三种选项是启用、禁用以及软件控制</p><blockquote><p>“启用”：严格开启了intel SGX<br>“禁用”：严格关闭了intel SGX<br>“软件控制”：允许包含intel SGX技术的应用程序在系统重启后启用intel SGX  </p></blockquote><p>安装程序时检查的步骤：</p><blockquote><p>检查CPU和BIOS是否支持intel SGX<br>检查intel SGX PSW是否安装，如果没有安装，就安装<br>检查intel SGX是否在BIOS中开启，如果没有开启，则用软件控制开启</p></blockquote><p>应用程序本身的检查</p><blockquote><p>检查intel SGX PSW是否安装<br>检查SGX是否可用，如果不可用，则使其变为启用</p></blockquote><p>如果上述步骤中的任一步骤失败，则说明系统不支持intel SGX。</p><h2 id="如何设计intel-SGX应用程序"><a href="#如何设计intel-SGX应用程序" class="headerlink" title="如何设计intel SGX应用程序"></a>如何设计intel SGX应用程序</h2><p>所有的intel SGX应用程序都有相同的基本结构，也就是他们在设计时都要遵循一些通用的原则。intel SGX应用程序分成两个部分，可信部分和不可信部分。</p><p>应用程序的可信部分由它的安全区（enclaves）组成，一个应用程序可以拥有一个或多个安全区。安全区存储在加密的内存中，并受intel SGX的保护。安全区是可信的，它们一旦被建立就不能被篡改。如果安全区的数据被恶意篡改，就会被CPU检测到，并不会被加载。</p><p>可信部分之外的被称为非可信部分，也就是不会被intel SGX保护的应用程序或内存区域。</p><p>如果我们需要设计一个intel SGX程序，就需要将程序分成两个不同的部分，需要判断哪些代码应该放在安全区，哪些代码应该放在安全区之外以及可信部分和非可信部分的交互。</p><p>划分代码的关键步骤：</p><ul><li>确定机密信息  </li><li>确定机密数据的提供者和使用者(画出机密数据在应用程序中的各个组件的流程图，也就是机密数据的来源和去向)  </li><li>确定安全边界(划定边界时，需要尽量包含尽可能多的机密数据，并最大限度地减少与非信任代码的交互)  </li><li>精简安全区的代码<br>在为安全区以及它的接口编写代码时需要记住：<blockquote><p>单一系统中，用于运行所有安全区的内存容量是固定的。    </p></blockquote></li></ul><p>安全区的体积应该尽可能地小。当不再需要机密数据时，安全区应该被销毁。  </p><blockquote><p>进出安全区的调用会产生性能损失，就和CPU上下文切换一样。 </p></blockquote><p>通过一次调用完成大量工作，会比分成多次调用来完成等量的工作更有效率。</p><h2 id="安全区定义语言（EDL）"><a href="#安全区定义语言（EDL）" class="headerlink" title="安全区定义语言（EDL）"></a>安全区定义语言（EDL）</h2><p>intel SGX提供的基本保护措施是安全区的机密数据仅能够被安全区内的代码访问。执行安全区内的代码的唯一方式是通过开发人员创建的接口函数。</p><p>每个安全区可以定义一个或多个e-call，e-call是非可信应用程序进入安全区的入口点；安全区也可以定义o-call，o-call使得安全函数可以调用外部的非可信应用程序，而后再返回安全区。ECALL和OCALL共同组成了安全区的接口，这些函数并非由非可信应用程序执行。</p><p>处理器对安全区出入口的访问严格控制，同时为了完成出入安全区的转换，必须依序执行特定的CPU指令。</p><p>intel SGX SDK把这些底层细节做了抽象，从而让软件开发者可以用熟悉的编程环境进行开发，名为Edger8r的特殊工具会自动为E-CALL和O-CALL生成代理函数，从而应用程序就可以像调用其他C语言函数一样调用它。</p><p>Edger8r从EDL文件中读取安全区接口的定义来创建代理函数。</p><p>安全区定义语言(enclave definition language,EDL)，EDL文件和声明函数原型的C语言风格的头文件十分相似。</p><p>EDL文件由可信区和非可信区组成。E-CALL定义在可信区，而O-CALL定义在非可信区。这些函数原型与C非常相似，但还需要一些额外的关键字。<br>所有能够被非可信程序调用的E-CALL都必须声明为public，每个安全区都至少有一个声明为public的E-CALL，不含public关键字的E-CALL只能被另一个O-CALL执行。</p><p>在进行E-CALL或O-CALL调用时，函数参数要从非可信内存和可信内存之间进行封送处理。若函数参数是值传递，对应的封送处理就是单向的。在E-CALL或O-CALL内部进行的更改不会反映到被调用的函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enclave&#123;</span><br><span class="line">    from <span class="string">"sgx_tstdc.edl"</span> <span class="keyword">import</span> *;</span><br><span class="line">    trusted&#123;</span><br><span class="line">        <span class="comment">/*define ECALLs here. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ecall_private</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    untrusted&#123;</span><br><span class="line">        <span class="comment">/*define OCALLs here. */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">an_ocall</span><span class="params">(<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果函数参数时引用传递，就必须完整地描述数据的封送处理过程，每个指针或参数之前必须有方括号来描述封送处理的方向以及封送处理的元素数量</p><p>in关键字表示数据需要封送到E-CALL或O-CALL之内，而如果是out关键字则意味着数据需要从E-CALL或O-CALL封送回调用的函数。如果需要out，则需要在调用E-CALL或O-CALL之前分配好数据的缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in] <span class="keyword">int32_t</span> *value)</span></span>;</span><br></pre></td></tr></table></figure><p>如果同时指定了in和out关键字，意味着要进行两个方向的封送处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,out] <span class="keyword">int32_t</span> *value)</span></span></span><br></pre></td></tr></table></figure><p>在缺省情况下，Edger8r假定数据的缓冲区大小等于参数的sizeof。如果指针指向的是一个数组，那么需要提供count参数来指定需要复制的元素个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,count=<span class="number">10</span>] <span class="keyword">int32_t</span> *<span class="built_in">array</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如果参数的个数要等到运行的时候才能确定，也可以用另一个函数参数来表示个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,count=len] <span class="keyword">int32_t</span> *<span class="built_in">array</span>,<span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>如果使用in关键字封送一个以’\0’作为终止符的字符串，可以选择使用string或者是wstring来代替count关键字，string或wstring不能和out关键字一起使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,<span class="built_in">string</span>] <span class="keyword">int32_t</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_wecall</span><span class="params">([in,wstring] <span class="keyword">wchar_t</span> *unicodename)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="EDL语言的进阶主题"><a href="#EDL语言的进阶主题" class="headerlink" title="EDL语言的进阶主题"></a>EDL语言的进阶主题</h2><p>有时需要把void指针传给E-CALL或O-CALL，问题在于边界例程无法知道void类型对应的大小，无法计算封送处理需要的数据缓冲区大小。为了解决这个问题，EDL语法提供了size关键字，通过指定单个元素的大小，边界例程就知道需要拷贝多少数据。在下面的例子中，32个8字节数据将会被封送到E-CALL中。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,count=<span class="number">32</span>,size=<span class="number">8</span>] <span class="keyword">void</span> *buffer)</span></span></span><br></pre></td></tr></table></figure><p>在不希望封送完整的数据缓冲区时，仅仅希望把指针指向的地址传给E-CALL或O-CALL，这可以通过user_check关键字来完成。这样行为传递的指针不进行边界例程的安全检查和数据封送处理，E-CALL和O-CALL将会直接作用于指针的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([user_check] <span class="keyword">void</span> *buff)</span></span>;</span><br></pre></td></tr></table></figure><p>只有被声明为public的E-CALL可以被不安全的函数调用，被称之为root E-CALL，由EDL文件中使用的public关键字指定，不含public关键字的E-CALL只能被另一个O-CALL调用，但是，在缺省情况下，O-CALL不能调用任何E-CALL，必须通过allow关键字声明该O-CALL可以调用哪些E-CALL,allow后面跟着允许的E-CALL名称列表。在本例中，O-CALL get_msg_block()只能调用E-CALL update_hash()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enclave&#123;</span><br><span class="line">    from <span class="string">"sgx_tstdc.edi"</span> <span class="keyword">import</span> *;</span><br><span class="line">    trusted&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init_hash</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_hash</span><span class="params">([out] <span class="keyword">char</span> hash[<span class="number">32</span>])</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">update_hash</span><span class="params">([in,count=len],<span class="keyword">char</span> *block,<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    untrusted&#123;</span><br><span class="line">        <span class="keyword">size_t</span> get_msg_block() allow(updata_hash);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试intel-SGX应用程序"><a href="#调试intel-SGX应用程序" class="headerlink" title="调试intel SGX应用程序"></a>调试intel SGX应用程序</h2><p>intel SGX安全区可以以debug模式或release模式构建。</p><ul><li>debug模式<blockquote><p>debug模式下的安全区是可以调试的；<br>可以使用intel SGX调试器附加到上面；<br>查看当前的状态；<br>以及对代码进行逐句调试，就和调试其他程序一样  </p></blockquote></li></ul><p>当在调试intel SGX应用程序时，它很有可能是以debug模式构建的，CPU允许运行任何以debug模式构建的安全区，由于您可以用intel SGX调试器附到安全区上，这些安全区显然是不安全的，所以<strong>永远不要在生产环境上部署以debug模式构建的安全区</strong></p><ul><li>release模式</li></ul><p>release模式构建的安全区无论如何也无法进行调试，CPU严格执行这条限制。对于intel SGX安全区的调试，仍然需要相关的CPU指令支持，这就意味着必须使用随intel SGX SDK安装的intel SGX调试器进行调试，而其他的调试器只会跳过安全区的代码。</p><h2 id="intel-SGX的数据密封功能"><a href="#intel-SGX的数据密封功能" class="headerlink" title="intel SGX的数据密封功能"></a>intel SGX的数据密封功能</h2><p>intel SGX应用程序也有可能需要把机密数据保存到安全区以外。安全区从本质上来说是无状态的：</p><blockquote><p>当电脑进入睡眠、关机或者应用程序退出时，安全区就会被销毁；<br>应用程序显示将其销毁时，安全区也会被销毁，当安全区被销毁后，其中的所有内容都会丢失。</p></blockquote><p>为了持久保存安全区内存储的数据，必须显式地将其发送到安全区以外的非可信内存中。由于不可信内存是不可信的，所以系统为数据提供密封功能。当数据被密封时，数据在安全区内用密钥加密，这个密钥是直接从CPU中取得的。加密的数据块被称为密封的数据，它只能在创建的电脑上进行解密。</p><p>密封数据时可以选择的密钥策略有两种：</p><ul><li>安全区标识(MRENCLAVE)  </li></ul><p>安全区标识策略生成一个该安全区独有的密钥，这就意味着只有同一台电脑的同一个安全区可以解封数据</p><ul><li>密封标识(MRSIGNER)  </li></ul><p>密封标识基于安全区密封授权方的密钥生成一个密钥，这使得一个安全区密封的数据可被另一个安全区解封。只要是同一台电脑，而且软件是由相同开发商开发（密封授权方的密钥相同）即可。该策略可以允许数据被新版应用程序或其他构建版本的应用程序所读取。该方法可以在两个不同的应用程序的两个不同的安全区中共享数据。</p><p>这两种策略的相同点是密封数据的电脑的指纹是密钥的一个输入，这就意味着如果密封的数据被复制到了另一台电脑上就无法被解封。</p><p>密钥的另一个输入是安全区的debug模式或release模式，debug的安全区无法解封release模式的安全区密封的数据，反之亦然。这项安全机制是用于防止intel SGX调试器在调试debug的安全区时，泄露来自release模式的安全区的数据。</p><p>注意，密封数据可能具有非常严重的安全隐患：<strong>安全区并不会检验非可信应用程序的真实性，绝不能假设只有自己的应用程序能加载安全区或者说E-CALL一定会按照预期的顺序执行！</strong> 任何人都可以加载安全区，并按照他们希望的顺序执行E-CALL。安全区API绝不能因为密封数据和解封数据而泄露了机密或授予了不该授予的权限。</p><p>总而言之，密封数据的功能是为了安全地把机密数据导出到安全区以外，并确保这些机密数据不会被篡改、替换、窃听或者是在解封数据时，被复制到另一台电脑上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;intel-sgx笔记&quot;&gt;&lt;a href=&quot;#intel-sgx笔记&quot; class=&quot;headerlink&quot; title=&quot;intel sgx笔记&quot;&gt;&lt;/a&gt;intel sgx笔记&lt;/h1&gt;&lt;p&gt;intel sgx是使得程序能够在可信的环境下执行代码并保护机密信息，从而让开发者直接控制程序的安全性。&lt;br&gt;intel sgx在内存中划定了名为安全区（enclave）的隔离区域，用来存放代码和数据。&lt;/p&gt;
    
    </summary>
    
      <category term="SGX" scheme="http://yoursite.com/categories/SGX/"/>
    
    
      <category term="SGX" scheme="http://yoursite.com/tags/SGX/"/>
    
  </entry>
  
</feed>
