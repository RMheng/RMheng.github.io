<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rww&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/875500b7339ad8bf5d54b6a28209fad0</icon>
  <subtitle>半夏花已开，未来诚可期</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-19T07:48:26.203Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rmheng</name>
    <email>2961930359@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python使用hahslib</title>
    <link href="http://yoursite.com/2020/04/19/python%E4%BD%BF%E7%94%A8hahslib/"/>
    <id>http://yoursite.com/2020/04/19/python使用hahslib/</id>
    <published>2020-04-19T06:23:34.000Z</published>
    <updated>2020-04-19T07:48:26.203Z</updated>
    
    <content type="html"><![CDATA[<p>python调用AES-GCM库</p><a id="more"></a><p>毕设中需要一个文件加密的步骤，本来是打算随便找个库来加密解密就好了，但是导师建议使用AES-GCM，阅读了有关文献，GCM模式能够进行身份验证，相对来说比较推荐。</p><p>开始考虑的还是希望直接调用已有的库比如openssl，就比较方便嘛，但是openssl不支持对AES-GCM模式的命令行调用。但是openssl中是有GCM的头文件的，但是C处理文件实在太麻烦了。。所以还是选择了python吧。</p><p>python中有个库cryptemis是可以对图片文件进行AES加密处理的，但是看代码用的模式是AES-CFB。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aes_cipher = AES.new(key, AES.MODE_CFB, iv)</span><br></pre></td></tr></table></figure><p>git clone下来之后把mode改成了GCM也得到了预期的效果。但是在两个容器中配置的过程比较繁琐，这里记录一下。</p><p>python3中AES相关的库是pycryptodome，python2中是pycryptodom。<br>这里调用了hashlib库是为了获得相对来说更乱序的iv值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key = hl.sha3_512(hl.sha1(password.encode()).hexdigest().encode()).hexdigest()[:AES.block_size].encode()</span><br><span class="line">iv = hl.sha3_512(hl.blake2s(password.encode()).hexdigest().encode()).hexdigest()[:AES.block_size].encode()</span><br></pre></td></tr></table></figure><p>直接测试的时候发现出现了下述错误</p><blockquote><p>AttributeError: module ‘hashlib’ has no attribute ‘blake2b’</p></blockquote><p>直接百度或者google的时候都说是自己的文件名与导入的报名撞了，但这里并没有呀。而且在我电脑上的环境上跑的很顺畅。hashlib是python内建模块，它的版本与python挂钩，我windows上的python是3.7，而服务器中的是2.7，大概率是版本问题。通过dir(hashlib)查看了一下，确实没有相应的函数，那么接下来就是升级python了。hashlib的官方文档中说3.6中升级有了blake2b，也就是说只需要升级到3.6及以上即可。</p><p>安装python3.7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install python3.7</span><br><span class="line">python3.7 –version</span><br></pre></td></tr></table></figure><p>将python3的链接指向python3.7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /usr/bin/python3</span><br><span class="line">sudo rm -rf /usr/bin/pip3</span><br></pre></td></tr></table></figure><p>添加python3的软链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/python3.7 /usr/bin/python3</span><br></pre></td></tr></table></figure><p>安装pip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">python3 get-pip.py   //运行安装脚本</span><br></pre></td></tr></table></figure><p>添加pip3的软链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/pip3.7 /usr/bin/pip3</span><br></pre></td></tr></table></figure><p>然后就可以依次安装numpy包、pillow包、pycryptodome包。</p><p>参考文献</p><ul><li>(encryption-如何选择AES加密模式)[<a href="https://kb.kutu66.com/encryption/post_131657]" target="_blank" rel="noopener">https://kb.kutu66.com/encryption/post_131657]</a></li><li>(cryptemis)[<a href="https://github.com/0x01h/cryptemis]" target="_blank" rel="noopener">https://github.com/0x01h/cryptemis]</a></li><li>(下载python3.7)[<a href="https://www.digitalocean.com/community/questions/unable-to-install-pyhton-3-7-version-on-ubuntu-16-04-error-couldn-t-find-any-package-by-regex-python3-7]" target="_blank" rel="noopener">https://www.digitalocean.com/community/questions/unable-to-install-pyhton-3-7-version-on-ubuntu-16-04-error-couldn-t-find-any-package-by-regex-python3-7]</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python调用AES-GCM库&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>NVDLA学习</title>
    <link href="http://yoursite.com/2019/12/29/NVDLA%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/12/29/NVDLA学习/</id>
    <published>2019-12-29T14:17:15.000Z</published>
    <updated>2020-04-19T07:45:05.055Z</updated>
    
    <content type="html"><![CDATA[<p>毕设要用NVDLA，在这里记录一下NVDLA的安装过程和学习。</p><a id="more"></a><h1 id="NVDLA-Virtual-Simulator"><a href="#NVDLA-Virtual-Simulator" class="headerlink" title="NVDLA Virtual Simulator"></a>NVDLA Virtual Simulator</h1><p>NVDLA的安装文档写的很详细，但已经是2017年写的，很长时间没更新，而且对很多工具的版本要求都很emm怀旧，安装的时候还是遇到几个问题。NVDLA也可以直接运用docker版本的，但直接用原代码编译能加强对NVDLA整体的理解嘛（虽然我编译完根本不知道发生了啥:(）</p><p>NVDLA Open Source Project中主要有四个文件夹。</p><ul><li><p>doc<br>Docunmentation for NVDLA</p></li><li><p>hw<br>RTL, Cmodel and testbench for NVDLA</p></li><li><p>sw<br>NVDLA SW</p></li><li><p>vp<br>Virtual Platform for NVDLA</p></li></ul><h2 id="下载Virtual-Simulator"><a href="#下载Virtual-Simulator" class="headerlink" title="下载Virtual Simulator"></a>下载Virtual Simulator</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nvdla/vp.git  </span><br><span class="line">cd vp  </span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><h3 id="install-required-tools-and-libraries"><a href="#install-required-tools-and-libraries" class="headerlink" title="install required tools and libraries"></a>install required tools and libraries</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install g++ cmake libboost-dev python-dev libglib2.0-dev libpixman-1-dev liblua5.2-dev swig libcap-dev libattr1-dev</span><br></pre></td></tr></table></figure><h3 id="install-SystemC-2-3-0"><a href="#install-SystemC-2-3-0" class="headerlink" title="install SystemC 2.3.0"></a>install SystemC 2.3.0</h3><p>这里需要注意的是必须用的systemC 2.3.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget -O systemc-2.3.0a.tar.gz http://www.accellera.org/images/downloads/standards/systemc/systemc-2.3.0a.tar.gz</span><br><span class="line">tar -xzvf systemc-2.3.0a.tar.gz</span><br><span class="line">cd systemc-2.3.0a</span><br><span class="line">sudo mkdir -p /usr/local/systemc-2.3.0/</span><br><span class="line">mkdir objdir</span><br><span class="line">cd objdir</span><br><span class="line">../configure --prefix=/usr/local/systemc-2.3.0</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="install-perl-package-required"><a href="#install-perl-package-required" class="headerlink" title="install perl package required"></a>install perl package required</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wget -O YAML-1.24.tar.gz http://search.cpan.org/CPAN/authors/id/T/TI/TINITA/YAML-1.24.tar.gz</span><br><span class="line">tar -xzvf YAML-1.24.tar.gz</span><br><span class="line">cd YAML-1.24</span><br><span class="line">perl Makefile.PL</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">wget -O IO-Tee-0.65.tar.gz http://search.cpan.org/CPAN/authors/id/N/NE/NEILB/IO-Tee-0.65.tar.gz</span><br><span class="line">tar -xzvf IO-Tee-0.65.tar.gz</span><br><span class="line">cd IO-Tee-0.65</span><br><span class="line">perl Makefile.PL</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="install-NVDLA-CMOD"><a href="#install-NVDLA-CMOD" class="headerlink" title="install NVDLA CMOD"></a>install NVDLA CMOD</h3><p>CMOD安装需要保证环境配置得当，我的环境配置版本与readme中略有不同。</p><ul><li>java -jdk1.8</li><li>Perl</li><li>CPP</li><li>python</li><li>System -systemc-2.3.0</li><li>[for Verilator builds] Verilator-Verilator</li><li>[for Verilator builds] clang-clang </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nvdla/hw.git</span><br><span class="line">cd hw</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>这一步执行完毕后需要按照提示输入对应的工具路径，这里我的工具路径如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_CPP:=/usr/bin/cpp</span><br><span class="line">DEFAULT_GCC:=/usr/bin/g++</span><br><span class="line">DEFAULT_PERL:=/usr/bin/perl</span><br><span class="line">DEFAULT_JAVA:=/usr/bin/java</span><br><span class="line">DEFAULT_SYSTEMC:=~/systemc-2.3.0</span><br><span class="line">DEFAULT_VERILATOR:=verilator</span><br><span class="line">DEFAULT_CLANG:=clang</span><br><span class="line">DEFAULT_PROJ:=nv_small</span><br></pre></td></tr></table></figure><p>make执行完毕后再输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tools/bin/tmake -build cmod_top</span><br></pre></td></tr></table></figure><h2 id="Build-and-Install-the-Virtual-Simulator"><a href="#Build-and-Install-the-Virtual-Simulator" class="headerlink" title="Build and Install the Virtual Simulator"></a>Build and Install the Virtual Simulator</h2><h3 id="Cmake-build-under-the-vp-repository-directory"><a href="#Cmake-build-under-the-vp-repository-directory" class="headerlink" title="Cmake build under the vp repository directory"></a>Cmake build under the vp repository directory</h3><p>build/是希望安装virtual simulator的位置，/usr/local/systemC是SystemC的安装目录，~/hw是本地NVDLA HW仓库的位置，nv_small是NVDLA HW project name.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=build/ -DSYSTEMC_PREFIX=~/usr/local/systemc-2.3.0/ -DNVDLA_HW_PREFIX=~/hw -DNVDLA_HW_PROJECT=nv_small</span><br></pre></td></tr></table></figure><h3 id="Compile-and-install"><a href="#Compile-and-install" class="headerlink" title="Compile and install"></a>Compile and install</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd vp/</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>编译vp中遇到了很多问题，里面直接导致无法运行的是这个</p><blockquote><p>/usr/local/systemc-2.3.0/include/sysc/packages/boost/get_pointer.hpp:21:40: error: ‘template<class> class std::auto_ptr’ is deprecated [-Werror=deprecated-declarations]<br> template<class t> T * get_pointer(std::auto_ptr<t> const&amp; p)</t></class></class></p></blockquote><p>产生的主要原因issue上的作者说是gcc版本应该用4.8的，后来在网上查到了不用修改gcc版本就可以成功编译的方法。<br><strong>修改vp/CMakeLists.txt</strong>(参考网址：<a href="https://blog.csdn.net/hywCogost/article/details/82114529" target="_blank" rel="noopener">https://blog.csdn.net/hywCogost/article/details/82114529</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 注释掉以下三行</span><br><span class="line"># set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -DSC_INCLUDE_DYNAMIC_PROCESSES -Wall -Werror $&#123;AWS_FPGA_CFLAGS&#125; $&#123;TRACE_CFLAGS&#125;&quot;)</span><br><span class="line"># set(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -DSC_INCLUDE_DYNAMIC_PROCESSES -Wall -Werror -DDEBUG_LOG=1 $&#123;AWS_FPGA_CFLAGS&#125; $&#123;TRACE_CFLAGS&#125;&quot;)</span><br><span class="line"># set(CMAKE_CXX_FLAGS_RELEASE &quot;$&#123;CMAKE_CXX_FLAGS_RELEASE&#125; -DSC_INCLUDE_DYNAMIC_PROCESSES -Wall -Werror $&#123;AWS_FPGA_CFLAGS&#125; $&#123;TRACE_CFLAGS&#125;&quot;)</span><br><span class="line"># 添加如下：</span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -DSC_INCLUDE_DYNAMIC_PROCESSES -Wall  $&#123;AWS_FPGA_CFLAGS&#125; $&#123;TRACE_CFLAGS&#125;&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -DSC_INCLUDE_DYNAMIC_PROCESSES -Wall  -DDEBUG_LOG=1 $&#123;AWS_FPGA_CFLAGS&#125; $&#123;TRACE_CFLAGS&#125;&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS_RELEASE &quot;$&#123;CMAKE_CXX_FLAGS_RELEASE&#125; -DSC_INCLUDE_DYNAMIC_PROCESSES -Wall  $&#123;AWS_FPGA_CFLAGS&#125; $&#123;TRACE_CFLAGS&#125;&quot;)</span><br></pre></td></tr></table></figure><p>也就是将这三条语句中的Werror去掉，同样的操作还要将子目录下CMakeList.txt中的CMake_CXX_FLAGS语句中国的-Werror删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./models/nvdla/CMakeLists.txt +87</span><br><span class="line">./models/nvdla/CMakeLists.txt +88</span><br><span class="line">./models/nvdla/CMakeLists.txt +89</span><br><span class="line"></span><br><span class="line">./fpga/aws-fpga/fpga_sc_wrapper/CMakeLists.txt +91</span><br><span class="line">./fpga/aws-fpga/fpga_sc_wrapper/CMakeLists.txt +92</span><br><span class="line">./fpga/aws-fpga/fpga_sc_wrapper/CMakeLists.txt +93</span><br><span class="line"></span><br><span class="line">./fpga/aws-fpga/cosim_sc_wrapper/CMakeLists.txt +82</span><br><span class="line">./fpga/aws-fpga/cosim_sc_wrapper/CMakeLists.txt +83</span><br><span class="line">./fpga/aws-fpga/cosim_sc_wrapper/CMakeLists.txt +84</span><br></pre></td></tr></table></figure><h2 id="Running-the-Virtual-Simulator"><a href="#Running-the-Virtual-Simulator" class="headerlink" title="Running the Virtual Simulator"></a>Running the Virtual Simulator</h2><p>要运行virtual simulator首先要准备好linux kernel image，可以自己手动编译或者直接用NVDLA项目中已经编译好的image。我因为开始的一个智障报错把两个都试了一遍。用NVDLA中已经编译好的image比较省事且快，但文档中说的不是很清楚，但在这个<a href="https://github.com/nvdla/vp/issues/1" target="_blank" rel="noopener">issue</a>解释清楚了。</p><p>我就简单说一下里面没有提到的部分，就是修改aarcha64_nvdla.lua中的kernel和driver的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-kernel /path/to/sw/prebuilt/arm64-linux/image/linux/Image</span><br><span class="line">-driver /path/to/sw/prebuilt/arm64-linux/image/linux/rootfs.ext4</span><br></pre></td></tr></table></figure><p>以下来简单说一下手动交叉编译一个linux内核的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://buildroot.org/downloads/buildroot-2017.11.tar.gz</span><br><span class="line">tar -zxvf buildroot-2017.11.tar.gz</span><br><span class="line">cd buildroot-2017.11/</span><br><span class="line">sudo apt-get install libncurses5-dev // make menuconfig时会用到</span><br><span class="line">make qemu_aarch64_virt_defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>需要自定义的配置如下：</p><blockquote><ul><li>Target Options -&gt; Target Architecture -&gt; AArch64 (little endian)  </li><li>Target Options -&gt; Target Architecture Variant -&gt; cortex-A57  </li><li>Toolchain -&gt; Custom kernel headers series -&gt; 4.13.x  </li><li>Toolchain -&gt; Toolchain type -&gt; External toolchain    </li><li>Toolchain -&gt; Toolchain -&gt; Linaro AArch64 2017.08  </li><li>Toolchain -&gt; Toolchain origin -&gt; Toolchain to be downloaded and installed  </li><li>Kernel -&gt; () Kernel version -&gt; 4.13.3  </li><li>Kernel -&gt; Kernel configuration -&gt; Use the architecture default configuration  </li><li>System configuration -&gt; Enable root login with password -&gt; Y  </li><li>System configuration -&gt; Root password -&gt; nvdla  </li><li>Target Packages -&gt; Show packages that are also provided by busybox -&gt; Y  </li><li>Target Packages -&gt; Networking applications -&gt; openssh -&gt; Y<br>最后，编译</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure><h3 id="Running-Kernel-Image-in-the-Virtual-Simulator"><a href="#Running-Kernel-Image-in-the-Virtual-Simulator" class="headerlink" title="Running Kernel Image in the Virtual Simulator"></a>Running Kernel Image in the Virtual Simulator</h3><p>在运行之前，需要修改conf/aarch64_nvdla.lua中的路径信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-driver ~/vp/buildroot-2017.11/output/images/rootfs.ext4</span><br><span class="line">-kernel ~/vp/buildroor-2017.11/output/images/Images</span><br></pre></td></tr></table></figure><p>接下来，就可以运行文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export SC_SIGNAL_WRITE_CHECK=DISABLE</span><br><span class="line">./build/bin/aarch64_toplevel -c conf/aarch64_nvdla.lua</span><br><span class="line">``` </span><br><span class="line">然后我又遇到了这个问题</span><br><span class="line">&gt; Could not set up host forwarding rule &apos;tcp::6666-:6666&apos;</span><br><span class="line"></span><br><span class="line">针对这个问题，我直接把lua文件中的`tcp::6666-:6666`这段给删了，接下来运行未发生报错。</span><br></pre></td></tr></table></figure><p>mount -t 9p -o trans=virtio r /mnt<br>cd /mnt/tests/hello<br>./aarch64_hello</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">运行成功，没有报错。</span><br><span class="line"></span><br><span class="line"># NVDLA documentation</span><br><span class="line">NVDLA在accelerate deep learning 中起到的是inference的作用，也就是一个网络已经训练好了，需要做实际应用了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># nvdla vp模拟推断</span><br><span class="line">nvdla的文档真的太少了。。。官方文档给了就跟没给一样，开发过程完全靠issue上一起摸着石头过河的人的提问。。。这里还是要感谢导师和学长的帮助。</span><br><span class="line"></span><br><span class="line">NVDLA在virtual platform上应该只能进行inference的操作，并且会很慢。nvdla_compiler是编译器，将caffe网络文件编译成NVDLA可读的nvdla文件，也就是最后生成的fast-math.nvdla。</span><br><span class="line"></span><br><span class="line">## 编译</span><br><span class="line">命令</span><br></pre></td></tr></table></figure><p>./nvdla_compiler –profile fast-math –configtarget nv_small –cprecision int8 –prototxt models/deep-residual-networks/prototxt/ResNet-50-deploy.prototxt –caffemodel ResNet-50-model.caffemodel –informat nchw –calibtable resnet50.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ `--profile`：编译生成的nvdla的四种模式（performance|basic|default|fast-math），fast_math应该是占用资源最少的一种模式，fast-math的时候一共162层，但如果是default，一共有334层</span><br><span class="line"></span><br><span class="line">+ `--configtarget`：生成的文件的规模，可以选择的是nv_small,nv_large,nv_full,对应的分别是资源的多少，nv\_small\&lt;nv\_large\&lt;nv\_full;</span><br><span class="line"></span><br><span class="line">+ `--cprecision`：精度，默认fp16，nv_small只支持int8，如果使用int8的话，需要加上calibtable参数（for quantizing pre-trained models from floating point to int8 and programming converters in NVDLA for scaling/re-scaling tensors）;</span><br><span class="line"></span><br><span class="line">+ `--prototxt`：prototxt文件是负责网络结构的定义,我这边的prototxt和caffemodel文件都来源于[何恺明的github](https://github.com/KaimingHe/deep-residual-networks)</span><br><span class="line"></span><br><span class="line">+ `--caffemodel`：caffemodel文件存储net参数以及所有layer的weights.</span><br><span class="line"></span><br><span class="line">+ `--informat`：该参数的设置是为了消除一个错误警报，但是作者在github上面有说该error其实出现了也无所谓，建议无视</span><br><span class="line"></span><br><span class="line">+ `--calibtable`：调用resnet50.json文件，该文件是vp自带的，应该是精度转化的json文件，如果是测试int8就需要</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 运行</span><br><span class="line">运行命令：</span><br></pre></td></tr></table></figure><p>./nv_runtime  –loadable fast_math.nvdla –image boat.jpg  –rawdump –normalize 1<br>```<br>runtime只能在aarch64架构下运行，所以在vp上会利用qemu先进入aarch64架构中，然后会安装nvdla driver，这里分别有opendla_1.ko和opendla_2.ko，opendla_1.ko是专门给nv_full的，opendla_2.ko供nv_small和nv_large使用。</p><ul><li><p><code>--image</code>：后面跟的要进行推断的图片文件</p></li><li><p><code>--normalize</code>：标准化输入的图片</p></li><li><p><code>--rawdump</code>：将输出结果从小数变成0、1</p></li></ul><p>我目前在软件上推断一次要两个小时，用的nv_full，用nv_small一直中间没有推断结束就断掉，貌似issue上有人有类似问题、、尴尬。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://nvdla.org/vp.html" target="_blank" rel="noopener">Virtual Platform</a></li><li><a href="https://blog.csdn.net/hywCogost/article/details/82114529" target="_blank" rel="noopener">Ubuntu16.04 NVDLA环境搭建</a></li><li><a href="https://blog.csdn.net/smiler_sun/article/details/89608320" target="_blank" rel="noopener">NVDLA virtual platform环境搭建</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毕设要用NVDLA，在这里记录一下NVDLA的安装过程和学习。&lt;/p&gt;
    
    </summary>
    
      <category term="NVDLA" scheme="http://yoursite.com/categories/NVDLA/"/>
    
    
      <category term="NVDLA" scheme="http://yoursite.com/tags/NVDLA/"/>
    
  </entry>
  
  <entry>
    <title>最近读的闲书20191222</title>
    <link href="http://yoursite.com/2019/12/22/%E6%9C%80%E8%BF%91%E8%AF%BB%E7%9A%84%E9%97%B2%E4%B9%A620191222/"/>
    <id>http://yoursite.com/2019/12/22/最近读的闲书20191222/</id>
    <published>2019-12-22T09:02:52.000Z</published>
    <updated>2019-12-22T09:50:24.987Z</updated>
    
    <content type="html"><![CDATA[<p>发现了“微信读书”这个宝藏APP，大部分的名家作品都能找得到www。这两周读了汪曾祺的散文集《宋朝人的吃喝》和张爱玲的《沉香屑第一炉香》和《小团圆》。随便写写读后感。</p><a id="more"></a><p>汪曾祺，张爱玲，木心是近现代我最喜欢的三个作家。汪曾祺的作品尤为适合心情闲散的时候读，有一种治愈的感觉。</p><h1 id="宋朝人的吃喝"><a href="#宋朝人的吃喝" class="headerlink" title="宋朝人的吃喝"></a>宋朝人的吃喝</h1><p>打算入手这本的实体书了，叫宋朝人的吃喝不过是里面有一章节的名字，谈写作，谈名人，谈食物的都有。谈写作的部分写的极好，适合广大高中生阅读。我很赞同汪老“随遇而安”的人生态度，有一说一，这样容易过的幸福。</p><p>前两天和同学聊天，他一段话说的极好。</p><blockquote><p>不过生活的本质，都是回归无聊和平淡的，哪怕结了婚也一样，所以还是得学会生活。</p></blockquote><p>汪老我觉得是个骨子里非常会生活的人，他这一生没有吃过多少苦，吃的那一点点苦，反而给平淡的生活加了点料，晚年回想起来有种甘之若饴的滋味。</p><h1 id="张爱玲小说集"><a href="#张爱玲小说集" class="headerlink" title="张爱玲小说集"></a>张爱玲小说集</h1><p>《沉香屑第一炉香》听说要拍了，选角是什么鬼(╯‵□′)╯︵┻━┻</p><p>原作本身是极有电影画面感的，电影配上这阵容，算了算了。</p><p>张爱玲本人其实就是一个很有意思的人，杨绛说她古怪、奇装异服、丑，我觉得有点偏颇。张爱玲自己也知道自己性格孤僻，不是个开朗活泼的人，所以朋友少，其实也很容易感到自卑。而在衣服上，张爱玲是个很注重生活情调的人，她不管是骨子里还是表现出来的，都是个完完全全的小资产阶级。而长相上，我觉得可以用当代话来说，是一种超模脸，冷淡有气质。</p><p>张爱玲的家境是让人羡慕的，祖上三代赫赫有名，但同时也是不幸。荣耀的像贾府一样的家庭在走到她这一代的时候已经是非常畸形的，而她也没有得到像贾宝玉那样的宠爱。父亲暴戾，母亲任性，上天赋予了她天才的一面，也给了她异于常人的敏感多思。敏感的人，往往是不容易感到幸福的。  </p><p>读小团圆，读到前面，她絮絮叨叨地说自己的家庭，谈的最多的是蕊秋，总说着对母亲的死心，足见她有多么爱自己的母亲。因为爱的浓烈，也最容易被伤害。蕊秋作为母亲，是极其不合格的，她从来没有想过如何做好一名母亲，孩子很小的时候，就离开他们去追求自己的幸福，寻求称为一名新时代的女性。回来了之后，也少有母女、母子的温存，吃饭的时候也只是教育批评。终其一生，不过是一个被宠坏了的富家小姐，从来就没有成长过。张爱玲和张子静生活在这样的家庭，着实是让人心疼的。</p><p>张爱玲一生自己活的清清楚楚明明白白，她不会表面一套背地一套，作品也总是就地取材，身边的人都是她的作品原型，她就是个天生的作家。</p><p>读张爱玲，有时候有种梦回高中的感觉，那时候读《金锁记》，有一种后背发凉的悲哀；读《天才梦》，被文笔惊艳到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现了“微信读书”这个宝藏APP，大部分的名家作品都能找得到www。这两周读了汪曾祺的散文集《宋朝人的吃喝》和张爱玲的《沉香屑第一炉香》和《小团圆》。随便写写读后感。&lt;/p&gt;
    
    </summary>
    
      <category term="读书杂谈" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>keystone-qemu手动安装测试</title>
    <link href="http://yoursite.com/2019/12/03/keystone-qemu%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/12/03/keystone-qemu手动安装测试/</id>
    <published>2019-12-03T06:16:06.000Z</published>
    <updated>2020-04-19T07:47:28.991Z</updated>
    
    <content type="html"><![CDATA[<p>还是docker装吧。（摊手</p><a id="more"></a><h1 id="Install-Dependencies"><a href="#Install-Dependencies" class="headerlink" title="Install Dependencies"></a>Install Dependencies</h1><p>在执行<code>sudo apt update</code>后执行<code>sudo apt install autoconf automake autotools-dev bc bison build-essential curl expat libexpat1-dev flex gawk gcc git gperf libgmp-dev libmpc-dev libmpfr-dev libtool texinfo tmux patchutils zlib1g-dev wget bzip2 patch vim-common lbzip2 python pkg-config libglib2.0-dev libpixman-1-dev libssl-dev screen device-tree-compiler expect makeself unzip cpio rsync</code><br>然后出现了如下问题</p><blockquote><p>Some packages could not be installed. This may mean that you have requested an impossible situation or if you are using the unstable distribution that some required packages have not yet been created or been moved out of Incoming.<br>The following information may help to resolve the situation:<br>The following packages have unmet dependencies:<br>gnupg : Breaks: software-properties-common (&lt;= 0.96.24.3) but 0.96.20.9 is to be installed<br>E: Error, pkgProblemResolver::Resolve generated breaks, this may be caused by held packages.</p></blockquote><p>用失败信息去google搜索，根据句askubuntu和stackflow中得到的信息，应该是因为Ubuntu版本号的原因。用<code>cat /etc/issue</code>命令查看当前Ubuntu版本，是18.04，继续查看更新源，也都是最新的阿里源。</p><p>根据<a href="https://askubuntu.com/questions/1108428/ubuntu-16-04-desktop-ui-is-broken-missing-features" target="_blank" rel="noopener">Ubuntu 16.04 desktop UI is broken/missing features</a>中一个老哥给出的<code>sudo apt dis-upgrade</code>的建议，运行该命令，成功更新，再安装依赖包，成功。</p><h1 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h1><p>本部分要完成三件事：(1)安装RISC-V toolchain；(2)检查git submodules；(3)安装SDK。</p><h2 id="同步并更新所有的子模块"><a href="#同步并更新所有的子模块" class="headerlink" title="同步并更新所有的子模块"></a>同步并更新所有的子模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule sync --recursive  </span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>在执行第一条命令的时候又出现了<code>dy_ms@test:~$ git submodule sync --recursivefatal: not a git repository (or any of the parent directories): .git</code>这样的错误，这是因为没有初始化git本地版本管理仓库，所以要执行<code>git init</code>，而后就可以顺利进行同步和更新。</p><h2 id="安装RISC-V-GNU-toolchain"><a href="#安装RISC-V-GNU-toolchain" class="headerlink" title="安装RISC-V GNU toolchain"></a>安装RISC-V GNU toolchain</h2><p>安装GNU toolchain我事先在虚拟机上尝试过，过程很漫长，结果很悲惨。我的虚拟机因为硬盘空间不够直接宕机了，然后重新装了虚拟机，现在都不敢在虚拟机上重新来一遍。T^T<br>当我看到服务器硬盘是1000G的时候，露出了满意的微笑，这时候再也没有什么能阻碍我的装机之旅了。然后在运行了以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/riscv/riscv-gnu-toolchain</span><br><span class="line">cd riscv-gnu-toolchain</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>然后出现了以下错误  </p><blockquote><p>error: RPC failed; curl 18 transfer closed with outstanding read data remaining<br>fatal: The remote end hung up unexpectedly<br>fatal: early EOF<br>fatal: index-pack failed<br>fatal: clone of ‘<a href="https://github.com/riscv/riscv-binutils-gdb.git&#39;" target="_blank" rel="noopener">https://github.com/riscv/riscv-binutils-gdb.git&#39;</a> into submodule path ‘/data/dy_ms/riscv-gnu-toolchain/riscv-binutils’ failed  </p></blockquote><p>google了相关问题，是因为网速太慢。(╯‵□′)╯︵┻━┻<br>本来我以为是实验室的网速慢，确实，实验室的网速也很慢。所以我昨天特地早早回家用家里的无线网连，还是10k每秒？？？今天跟学长老师交流了一下，是因为对面服务器的网速太慢了，晕了，这也太慢了。这个网速太坑了，我已经打算再试一下docker装了。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>然后我用docker了，docker大法好，躺平任嘲XD</p><h1 id="其他细节的知识点"><a href="#其他细节的知识点" class="headerlink" title="其他细节的知识点"></a>其他细节的知识点</h1><h2 id="ubuntu更新的区别与联系"><a href="#ubuntu更新的区别与联系" class="headerlink" title="ubuntu更新的区别与联系"></a>ubuntu更新的区别与联系</h2><p>update：是下载源里面的metadata，比如软件包的版本信息、系统要求、翻译、依赖项等等。apt get update是对软件包列表的更新过程，而upgrade是对软件包的更新过程。</p><p>upgrade: 系统将现有的package升级，如果有相依性的问题，而相依性需要安装其他新的package或影响到其他package的相依性时，此时package就不会被升级而会保留下来；<br>dist-upgrade：可以聪明地解决相依性的问题，如果有相依性问题，需要安装或移除新的package，就会尝试去安装或者移除它。</p><p>upgrade和disupgrade本质上没有什么不同，但dist-upgrade会识别出依赖关系改变的情况并作出处理，而upgrade对此情形不处理。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/wangyezi19930928/article/details/54928201" target="_blank" rel="noopener">apt-get update,upgrade和dist-upgrade的区别</a></li><li><a href="https://www.zhihu.com/question/20709809" target="_blank" rel="noopener">Linux ssh状态下如何后台运行程序</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还是docker装吧。（摊手&lt;/p&gt;
    
    </summary>
    
      <category term="keystone" scheme="http://yoursite.com/categories/keystone/"/>
    
    
      <category term="keystone" scheme="http://yoursite.com/tags/keystone/"/>
    
      <category term="实验" scheme="http://yoursite.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="qemu" scheme="http://yoursite.com/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>2019.11日记</title>
    <link href="http://yoursite.com/2019/11/26/2019-11%E6%97%A5%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/26/2019-11日记/</id>
    <published>2019-11-26T08:47:48.000Z</published>
    <updated>2019-12-22T09:03:55.942Z</updated>
    
    <content type="html"><![CDATA[<p>对这段时间的生活总结。</p><a id="more"></a><p>intel sgx explained的阅读笔记以及单词记录，看的论文笔记后期转到OneNote上写了。有一说一，OneNote除了字体非常非常非常丑以外，其他讲道理都还可以。  </p><p>blog上接下来我打算填暑假留下来的天坑：</p><ul><li>《深入理解计算机系统》的阅读笔记；</li><li>Git学习</li><li>linux内核学习</li></ul><p>还有背单词！！！好久没打卡百词斩了，虽然我从从前地看中文小说转成了看AO3上的英文小说，词汇量上去了一丢丢，但是我英语还是好菜啊QAQ。</p><p>今天认真想了一下，感觉如果老师不布置任务，学习动力就–了，本来我们实验室的氛围就比较自由（一旦都不push），还是希望自己在有限的时间内多学到点东西，所以还是把暑假填的坑全部补上去。</p><p>本周依然是看论文，一遍扫完论文确实还是一知半解，这两天打算重新看一遍论文，自己总结一下，具体思考一下如何来搭建这个系统。  </p><p>啊，vscode的字体真好看。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>生活教我好好做人，逼迫我学会做饭。  </p><p>认清楚的还有一点就是我前三年的生活作息过于反人类，我不烂脸谁烂脸。早睡早起，清淡饮食，拒绝甜品，远离肥宅水。  </p><h1 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h1><p>这个月依然没有足够吸引人的番</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对这段时间的生活总结。&lt;/p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="日记" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统day0</title>
    <link href="http://yoursite.com/2019/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fday0/"/>
    <id>http://yoursite.com/2019/08/06/深入理解计算机系统day0/</id>
    <published>2019-08-06T06:13:24.000Z</published>
    <updated>2019-08-06T06:31:27.215Z</updated>
    
    <content type="html"><![CDATA[<p>从今天开始，开始看CMU的深入理解计算机系统。今天主要飞快地过了第一章。</p><a id="more"></a><p>第一章作为对本书主题的漫游，简略地讲了内存、进程、中央处理器几个概念。这里对最后提到的几个重要主题进行记录。</p><h1 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h1><p>要想显著地加速整个系统，必须提升全系统中相当大部分的速度。</p><h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><p>并发(concurrency)表示的是一个同时具有多个活动的系统；而并行(parallelism)指的是用并发使一个系统运行得更快。其具体的实现可以从线程级并发、指令级并行和单指令、多数据并行。</p><h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><p>在处理器中，指令集架构是对实际处理器硬件的抽象。文件是对I/O设备的抽象，虚拟内存是对程序存储器的抽象，而进程是对正在运行的程序的抽象，虚拟机提供对整个计算机的抽象，包括操作系统、处理器和程序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从今天开始，开始看CMU的深入理解计算机系统。今天主要飞快地过了第一章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>专业单词记录</title>
    <link href="http://yoursite.com/2019/08/02/%E4%B8%93%E4%B8%9A%E5%8D%95%E8%AF%8D%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/08/02/专业单词记录/</id>
    <published>2019-08-02T07:54:26.000Z</published>
    <updated>2019-08-31T08:46:37.977Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要用于记录在论文中看到的常见的专业单词以及感觉很有意思的短语句子之类的。</p><a id="more"></a><p>hypervisor 系统管理程序<br>homomorphic encryption  同态加密<br>endorsement  认可，支持<br>predecessor  前驱，前辈<br>software attestation  软件认证<br>peripheral  外围的，次要的<br>compatible  兼容的<br>manual 手册<br>dedicated  专用的<br>asynchronous  异步的<br>delegate  委托<br>evict  驱逐<br>asynchronous enclave exit  异步安全区退出<br>scatter  分散<br>prerequisite  先决条件<br>lauch control feature  发射控制功能<br>hint  暗示<br>disclose  揭示<br>sidestep  回避<br>peculiarity  特性<br>refrain  节制<br>intricacy  复杂性<br>multiplex  多路传输<br>disposal  处理<br>register file  寄存器堆<br>thrust  重点<br>terminology  术语<br>acronyms  首字母缩略词<br>peripheral  外设<br>intuition  直观<br>building block  基石<br>salient feature  鲜明特征<br>procedural  程序<br>internal memory  内部存储器，内存<br>execution context  执行上下文<br>instruction pointer  指令指针<br>stack point  堆栈指针<br>precondition  前置条件<br>execution flow  执行流<br>in a nutshell  简而言之<br>processor  处理器<br>issue by 发出的<br>interrupt request  中断请求输入信号<br>Infrastructure-as-a-Service(IaaS)  基础设施即服务<br>implicitly  隐式地<br>motherboard  主板<br>bootstrapping  引导程序<br>firmware  固件<br>manufacture  厂商<br>emulate  仿真<br>benchmark and optimize software  基准测试和优化软件<br>fine-grained  细粒度的<br>virtually  事实上<br>load  加载<br>concurrently  同时地<br>codebase  代码库<br>monolithic kernel  单内核<br>video rendering functionality  视频渲染功能<br>a high-speed scratch space  一个高速暂存空间<br>memory-mapped device  内存映射设备<br>memory space  内存空间<br>shorthand for  简写为<br>over_commit  过量使用<br>page swapping  页调换<br>extend page table  扩展页表<br>attributes  属性<br>give … insight into  使…深入了解<br>memory access pattern  内存访问模式<br>fetch  取指令<br>pointer arithmetic  指针运算<br>context switching  上下文切换<br>general-purpose register  通用寄存器<br>procedure  程序<br>procedure call stack  过程调用堆栈<br>further-proof  永不过时的<br>wart  缺点<br>descriptor  描述符<br>vestigial segmentation model  残留细分模式<br>TLS=Thread-Local-Store  线程本地存储<br>disable  禁用<br>addressable space  可寻址空间<br>unnamed  未指定的<br>entry  条目<br>map  映射<br>interrupt  中断<br>invoke  调用<br>invariant  不变量<br>entry point  入口点<br>have deep implications for  对…有深刻影响<br>intimidating  吓人的<br>rogue application  流氓应用<br>recursive  递归<br>exception handler  异常处理程序<br>resume  恢复<br>restore  恢复</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要用于记录在论文中看到的常见的专业单词以及感觉很有意思的短语句子之类的。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机英语" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="计算机英语" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基本知识</title>
    <link href="http://yoursite.com/2019/08/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/08/01/操作系统基本知识/</id>
    <published>2019-08-01T06:10:04.000Z</published>
    <updated>2019-08-06T06:09:12.253Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章断断续续地记录了在读书中回顾到的以前遇到的基本知识，算是对计算机专业课中基本知识的回顾。</p><a id="more"></a><h1 id="内存、cache和寄存器之间的关系"><a href="#内存、cache和寄存器之间的关系" class="headerlink" title="内存、cache和寄存器之间的关系"></a>内存、cache和寄存器之间的关系</h1><p>把CPU比作大脑的话，寄存器相当于当前正在思考问题，而cache则相当于临时的记忆。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器是中央处理器(CPU)的组成部分，是有限存储容量的高速存储部件，可以用来暂存指令、数据和位址。CPU的控制部件中，包含的寄存器有指令寄存器(IR)和程序寄存器(PC)。在CPU的算数逻辑部件中，包含的寄存器有累加器(ACC)。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存用来存放当前正在使用的程序和数据。RAM可以分为静态存储器(Staic Random Access Memory,SRAM)和动态存储器(Dynamic Random Access Memory)，一般我们提到的DRAM就是内存。</p><p>SRAM中的存储单元相当于一个锁存器，只有0、1两个稳态；而DRAM是利用电容存储电荷来保存0和1两个状态，需要定时刷新。</p><p>DRAM，其中，随机访问表示的是以无序的顺序访问DRAM中的任何信息的这种能力。动态表示的是暂时性存储数据的基本能力。</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>Cache就是高速缓冲存储器，是位于CPU和主内存之间的容量小但速度很快的存储器。Cache中保存着CPU刚用过的一部分数据，当CPU再次使用这部分数据直接从Cache中直接调用即可，从而减少了CPU的使用时间提高了效率。Cache分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2早起焊在主板上，现在也都集成在CPU内部。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，寄存器(register file)位于CPU内部，内存是连接CPU和磁盘的桥梁，而缓存是为了解决内存和CPU的运算速度差异而设置的组件。数据的流向过程是内存-Cache-寄存器。</p><h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>最后补一个磁盘缓存，缓存的概念目前已经从CPU和主内存之间的Cache扩充到内存和磁盘之间的Cache（磁盘缓存）。凡是速度差异较大的两个硬件之间，用于协调两者数据传输速度差异的结构，就可以称之为Cache。</p><p>磁盘缓存实际上是将需要下载的数据先保存到系统为软件分配的内存空间中（该内存空间被称之为“内存池”），当保存到内存池中的数据达到一定程度时，便将数据保存到硬盘中，这样就可以减少实际的磁盘操作，有效保护磁盘避免重复的读写操作而造成的损坏。</p><blockquote><p>磁盘缓存是为了减少CPU透过I/O读取磁盘的次数，提高I/O的效率，用一块内存来存储存取较为频繁的磁盘内容。因为内存的存取是电子动作，而磁盘的存取是I/O动作。</p></blockquote><h1 id="Intel-VMM"><a href="#Intel-VMM" class="headerlink" title="Intel VMM"></a>Intel VMM</h1><p>intel提供了处理器级别的VMX(Virtual-Machine Extensions)技术.intel VMX的体系结构可以划分为两层：VMM和VM。</p><p>VMM(Virtual-Machine Monitors)作为host，具有对processor和平台硬件的完全控制权限。它为guest提供了VCPU(virtual processor)的抽象，并允许guest直接运行在逻辑处理器上，具有对处理器资源、物理内存、中断和IO的控制的权利。  </p><p>VM(Virtual-Machine)相应地作为guest，其实提供了一种guest的软件环境。它维护了一个栈，其中包含了OS和application software。其中每个操作都独立于其他的VM，并且使用由同一个物理平台所提供的处理器、内存、硬盘、显卡和IO访问的统一接口。这些栈并不知道VMM的存在。运行于VM中的软件其权限是受限的，也就保障了VMM对整个平台资源的完全控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章断断续续地记录了在读书中回顾到的以前遇到的基本知识，算是对计算机专业课中基本知识的回顾。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="基本知识复习" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>SGX-Ubuntu-makefile</title>
    <link href="http://yoursite.com/2019/08/01/SGX-Ubuntu-makefile/"/>
    <id>http://yoursite.com/2019/08/01/SGX-Ubuntu-makefile/</id>
    <published>2019-08-01T05:04:10.000Z</published>
    <updated>2019-08-01T05:10:59.651Z</updated>
    
    <content type="html"><![CDATA[<p>本次实验是在虚拟机上配置好了Ubuntu16.04之后，在该系统上进行SGX实验。主要参照qiu_pengfei的blog<a href="https://blog.csdn.net/qiu_pengfei/article/details/78798644" target="_blank" rel="noopener">Ubuntu16.04下Intel SGX应用程序程序开发——打印Hello World！</a>。</p><a id="more"></a><h1 id="sgx-helloworld程序"><a href="#sgx-helloworld程序" class="headerlink" title="sgx_helloworld程序"></a>sgx_helloworld程序</h1><p>在SGX SDK中，在/sgxsdk/SampleCode文件下提供了6个SGX应用程序示例。</p><h1 id="文件夹介绍"><a href="#文件夹介绍" class="headerlink" title="文件夹介绍"></a>文件夹介绍</h1><p>其中，SampleEnclave示例实现了安全printf函数，可以用来安全打印需要打印的字符串。该项目中一共包含了3个文件夹。 </p><h2 id="App文件夹"><a href="#App文件夹" class="headerlink" title="App文件夹"></a>App文件夹</h2><p>该文件夹中存储着应用程序中的不可信代码部分，其中包含了Edger8rSyntax、TrustedLibrary文件夹、App.h、App.cpp文件。</p><h3 id="App-cpp文件"><a href="#App-cpp文件" class="headerlink" title="App.cpp文件"></a>App.cpp文件</h3><p>应用程序中的不可信部分代码，其中包含了创建Enclave以及销毁Enclave的代码、返回码供使用者查看Enclave程序的执行状态。其中，main函数是整个项目的入口函数。</p><h3 id="App-h文件"><a href="#App-h文件" class="headerlink" title="App.h文件"></a>App.h文件</h3><p>该文件是应用程序中不可信部分代码的头文件，定义了一些宏常量和函数声明。</p><h3 id="Edger8rSyntax文件夹"><a href="#Edger8rSyntax文件夹" class="headerlink" title="Edger8rSyntax文件夹"></a>Edger8rSyntax文件夹</h3><p>提供了一些工具，无需进行修改。</p><h3 id="TrustedLibrary文件夹"><a href="#TrustedLibrary文件夹" class="headerlink" title="TrustedLibrary文件夹"></a>TrustedLibrary文件夹</h3><p>提供了一些函数库，无需进行修改，</p><h2 id="Enclave文件夹"><a href="#Enclave文件夹" class="headerlink" title="Enclave文件夹"></a>Enclave文件夹</h2><p>该文件夹存放的是应用程序中的可信代码部分、可信与不可信代码接口文件。</p><h3 id="Enclave-config-xml文件"><a href="#Enclave-config-xml文件" class="headerlink" title="Enclave.config.xml文件"></a>Enclave.config.xml文件</h3><p>Enclave的配置文件，定义了Enclave的元数据信息。  </p><h3 id="Enclave-cpp文件"><a href="#Enclave-cpp文件" class="headerlink" title="Enclave.cpp文件"></a>Enclave.cpp文件</h3><p>该文件是应用程序中的可信部分代码，包括了可信函数的实现，是需要修改的文件。  </p><h3 id="Enclave-h文件"><a href="#Enclave-h文件" class="headerlink" title="Enclave.h文件"></a>Enclave.h文件</h3><p>是应用程序中的可信部分代码的头文件，定义了一些宏常量和函数声明，是需要修改的文件。</p><h3 id="Enclave-edl文件"><a href="#Enclave-edl文件" class="headerlink" title="Enclave.edl文件"></a>Enclave.edl文件</h3><p>该文件是Enclave的接口定义文件，定义了不可信代码调用可信代码的ECALL函数接口和可信代码调用不可信代码的OCALL函数接口。其中trusted{}中定义了ECALL函数接口，untrusted{}中定义了OCALL函数接口。</p><h3 id="Enclave-lds文件"><a href="#Enclave-lds文件" class="headerlink" title="Enclave.lds文件"></a>Enclave.lds文件</h3><p>定义了Enclave可执行文件信息。</p><h3 id="Enclave-private-pem文件"><a href="#Enclave-private-pem文件" class="headerlink" title="Enclave_private.pem文件"></a>Enclave_private.pem文件</h3><p>该文件是SGX生成的私钥，无需修改。</p><h3 id="Edger8rSyntax文件夹-amp-TrustedLibrary文件夹"><a href="#Edger8rSyntax文件夹-amp-TrustedLibrary文件夹" class="headerlink" title="Edger8rSyntax文件夹&amp;TrustedLibrary文件夹"></a>Edger8rSyntax文件夹&amp;TrustedLibrary文件夹</h3><p>同上</p><h2 id="include文件夹"><a href="#include文件夹" class="headerlink" title="include文件夹"></a>include文件夹</h2><p>该文件夹存放被Enclave接口定义文件Enclave.edl使用的头文件，包括一些宏定义，其中只包含了user_types.h文件，该文件主要定义了用户自定义的类型。</p><h2 id="Makefile文件"><a href="#Makefile文件" class="headerlink" title="Makefile文件"></a>Makefile文件</h2><p>该文件保存着编译相关的信息。  </p><h3 id="修改SDK路径"><a href="#修改SDK路径" class="headerlink" title="修改SDK路径"></a>修改SDK路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SGX_SDK ?= ~/下载/sgxsdk //sgx SDK安装的位置</span><br><span class="line">SGX_MODE ?= SIM  //模拟运行</span><br></pre></td></tr></table></figure><h3 id="修改不可信代码编译的源文件"><a href="#修改不可信代码编译的源文件" class="headerlink" title="修改不可信代码编译的源文件"></a>修改不可信代码编译的源文件</h3><p>由于不可信代码可能是多个文件，所以最好在App_Cpp_Files文件中包括App文件夹中的所有cpp文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App_Cpp_Files := $(wildcard App/*.cpp) $(wildcard App/Edger8rSyntax/.cpp) $(wildcard App/TrustedLibrary/*.cpp)</span><br></pre></td></tr></table></figure><h3 id="修改可信代码编译的源文件"><a href="#修改可信代码编译的源文件" class="headerlink" title="修改可信代码编译的源文件"></a>修改可信代码编译的源文件</h3><p>同理，可信代码也可能是多个文件，最好在Encalve_Cpp_Files中包括Enclave文件夹中的所有cpp文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App_Cpp_Files := $(wildcard Enclave/*.cpp) $(wildcard Enclave/Edger8rSyntax/.cpp) $(wildcard Enclave/TrustedLibrary/*.cpp)</span><br></pre></td></tr></table></figure><h1 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h1><p>需要修改的文件包括Enclave.edl文件、Enclave.cpp文件、Enclave.h文件、App.cpp文件和makefile文件（已修改完成）。</p><h2 id="Enclave-edl文件修改"><a href="#Enclave-edl文件修改" class="headerlink" title="Enclave.edl文件修改"></a>Enclave.edl文件修改</h2><p>该文件中添加不可信代码调用可信函数的接口，也就是ECALL，添加到untrusted{}之前。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trusted&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printf_helloworld</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enclave-cpp文件修改"><a href="#Enclave-cpp文件修改" class="headerlink" title="Enclave.cpp文件修改"></a>Enclave.cpp文件修改</h2><p>该文件就是实现printf_helloworld函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_helloword</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enclave-h文件修改"><a href="#Enclave-h文件修改" class="headerlink" title="Enclave.h文件修改"></a>Enclave.h文件修改</h2><p>将printf_helloworld函数声明添加到Enclave.h文件中。添加到原先的printf函数的下方即可。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf_helloworld</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="App-cpp文件修改"><a href="#App-cpp文件修改" class="headerlink" title="App.cpp文件修改"></a>App.cpp文件修改</h2><p>该文件中调用自定义的ECALL函数printf_helloworld，将下面的代码放到<code>sgx_destroy_enclave(global_eid);</code>之前。其中，global_eid是必须的，表示的是enclave的id。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf_helloworld(global_eid);</span><br></pre></td></tr></table></figure><h1 id="编译文件"><a href="#编译文件" class="headerlink" title="编译文件"></a>编译文件</h1><p>打开终端，进入文件夹中，首先<code>source ~/下载/sgxsdk/environment</code>将sgx sdk设置到环境变量中。而后，输入make进行编译。</p><h1 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h1><p>在终端输入./app，可以看到hello world，说明程序编写正确。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次实验是在虚拟机上配置好了Ubuntu16.04之后，在该系统上进行SGX实验。主要参照qiu_pengfei的blog&lt;a href=&quot;https://blog.csdn.net/qiu_pengfei/article/details/78798644&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu16.04下Intel SGX应用程序程序开发——打印Hello World！&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="SGX" scheme="http://yoursite.com/categories/SGX/"/>
    
    
      <category term="实验" scheme="http://yoursite.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="SGX" scheme="http://yoursite.com/tags/SGX/"/>
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>阅读英文文献建议</title>
    <link href="http://yoursite.com/2019/08/01/%E9%98%85%E8%AF%BB%E8%8B%B1%E6%96%87%E6%96%87%E7%8C%AE%E5%BB%BA%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/08/01/阅读英文文献建议/</id>
    <published>2019-08-01T04:52:53.000Z</published>
    <updated>2019-08-01T05:02:32.619Z</updated>
    
    <content type="html"><![CDATA[<p>最近正在读老师建议的Intel SGX Explained，相当于对SGX的入门综述，100多页的全英文，读的脑阔疼，真~看了上句忘了下句….然后我就很困惑，我到底要怎么去读这本书，从知乎上了看了相关的经验后，总结如下。</p><a id="more"></a><h1 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h1><h2 id="如何阅读文献"><a href="#如何阅读文献" class="headerlink" title="如何阅读文献"></a>如何阅读文献</h2><ul><li><p>注重摘要</p></li><li><p>确立句子的架构</p></li><li><p>增加阅读量</p></li></ul><h2 id="如何提高阅读的效率"><a href="#如何提高阅读的效率" class="headerlink" title="如何提高阅读的效率"></a>如何提高阅读的效率</h2><ul><li><p>集中时间看文献</p></li><li><p>做好标记和记录</p></li></ul><h1 id="三步走方法"><a href="#三步走方法" class="headerlink" title="三步走方法"></a>三步走方法</h1><p>三步走方法参考的是滑铁卢大学教授的paper<a href="http://ccr.sigcomm.org/online/files/p83-keshavA.pdf" target="_blank" rel="noopener">How to Read a Paper</a>，写的非常有意思，而且易懂。</p><h2 id="first-pass"><a href="#first-pass" class="headerlink" title="first pass"></a>first pass</h2><p>first pass主要强调的是”get a bird’s-eye view”，快速地扫一遍</p><h3 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h3><blockquote><p>认真读标题、摘要和介绍(introduction)<br>读标题和子标题，忽略其他一切<br>过一遍(glance)公式<br>阅读结论<br>扫一遍参考文献，在心中标记处已经读过</p></blockquote><h3 id="需要回到的five-Cs"><a href="#需要回到的five-Cs" class="headerlink" title="需要回到的five Cs"></a>需要回到的five Cs</h3><blockquote><p>种类(category)：这篇paper是那种类型的？<br>内容(Context)：这篇文章与哪些文章有关联？哪些理论基础会被用来分析这个问题？<br>这些假设是否是有依据的？<br>这篇论文的主要贡献是什么？<br>这篇文章写得好吗？</p></blockquote><h2 id="second-pass"><a href="#second-pass" class="headerlink" title="second pass"></a>second pass</h2><p>第二步需要更好的耐心来看，但同时也需要忽略诸如证明之类的细节。本部分能够帮助记下key points（核心点），并在空白处记下评论。</p><blockquote><p>仔细看图表、图片以及论文中的其他的说明。<br>记得要去标注相关的未读过的参考文献for further reading</p></blockquote><h2 id="third-pass"><a href="#third-pass" class="headerlink" title="third pass"></a>third pass</h2><p><strong>复现论文</strong>  </p><p>在这一步，需要考虑的是我们自己应该如何定义或者挑战假设，更多的是，我们需要考虑自己如何提出一个特别的idea。在这一部分，我们需要记下敢于未来干工作的想法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近正在读老师建议的Intel SGX Explained，相当于对SGX的入门综述，100多页的全英文，读的脑阔疼，真~看了上句忘了下句….然后我就很困惑，我到底要怎么去读这本书，从知乎上了看了相关的经验后，总结如下。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="英语" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="读后感" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>intel sgx explained阅读笔记</title>
    <link href="http://yoursite.com/2019/07/31/intel-sgx-explained%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/31/intel-sgx-explained阅读笔记/</id>
    <published>2019-07-31T08:17:08.000Z</published>
    <updated>2019-09-01T09:15:41.060Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要是对SGX经典入门综述intel SGX Explained这本书的阅读笔记。</p><p>希望能够坚持下来，在这个过程中得到从英语和知识水平两个方面的提高。  </p><a id="more"></a><h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><p>之前看的时候还很不连贯，会在最后第2,5章全部读完时再回头重新读一遍时，再进行相关的记录。</p><h1 id="computer-architecture-background"><a href="#computer-architecture-background" class="headerlink" title="computer architecture background"></a>computer architecture background</h1><p>本部分主要是对intel目前最为流行的计算机处理器背后的总体架构进行概括，以及运行在这些处理器上的系统所需要的安全特性。</p><p>在经过一个月艰(mo)苦(yu)卓(wan)绝(le)的学习下，终于把第二章读完了。第二章主要是从操作系统和体系结构的角度来对intel计算机体系架构进行了介绍。</p><p>计算机最为重要的资源就是处理器(processor)和内存(memory)。DRAM提供了内存资源，而CPU芯片则提供了逻辑处理器资源。计算机资源是由系统软件来进行管理，而系统软件主要分成两类：操作系统(operating system)和管理程序(hypervisor)。操作系统将计算机资源分配给正在运行的进程，而一台计算机中可能有多个操作系统，管理程序便负责将计算机资源分配给不同的操作系统。</p><p>为了让多个同时运行的操作系统之间不互相影响，计算机使用了虚拟化技术(virtualization)。其中一个就是地址映射技术，而另一个则是软件特权等级。</p><p>另外，每个进程由包含着一个或多个线程(thread)，每个线程都有执行上下文信息(execuation context)，其中包含了计算所必要的信息。计算机让每个进程都认为自己可以无限制地使用计算机资源，但实际上处理器资源是有限的，这里就用到了复用技术，也就是一个逻辑处理器可能会被多个进程或操作系统使用。</p><p>DRAM和CPU之间的速度差距非常大，当代intel体系结构中的很多复杂性都源于缩小这种差距的需要。比如说hyperthreading、out-of-order execuation、caching。cache是其中最为典型的代表(cache分为不同的level，level1在CPU内核内部)，由于不止存在一个cache，同时也不会有不同的内存对其进行读写，所以使用cache coherence mechanism来保证对于所有的缓存来说，看到的DRAM都是一致的。</p><p>CPU与DRAM和I/O设备都是使用system bus来进行通信的。intel架构的软件是通过I/O地址空间与I/O设备进行通信，使用内存地址空间对DRAM进行访问。</p><p>计算机由于有非常多的外设，所以初始化是一件复杂的过程，初始化序列也带来的一定的安全妥协和问题。</p><p>最后讲述了microcode。</p><h1 id="计算模型-Computation-Model"><a href="#计算模型-Computation-Model" class="headerlink" title="计算模型(Computation Model)"></a>计算模型(Computation Model)</h1><p>计算机最基本的几个组成部件就是DRAM、处理器，DRAM与处理器和I/O设备之间都通过系统总线进行连接。</p><p>DRAM其实也就是一般所说的内存，表现为一个存储单元构成的数组。一个显著的特征是<strong>在一个地址读取到的内存单元的值必须等于它被写入的最新值</strong>.</p><p>处理器最核心的功能就是处理指令，当处理器开始处理指令时，首先会判断当前是否是中断（interrupt）。如果是中断，则首先将当前中断数据写入exception register，而后进行异常管理：定位到异常管理程序的位置–&gt;定位异常管理程序栈顶–&gt;将RIP和RSP压入栈中–&gt;像RIP中写入异常管理程序地址–&gt;向RSP中写入栈顶地址。而如果没有发生中断，则在RIP中进行取指令–&gt;对指令进行译码–&gt;读取目前指令的输入寄存器(current register’s input register)（这边这个我理解的是不是说指令是不是寄存器寻址这些？）–&gt;执行。在执行过程中，可能会遇到出错，在遇到出错时，将出错信息写入到exception register中，而后进行异常管理操作（和上面的一样）。如果没有出错，将当前指令结果写入到输出寄存器中，并判断输出寄存器中是否包含了RIP。如果包含，则下一条指令就直接从结果指定的地方执行（类似于jmp之类的跳转指令）；反之，则将RIP中的值加上当前执行指令的长度。接下来，就是下一轮的指令执行。</p><p>由于RISC（精简指令集）中的指令都是可变大小的指令，所以每条指令的大小都是不可预测的，所以必须要当前指令执行结束，才能够进行下一条指令的执行。</p><p>总线上连接着很多个不同的设备，在每个时钟周期中，这些设备能够发送消息，这些消息会被该总线上连接的所有设备接收。每个设备对消息进行解码后，发现目标地址不是自己后，就会忽视掉这条不需要自己参与的信息。</p><h1 id="软件特权级别-Software-Privilege-Levels"><a href="#软件特权级别-Software-Privilege-Levels" class="headerlink" title="软件特权级别(Software Privilege Levels)"></a>软件特权级别(Software Privilege Levels)</h1><p>设置不同的priviege level是处于对计算机安全的考虑。高安全级别的软件，能够访问低安全级别，而相反咋不能。这在一定程度上，保护了高安全级别软件的安全。所带来的另一层问题：计算机上的软件必须要信任所有更高安全级别的软件。对于一台计算机的安全分析，也应该囊括所有安全级别的软件。</p><p>intel架构中的安全级别分为三层。第一层，SMM模式下，主要包含BIOS（基本输入输出系统）；第二层：VMX root，主要是hypervisor（管理程序），hypervisor负责对使用着同一个物理机的不同操作系统进行资源分配；第三次：VMX non-root：ring0是OS kernel；而ring3是普通的应用程序。</p><p>根据kernel不同的设计思想，可以分为微内核和单内核。微内核中强调kernel尽可能地小，只包含核心组件，而其他相应不那么重要的组件可以运行在非内核中（比如Windows）。但另一方面，单内核中虽然有大量的组件，但执行效率高，不同组件之间重要通过进行模块调用即可（Linux），而相对的，微内核不同模块的调用是需要进行调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要是对SGX经典入门综述intel SGX Explained这本书的阅读笔记。&lt;/p&gt;
&lt;p&gt;希望能够坚持下来，在这个过程中得到从英语和知识水平两个方面的提高。  &lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="SGX" scheme="http://yoursite.com/tags/SGX/"/>
    
      <category term="基本知识复习" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>SGX官方视频笔记</title>
    <link href="http://yoursite.com/2019/07/31/sgx%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/31/sgx笔记/</id>
    <published>2019-07-31T05:23:58.000Z</published>
    <updated>2019-11-10T02:58:10.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="intel-sgx笔记"><a href="#intel-sgx笔记" class="headerlink" title="intel sgx笔记"></a>intel sgx笔记</h1><p>本文是根据b站上的sgx介绍视频整理而来的对sgx的基本概念的介绍。</p><p>intel sgx是使得程序能够在可信的环境下执行代码并保护机密信息，从而让开发者直接控制程序的安全性。<br>intel sgx在内存中划定了名为安全区（enclave）的隔离区域，用来存放代码和数据。</p><a id="more"></a><h2 id="features-and-benefits"><a href="#features-and-benefits" class="headerlink" title="features and benefits"></a>features and benefits</h2><ul><li>这些不可寻址的分页内存是从系统的物理内存中保留的，并且经过了加密；</li><li>安全区是受保护的内存区域，应用程序可以在里面处理它的机密数据而不必担心泄露；</li></ul><p>包含intel SGX技术的应用程序分为两个部分，分别是可信部分和不可信部分。当应用程序需要处理机密时，会创建一个位于可信内存的安全区，然后调用可信函数。可信函数是由开发者创建的，专门在安全区内执行的函数。一旦这个函数被调用，应用程序就会在可信区域执行，并且明文访问安全区内的代码和数据。而试图从安全区之外的地方访问安全区内存的行为都会被处理器拒绝，即使是系统特权用户的行为。</p><p>当可信函数执行完毕之后，安全区的数据依然会保留在可信内存中，而应用程序返回到不可信区域继续执行，并且失去了对可信内存的访问权限。</p><h2 id="检测和开启intel-SGX"><a href="#检测和开启intel-SGX" class="headerlink" title="检测和开启intel SGX"></a>检测和开启intel SGX</h2><p>应用程序可以使用intel SGX的四个条件</p><blockquote><p>CPU必须支持intel SGX的指令<br>BIOS必须支持intel SGX<br>必须在BIOS设置中开启intel SGX<br>必须安装intel SGX PSW</p></blockquote><p>BIOS设置中intel SGX可能的三种选项是启用、禁用以及软件控制</p><blockquote><p>“启用”：严格开启了intel SGX<br>“禁用”：严格关闭了intel SGX<br>“软件控制”：允许包含intel SGX技术的应用程序在系统重启后启用intel SGX  </p></blockquote><p>安装程序时检查的步骤：</p><blockquote><p>检查CPU和BIOS是否支持intel SGX<br>检查intel SGX PSW是否安装，如果没有安装，就安装<br>检查intel SGX是否在BIOS中开启，如果没有开启，则用软件控制开启</p></blockquote><p>应用程序本身的检查</p><blockquote><p>检查intel SGX PSW是否安装<br>检查SGX是否可用，如果不可用，则使其变为启用</p></blockquote><p>如果上述步骤中的任一步骤失败，则说明系统不支持intel SGX。</p><h2 id="如何设计intel-SGX应用程序"><a href="#如何设计intel-SGX应用程序" class="headerlink" title="如何设计intel SGX应用程序"></a>如何设计intel SGX应用程序</h2><p>所有的intel SGX应用程序都有相同的基本结构，也就是他们在设计时都要遵循一些通用的原则。intel SGX应用程序分成两个部分，可信部分和不可信部分。</p><p>应用程序的可信部分由它的安全区（enclaves）组成，一个应用程序可以拥有一个或多个安全区。安全区存储在加密的内存中，并受intel SGX的保护。安全区是可信的，它们一旦被建立就不能被篡改。如果安全区的数据被恶意篡改，就会被CPU检测到，并不会被加载。</p><p>可信部分之外的被称为非可信部分，也就是不会被intel SGX保护的应用程序或内存区域。</p><p>如果我们需要设计一个intel SGX程序，就需要将程序分成两个不同的部分，需要判断哪些代码应该放在安全区，哪些代码应该放在安全区之外以及可信部分和非可信部分的交互。</p><p>划分代码的关键步骤：</p><ul><li>确定机密信息  </li><li>确定机密数据的提供者和使用者(画出机密数据在应用程序中的各个组件的流程图，也就是机密数据的来源和去向)  </li><li>确定安全边界(划定边界时，需要尽量包含尽可能多的机密数据，并最大限度地减少与非信任代码的交互)  </li><li>精简安全区的代码<br>在为安全区以及它的接口编写代码时需要记住：<blockquote><p>单一系统中，用于运行所有安全区的内存容量是固定的。    </p></blockquote></li></ul><p>安全区的体积应该尽可能地小。当不再需要机密数据时，安全区应该被销毁。  </p><blockquote><p>进出安全区的调用会产生性能损失，就和CPU上下文切换一样。 </p></blockquote><p>通过一次调用完成大量工作，会比分成多次调用来完成等量的工作更有效率。</p><h2 id="安全区定义语言（EDL）"><a href="#安全区定义语言（EDL）" class="headerlink" title="安全区定义语言（EDL）"></a>安全区定义语言（EDL）</h2><p>intel SGX提供的基本保护措施是安全区的机密数据仅能够被安全区内的代码访问。执行安全区内的代码的唯一方式是通过开发人员创建的接口函数。</p><p>每个安全区可以定义一个或多个e-call，e-call是非可信应用程序进入安全区的入口点；安全区也可以定义o-call，o-call使得安全函数可以调用外部的非可信应用程序，而后再返回安全区。ECALL和OCALL共同组成了安全区的接口，这些函数并非由非可信应用程序执行。</p><p>处理器对安全区出入口的访问严格控制，同时为了完成出入安全区的转换，必须依序执行特定的CPU指令。</p><p>intel SGX SDK把这些底层细节做了抽象，从而让软件开发者可以用熟悉的编程环境进行开发，名为Edger8r的特殊工具会自动为E-CALL和O-CALL生成代理函数，从而应用程序就可以像调用其他C语言函数一样调用它。</p><p>Edger8r从EDL文件中读取安全区接口的定义来创建代理函数。</p><p>安全区定义语言(enclave definition language,EDL)，EDL文件和声明函数原型的C语言风格的头文件十分相似。</p><p>EDL文件由可信区和非可信区组成。E-CALL定义在可信区，而O-CALL定义在非可信区。这些函数原型与C非常相似，但还需要一些额外的关键字。<br>所有能够被非可信程序调用的E-CALL都必须声明为public，每个安全区都至少有一个声明为public的E-CALL，不含public关键字的E-CALL只能被另一个O-CALL执行。</p><p>在进行E-CALL或O-CALL调用时，函数参数要从非可信内存和可信内存之间进行封送处理。若函数参数是值传递，对应的封送处理就是单向的。在E-CALL或O-CALL内部进行的更改不会反映到被调用的函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enclave&#123;</span><br><span class="line">    from <span class="string">"sgx_tstdc.edl"</span> <span class="keyword">import</span> *;</span><br><span class="line">    trusted&#123;</span><br><span class="line">        <span class="comment">/*define ECALLs here. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ecall_private</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    untrusted&#123;</span><br><span class="line">        <span class="comment">/*define OCALLs here. */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">an_ocall</span><span class="params">(<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果函数参数时引用传递，就必须完整地描述数据的封送处理过程，每个指针或参数之前必须有方括号来描述封送处理的方向以及封送处理的元素数量</p><p>in关键字表示数据需要封送到E-CALL或O-CALL之内，而如果是out关键字则意味着数据需要从E-CALL或O-CALL封送回调用的函数。如果需要out，则需要在调用E-CALL或O-CALL之前分配好数据的缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in] <span class="keyword">int32_t</span> *value)</span></span>;</span><br></pre></td></tr></table></figure><p>如果同时指定了in和out关键字，意味着要进行两个方向的封送处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,out] <span class="keyword">int32_t</span> *value)</span></span></span><br></pre></td></tr></table></figure><p>在缺省情况下，Edger8r假定数据的缓冲区大小等于参数的sizeof。如果指针指向的是一个数组，那么需要提供count参数来指定需要复制的元素个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,count=<span class="number">10</span>] <span class="keyword">int32_t</span> *<span class="built_in">array</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如果参数的个数要等到运行的时候才能确定，也可以用另一个函数参数来表示个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,count=len] <span class="keyword">int32_t</span> *<span class="built_in">array</span>,<span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>如果使用in关键字封送一个以’\0’作为终止符的字符串，可以选择使用string或者是wstring来代替count关键字，string或wstring不能和out关键字一起使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,<span class="built_in">string</span>] <span class="keyword">int32_t</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_wecall</span><span class="params">([in,wstring] <span class="keyword">wchar_t</span> *unicodename)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="EDL语言的进阶主题"><a href="#EDL语言的进阶主题" class="headerlink" title="EDL语言的进阶主题"></a>EDL语言的进阶主题</h2><p>有时需要把void指针传给E-CALL或O-CALL，问题在于边界例程无法知道void类型对应的大小，无法计算封送处理需要的数据缓冲区大小。为了解决这个问题，EDL语法提供了size关键字，通过指定单个元素的大小，边界例程就知道需要拷贝多少数据。在下面的例子中，32个8字节数据将会被封送到E-CALL中。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([in,count=<span class="number">32</span>,size=<span class="number">8</span>] <span class="keyword">void</span> *buffer)</span></span></span><br></pre></td></tr></table></figure><p>在不希望封送完整的数据缓冲区时，仅仅希望把指针指向的地址传给E-CALL或O-CALL，这可以通过user_check关键字来完成。这样行为传递的指针不进行边界例程的安全检查和数据封送处理，E-CALL和O-CALL将会直接作用于指针的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">my_ecall</span><span class="params">([user_check] <span class="keyword">void</span> *buff)</span></span>;</span><br></pre></td></tr></table></figure><p>只有被声明为public的E-CALL可以被不安全的函数调用，被称之为root E-CALL，由EDL文件中使用的public关键字指定，不含public关键字的E-CALL只能被另一个O-CALL调用，但是，在缺省情况下，O-CALL不能调用任何E-CALL，必须通过allow关键字声明该O-CALL可以调用哪些E-CALL,allow后面跟着允许的E-CALL名称列表。在本例中，O-CALL get_msg_block()只能调用E-CALL update_hash()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enclave&#123;</span><br><span class="line">    from <span class="string">"sgx_tstdc.edi"</span> <span class="keyword">import</span> *;</span><br><span class="line">    trusted&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init_hash</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get_hash</span><span class="params">([out] <span class="keyword">char</span> hash[<span class="number">32</span>])</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">update_hash</span><span class="params">([in,count=len],<span class="keyword">char</span> *block,<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    untrusted&#123;</span><br><span class="line">        <span class="keyword">size_t</span> get_msg_block() allow(updata_hash);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试intel-SGX应用程序"><a href="#调试intel-SGX应用程序" class="headerlink" title="调试intel SGX应用程序"></a>调试intel SGX应用程序</h2><p>intel SGX安全区可以以debug模式或release模式构建。</p><ul><li>debug模式<blockquote><p>debug模式下的安全区是可以调试的；<br>可以使用intel SGX调试器附加到上面；<br>查看当前的状态；<br>以及对代码进行逐句调试，就和调试其他程序一样  </p></blockquote></li></ul><p>当在调试intel SGX应用程序时，它很有可能是以debug模式构建的，CPU允许运行任何以debug模式构建的安全区，由于您可以用intel SGX调试器附到安全区上，这些安全区显然是不安全的，所以<strong>永远不要在生产环境上部署以debug模式构建的安全区</strong></p><ul><li>release模式</li></ul><p>release模式构建的安全区无论如何也无法进行调试，CPU严格执行这条限制。对于intel SGX安全区的调试，仍然需要相关的CPU指令支持，这就意味着必须使用随intel SGX SDK安装的intel SGX调试器进行调试，而其他的调试器只会跳过安全区的代码。</p><h2 id="intel-SGX的数据密封功能"><a href="#intel-SGX的数据密封功能" class="headerlink" title="intel SGX的数据密封功能"></a>intel SGX的数据密封功能</h2><p>intel SGX应用程序也有可能需要把机密数据保存到安全区以外。安全区从本质上来说是无状态的：</p><blockquote><p>当电脑进入睡眠、关机或者应用程序退出时，安全区就会被销毁；<br>应用程序显示将其销毁时，安全区也会被销毁，当安全区被销毁后，其中的所有内容都会丢失。</p></blockquote><p>为了持久保存安全区内存储的数据，必须显式地将其发送到安全区以外的非可信内存中。由于不可信内存是不可信的，所以系统为数据提供密封功能。当数据被密封时，数据在安全区内用密钥加密，这个密钥是直接从CPU中取得的。加密的数据块被称为密封的数据，它只能在创建的电脑上进行解密。</p><p>密封数据时可以选择的密钥策略有两种：</p><ul><li>安全区标识(MRENCLAVE)  </li></ul><p>安全区标识策略生成一个该安全区独有的密钥，这就意味着只有同一台电脑的同一个安全区可以解封数据</p><ul><li>密封标识(MRSIGNER)  </li></ul><p>密封标识基于安全区密封授权方的密钥生成一个密钥，这使得一个安全区密封的数据可被另一个安全区解封。只要是同一台电脑，而且软件是由相同开发商开发（密封授权方的密钥相同）即可。该策略可以允许数据被新版应用程序或其他构建版本的应用程序所读取。该方法可以在两个不同的应用程序的两个不同的安全区中共享数据。</p><p>这两种策略的相同点是密封数据的电脑的指纹是密钥的一个输入，这就意味着如果密封的数据被复制到了另一台电脑上就无法被解封。</p><p>密钥的另一个输入是安全区的debug模式或release模式，debug的安全区无法解封release模式的安全区密封的数据，反之亦然。这项安全机制是用于防止intel SGX调试器在调试debug的安全区时，泄露来自release模式的安全区的数据。</p><p>注意，密封数据可能具有非常严重的安全隐患：<strong>安全区并不会检验非可信应用程序的真实性，绝不能假设只有自己的应用程序能加载安全区或者说E-CALL一定会按照预期的顺序执行！</strong> 任何人都可以加载安全区，并按照他们希望的顺序执行E-CALL。安全区API绝不能因为密封数据和解封数据而泄露了机密或授予了不该授予的权限。</p><p>总而言之，密封数据的功能是为了安全地把机密数据导出到安全区以外，并确保这些机密数据不会被篡改、替换、窃听或者是在解封数据时，被复制到另一台电脑上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;intel-sgx笔记&quot;&gt;&lt;a href=&quot;#intel-sgx笔记&quot; class=&quot;headerlink&quot; title=&quot;intel sgx笔记&quot;&gt;&lt;/a&gt;intel sgx笔记&lt;/h1&gt;&lt;p&gt;本文是根据b站上的sgx介绍视频整理而来的对sgx的基本概念的介绍。&lt;/p&gt;
&lt;p&gt;intel sgx是使得程序能够在可信的环境下执行代码并保护机密信息，从而让开发者直接控制程序的安全性。&lt;br&gt;intel sgx在内存中划定了名为安全区（enclave）的隔离区域，用来存放代码和数据。&lt;/p&gt;
    
    </summary>
    
      <category term="SGX" scheme="http://yoursite.com/categories/SGX/"/>
    
    
      <category term="SGX" scheme="http://yoursite.com/tags/SGX/"/>
    
  </entry>
  
</feed>
