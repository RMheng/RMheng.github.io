{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"rmheng","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"intel sgx explained阅读笔记","slug":"intel-sgx-explained阅读笔记","date":"2019-07-31T08:17:08.000Z","updated":"2019-07-31T09:20:52.865Z","comments":true,"path":"2019/07/31/intel-sgx-explained阅读笔记/","link":"","permalink":"http://yoursite.com/2019/07/31/intel-sgx-explained阅读笔记/","excerpt":"","text":"本篇文章主要是对SGX经典入门综述intel SGX Explained这本书的阅读笔记。 希望能够坚持下来，在这个过程中得到从英语和知识水平两个方面的提高。 overview之前看的时候还很不连贯，会在最后第2,5章全部读完时再回头重新读一遍时，再进行相关的记录。 computer architecture background本部分主要是对intel目前最为流行的计算机处理器背后的总体架构进行概括，以及运行在这些处理器上的系统所需要的安全特性。 overview同样等第二章全部读完之后再进行阅读。 computational model本部分呈现了一个实现了intel架构的高度简化的计算机模型。 内存是存储单元的数组，使用从0开始的自然数来进行地址标记。它的一个显著特征就是即将读取的内存单元的地址等于最近的写入的地址单元的值。","categories":[],"tags":[{"name":"SGX","slug":"SGX","permalink":"http://yoursite.com/tags/SGX/"}]},{"title":"sgx笔记","slug":"sgx笔记","date":"2019-07-31T05:23:58.000Z","updated":"2019-07-31T06:20:40.771Z","comments":true,"path":"2019/07/31/sgx笔记/","link":"","permalink":"http://yoursite.com/2019/07/31/sgx笔记/","excerpt":"","text":"intel sgx笔记intel sgx是使得程序能够在可信的环境下执行代码并保护机密信息，从而让开发者直接控制程序的安全性。intel sgx在内存中划定了名为安全区（enclave）的隔离区域，用来存放代码和数据。 features and benefits 这些不可寻址的分页内存是从系统的物理内存中保留的，并且经过了加密； 安全区是受保护的内存区域，应用程序可以在里面处理它的机密数据而不必担心泄露； 包含intel SGX技术的应用程序分为两个部分，分别是可信部分和不可信部分。当应用程序需要处理机密时，会创建一个位于可信内存的安全区，然后调用可信函数。可信函数是由开发者创建的，专门在安全区内执行的函数。一旦这个函数被调用，应用程序就会在可信区域执行，并且明文访问安全区内的代码和数据。而试图从安全区之外的地方访问安全区内存的行为都会被处理器拒绝，即使是系统特权用户的行为。 当可信函数执行完毕之后，安全区的数据依然会保留在可信内存中，而应用程序返回到不可信区域继续执行，并且失去了对可信内存的访问权限。 检测和开启intel SGX应用程序可以使用intel SGX的四个条件 CPU必须支持intel SGX的指令BIOS必须支持intel SGX必须在BIOS设置中开启intel SGX必须安装intel SGX PSW BIOS设置中intel SGX可能的三种选项是启用、禁用以及软件控制 “启用”：严格开启了intel SGX“禁用”：严格关闭了intel SGX“软件控制”：允许包含intel SGX技术的应用程序在系统重启后启用intel SGX安装程序时检查的步骤：检查CPU和BIOS是否支持intel SGX检查intel SGX PSW是否安装，如果没有安装，就安装检查intel SGX是否在BIOS中开启，如果没有开启，则用软件控制开启 应用程序本身的检查 检查intel SGX PSW是否安装检查SGX是否可用，如果不可用，则使其变为启用 如果上述步骤中的任一步骤失败，则说明系统不支持intel SGX。 如何设计intel SGX应用程序所有的intel SGX应用程序都有相同的基本结构，也就是他们在设计时都要遵循一些通用的原则。intel SGX应用程序分成两个部分，可信部分和不可信部分。 应用程序的可信部分由它的安全区（enclaves）组成，一个应用程序可以拥有一个或多个安全区。安全区存储在加密的内存中，并受intel SGX的保护。安全区是可信的，它们一旦被建立就不能被篡改。如果安全区的数据被恶意篡改，就会被CPU检测到，并不会被加载。 可信部分之外的被称为非可信部分，也就是不会被intel SGX保护的应用程序或内存区域。 如果我们需要设计一个intel SGX程序，就需要将程序分成两个不同的部分，需要判断哪些代码应该放在安全区，哪些代码应该放在安全区之外以及可信部分和非可信部分的交互。 划分代码的关键步骤： 确定机密信息 确定机密数据的提供者和使用者(画出机密数据在应用程序中的各个组件的流程图，也就是机密数据的来源和去向) 确定安全边界(划定边界时，需要尽量包含尽可能多的机密数据，并最大限度地减少与非信任代码的交互) 精简安全区的代码在为安全区以及它的接口编写代码时需要记住： 单一系统中，用于运行所有安全区的内存容量是固定的。 安全区的体积应该尽可能地小。当不再需要机密数据时，安全区应该被销毁。 进出安全区的调用会产生性能损失，就和CPU上下文切换一样。 通过一次调用完成大量工作，会比分成多次调用来完成等量的工作更有效率。 安全区定义语言（EDL）intel SGX提供的基本保护措施是安全区的机密数据仅能够被安全区内的代码访问。执行安全区内的代码的唯一方式是通过开发人员创建的接口函数。 每个安全区可以定义一个或多个e-call，e-call是非可信应用程序进入安全区的入口点；安全区也可以定义o-call，o-call使得安全函数可以调用外部的非可信应用程序，而后再返回安全区。ECALL和OCALL共同组成了安全区的接口，这些函数并非由非可信应用程序执行。 处理器对安全区出入口的访问严格控制，同时为了完成出入安全区的转换，必须依序执行特定的CPU指令。 intel SGX SDK把这些底层细节做了抽象，从而让软件开发者可以用熟悉的编程环境进行开发，名为Edger8r的特殊工具会自动为E-CALL和O-CALL生成代理函数，从而应用程序就可以像调用其他C语言函数一样调用它。 Edger8r从EDL文件中读取安全区接口的定义来创建代理函数。 安全区定义语言(enclave definition language,EDL)，EDL文件和声明函数原型的C语言风格的头文件十分相似。 EDL文件由可信区和非可信区组成。E-CALL定义在可信区，而O-CALL定义在非可信区。这些函数原型与C非常相似，但还需要一些额外的关键字。所有能够被非可信程序调用的E-CALL都必须声明为public，每个安全区都至少有一个声明为public的E-CALL，不含public关键字的E-CALL只能被另一个O-CALL执行。 在进行E-CALL或O-CALL调用时，函数参数要从非可信内存和可信内存之间进行封送处理。若函数参数是值传递，对应的封送处理就是单向的。在E-CALL或O-CALL内部进行的更改不会反映到被调用的函数中。 12345678910111213enclave&#123; from \"sgx_tstdc.edl\" import *; trusted&#123; /*define ECALLs here. */ public int my_ecall(int value); int ecall_private(int value); &#125;; untrusted&#123; /*define OCALLs here. */ void an_ocall(int p1,int p2); &#125;;&#125;; 如果函数参数时引用传递，就必须完整地描述数据的封送处理过程，每个指针或参数之前必须有方括号来描述封送处理的方向以及封送处理的元素数量 in关键字表示数据需要封送到E-CALL或O-CALL之内，而如果是out关键字则意味着数据需要从E-CALL或O-CALL封送回调用的函数。如果需要out，则需要在调用E-CALL或O-CALL之前分配好数据的缓冲区。 1public int my_ecall([in] int32_t *value); 如果同时指定了in和out关键字，意味着要进行两个方向的封送处理 1public int my_ecall([in,out] int32_t *value) 在缺省情况下，Edger8r假定数据的缓冲区大小等于参数的sizeof。如果指针指向的是一个数组，那么需要提供count参数来指定需要复制的元素个数 1public int my_ecall([in,count=10] int32_t *array); 如果参数的个数要等到运行的时候才能确定，也可以用另一个函数参数来表示个数 1public int my_ecall([in,count=len] int32_t *array,size_t len); 如果使用in关键字封送一个以’\\0’作为终止符的字符串，可以选择使用string或者是wstring来代替count关键字，string或wstring不能和out关键字一起使用 12public int my_ecall([in,string] int32_t *name);public int my_wecall([in,wstring] wchar_t *unicodename); EDL语言的进阶主题有时需要把void指针传给E-CALL或O-CALL，问题在于边界例程无法知道void类型对应的大小，无法计算封送处理需要的数据缓冲区大小。为了解决这个问题，EDL语法提供了size关键字，通过指定单个元素的大小，边界例程就知道需要拷贝多少数据。在下面的例子中，32个8字节数据将会被封送到E-CALL中。 1public int my_ecall([in,count=32,size=8] void *buffer) 在不希望封送完整的数据缓冲区时，仅仅希望把指针指向的地址传给E-CALL或O-CALL，这可以通过user_check关键字来完成。这样行为传递的指针不进行边界例程的安全检查和数据封送处理，E-CALL和O-CALL将会直接作用于指针的地址。 1public int my_ecall([user_check] void *buff); 只有被声明为public的E-CALL可以被不安全的函数调用，被称之为root E-CALL，由EDL文件中使用的public关键字指定，不含public关键字的E-CALL只能被另一个O-CALL调用，但是，在缺省情况下，O-CALL不能调用任何E-CALL，必须通过allow关键字声明该O-CALL可以调用哪些E-CALL,allow后面跟着允许的E-CALL名称列表。在本例中，O-CALL get_msg_block()只能调用E-CALL update_hash() 123456789101112enclave&#123; from \"sgx_tstdc.edi\" import *; trusted&#123; public void init_hash(); public void get_hash([out] char hash[32]); void update_hash([in,count=len],char *block,size_t len); &#125;; untrusted&#123; size_t get_msg_block() allow(updata_hash); &#125;;&#125; 调试intel SGX应用程序intel SGX安全区可以以debug模式或release模式构建。 debug模式 debug模式下的安全区是可以调试的；可以使用intel SGX调试器附加到上面；查看当前的状态；以及对代码进行逐句调试，就和调试其他程序一样 当在调试intel SGX应用程序时，它很有可能是以debug模式构建的，CPU允许运行任何以debug模式构建的安全区，由于您可以用intel SGX调试器附到安全区上，这些安全区显然是不安全的，所以永远不要在生产环境上部署以debug模式构建的安全区 release模式 release模式构建的安全区无论如何也无法进行调试，CPU严格执行这条限制。对于intel SGX安全区的调试，仍然需要相关的CPU指令支持，这就意味着必须使用随intel SGX SDK安装的intel SGX调试器进行调试，而其他的调试器只会跳过安全区的代码。 intel SGX的数据密封功能intel SGX应用程序也有可能需要把机密数据保存到安全区以外。安全区从本质上来说是无状态的： 当电脑进入睡眠、关机或者应用程序退出时，安全区就会被销毁；应用程序显示将其销毁时，安全区也会被销毁，当安全区被销毁后，其中的所有内容都会丢失。 为了持久保存安全区内存储的数据，必须显式地将其发送到安全区以外的非可信内存中。由于不可信内存是不可信的，所以系统为数据提供密封功能。当数据被密封时，数据在安全区内用密钥加密，这个密钥是直接从CPU中取得的。加密的数据块被称为密封的数据，它只能在创建的电脑上进行解密。 密封数据时可以选择的密钥策略有两种： 安全区标识(MRENCLAVE) 安全区标识策略生成一个该安全区独有的密钥，这就意味着只有同一台电脑的同一个安全区可以解封数据 密封标识(MRSIGNER) 密封标识基于安全区密封授权方的密钥生成一个密钥，这使得一个安全区密封的数据可被另一个安全区解封。只要是同一台电脑，而且软件是由相同开发商开发（密封授权方的密钥相同）即可。该策略可以允许数据被新版应用程序或其他构建版本的应用程序所读取。该方法可以在两个不同的应用程序的两个不同的安全区中共享数据。 这两种策略的相同点是密封数据的电脑的指纹是密钥的一个输入，这就意味着如果密封的数据被复制到了另一台电脑上就无法被解封。 密钥的另一个输入是安全区的debug模式或release模式，debug的安全区无法解封release模式的安全区密封的数据，反之亦然。这项安全机制是用于防止intel SGX调试器在调试debug的安全区时，泄露来自release模式的安全区的数据。 注意，密封数据可能具有非常严重的安全隐患：安全区并不会检验非可信应用程序的真实性，绝不能假设只有自己的应用程序能加载安全区或者说E-CALL一定会按照预期的顺序执行！ 任何人都可以加载安全区，并按照他们希望的顺序执行E-CALL。安全区API绝不能因为密封数据和解封数据而泄露了机密或授予了不该授予的权限。 总而言之，密封数据的功能是为了安全地把机密数据导出到安全区以外，并确保这些机密数据不会被篡改、替换、窃听或者是在解封数据时，被复制到另一台电脑上。","categories":[],"tags":[{"name":"sgx","slug":"sgx","permalink":"http://yoursite.com/tags/sgx/"}]}]}